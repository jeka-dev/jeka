/*
 * Copyright 2014-2024  the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *       https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 *  limitations under the License.
 */

package dev.jeka.core.tool.builtins.base;

import dev.jeka.core.api.depmanagement.*;
import dev.jeka.core.api.depmanagement.artifact.JkArtifactLocator;
import dev.jeka.core.api.depmanagement.resolution.JkDependencyResolver;
import dev.jeka.core.api.depmanagement.resolution.JkResolveResult;
import dev.jeka.core.api.file.JkPathMatcher;
import dev.jeka.core.api.file.JkPathSequence;
import dev.jeka.core.api.file.JkPathTree;
import dev.jeka.core.api.function.JkConsumers;
import dev.jeka.core.api.function.JkRunnables;
import dev.jeka.core.api.java.*;
import dev.jeka.core.api.project.JkBuildable;
import dev.jeka.core.api.project.JkProjectPackaging;
import dev.jeka.core.api.system.JkLog;
import dev.jeka.core.api.testing.JkTestProcessor;
import dev.jeka.core.api.testing.JkTestResult;
import dev.jeka.core.api.tooling.git.JkVersionFromGit;
import dev.jeka.core.api.utils.JkUtilsPath;
import dev.jeka.core.api.utils.JkUtilsString;
import dev.jeka.core.tool.*;
import dev.jeka.core.tool.builtins.scaffold.JkScaffoldOptions;
import dev.jeka.core.tool.builtins.tooling.git.JkGitVersioning;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.function.Consumer;
import java.util.function.Supplier;
import java.util.stream.Collectors;

@JkDoc(
        "Manages the build and execution of code located in 'jeka-src' directory.\n" +
        "The code stands for neither an application nor a library.\n" +
        "For applications, code should contain a class including a main method to:\n\n" +  // double \n needed to proper display in mkdocs
        "  - Run application\n" +
        "  - Create bootable jar\n" +
        "  - Create bootable fat jar, and create Docker images."
)
@JkDocUrl("https://jeka-dev.github.io/jeka/reference/kbeans-base/")
public final class BaseKBean extends KBean implements JkBuildable.Supplier {

    public static final String CREATE_JAR_ACTION = "create-jar";

    @JkDoc("Space separated list of options to pass to the JVM that will run the program.")
    public String jvmOptions = "";

    @JkDoc("Space separated list of program arguments to pass to the command line running the program.")
    public String programArgs = "";

    @JkDoc("Group and name for publication, formatted as 'groupId:nameId'.")
    public String moduleId;

    @JkDoc("Type of jar to produce for the main artifact.")
    public JkProjectPackaging.JarType jarType = JkProjectPackaging.JarType.FAT;

    public JkGitVersioning gitVersioning = JkGitVersioning.of();

    @JkDoc
    final BaseScaffoldOptions scaffold = new BaseScaffoldOptions();

    /**
     * Actions to execute when {@link BaseKBean#pack()} is invoked.<p>
     * By default, the build action creates a fat jar. It can be
     * replaced by an action creating other jars/artifacts or doing special
     * action as publishing a Docker image, for example.
     */
    public final JkRunnables packActions = JkRunnables.of();

    public final JkConsumers<JkManifest> manifestCustomizers = JkConsumers.of();

    private Supplier<String> mainClassFinder = this::findMainClass;

    private JkModuleId module;

    private Supplier<JkVersion> versionSupplier = () -> JkVersion.UNSPECIFIED;

    private Consumer<Path> jarMaker = this::fatJar;

    private JkBaseScaffold baseScaffold;

    @Override
    protected void init() {
        baseScaffold = JkBaseScaffold.of(this);
        packActions.append(CREATE_JAR_ACTION, this::buildJar);
        if (!JkUtilsString.isBlank(moduleId)) {
            setModuleId(this.moduleId);
        }
        if (gitVersioning.enable) {
            JkVersionFromGit.of(getBaseDir(), gitVersioning.tagPrefix).handleVersioning(this);
        }
        setMainArtifactJarType(jarType);
    }

    // We can not just run Application#main cause Spring-Boot seems
    // requiring that the Java process is launched using Spring-Boot application class
    @JkDoc("Launches application")
    public void runMain() {
        Path tempDirClass = JkUtilsPath.createTempDirectory("jk-");
        getAppClasses().copyTo(tempDirClass);
        JkJavaProcess.ofJava(getMainClass())
                .setClasspath(JkPathSequence.of(tempDirClass).and(getAppClasspath()))
                .setInheritIO(true)
                //.setInheritSystemProperties(true)
                .setDestroyAtJvmShutdown(true)
                .addJavaOptions(JkUtilsString.parseCommandline(jvmOptions))
                .addParams(JkUtilsString.parseCommandline(programArgs))
                .exec();
        JkPathTree.of(tempDirClass).createIfNotExist();
    }

    @JkDoc("Launches test suite")
    public void test() {
        if ("true".equals(getRunbase().getProperties().get(JkConstants.TEST_SKIP_PROP))) {
            JkLog.info("Tests are skipped.");
            return;
        }

        //
        boolean hasDev = JkUtilsPath.listDirectChildren(getBaseDir().resolve(JkConstants.JEKA_SRC_DIR)).stream()
                .filter(Files::isDirectory)
                .anyMatch(path -> path.getFileName().toString().startsWith("_"));
        if (!hasDev) {
            JkLog.info("No '_dev' folder found. No test to run.");
            return;
        }
        if (!JkTestProcessor.isEngineTestPresent()) {
            throw new JkException("No test engine class found in current classloader. " +
                    "You should add @JkDep(\"org.junit.jupiter:junit-jupiter\") dependencies " +
                    "to the classpath for testing.");
        }

        Supplier<JkPathSequence> classpathSupplier = this.getRunbase()::getClasspath;
        Supplier<Iterable<Path>> rootClassSupplier = () -> this.getBaseDir().resolve(JkConstants.JEKA_SRC_CLASSES_DIR);
        JkTestResult testResult = JkTestProcessor.of(classpathSupplier, rootClassSupplier)
                .setForkingProcess(true)
                .run();
        if (!testResult.getFailures().isEmpty()) {
            System.exit(1);
        }
    }

    @JkDoc("Creates runnable fat jar and optional artifacts.")
    public void pack() {
        packActions.run();
    }

    @JkDoc("Runs tests then 'pack'.")
    public void build() {
        test();
        pack();
    }

    @JkDoc("Runs fat jar.")
    public void runJar() {
        this.prepareRunJar().exec();
    }

    @JkDoc("Displays info about this base KBean.")
    public void info() {
        StringBuilder sb = new StringBuilder();
        sb.append("Module Id    : " + this.module).append("\n");
        sb.append("Version      : " + this.getVersion()).append("\n");
        sb.append("Jar Type     : " + this.jarType).append("\n");
        sb.append("Main Class   : " + this.getMainClass()).append("\n");
        sb.append("JVM Options  : " + jvmOptions).append("\n");
        sb.append("Program Args : " + programArgs).append("\n");
        sb.append("Class Files  : ").append("\n");
        this.getAppClasses().getRelativeFiles().stream()
                .forEach(path -> sb.append("  " + path + "\n"));
        sb.append("Classpath    : ").append("\n");
        this.getAppClasspath().forEach(path -> sb.append("  " + path + "\n"));
        sb.append("Manifest     : ").append("\n");
        Arrays.stream(getManifest().asString().split("\n"))
                .forEach(line -> sb.append("  " + line + "\n"));
        JkLog.info(sb.toString());
    }

    @JkDoc("Displays exported dependency tree on console.")
    public void depTree() {
        JkDependencySet deps = getRunbase().getExportedDependencies()
                .andVersionProvider(JkConstants.JEKA_VERSION_PROVIDER);
        String output = getRunbase().getDependencyResolver().resolve(deps)
                .getDependencyTree().toStringTree();
        JkLog.info(output);
    }

    @JkDoc("Creates a skeleton in the current working directory.")
    public void scaffold() {
        baseScaffold.run();
    }

    /**
     * Builds a JAR file using the provided jarMaker
     */
    public BaseKBean buildJar() {
        jarMaker.accept(getJarPath());
        return this;
    }

    /**
     * Returns the path to the JAR file created by {@link #buildJar()} method.
     */
    public Path getJarPath() {
        return Paths.get(getJarPathBaseName() + ".jar");
    }

    /**
     * Returns the base name of the JAR file path created by the {@link #buildJar()} method.
     */
    public String getJarPathBaseName() {
        return getBaseDir().resolve(JkConstants.OUTPUT_PATH).resolve(getBaseDirName()).toString();
    }

    /**
     * Sets the jarMaker for creating a runnable fat jar.
     */
    public BaseKBean setJarMaker(Consumer<Path> jarMaker) {
        this.jarMaker = jarMaker;
        return this;
    }

    /**
     * Sets the version supplier for this BaseKBean. The version represents the
     * version of the application/library.
     */
    public BaseKBean setVersionSupplier(Supplier<JkVersion> versionSupplier) {
        this.versionSupplier = versionSupplier;
        return this;
    }

    /**
     * Sets the version for this BaseKBean. The version represents the
     * version of the application/library.
     */
    public BaseKBean setVersion(String version) {
        this.versionSupplier = ()  -> JkVersion.of(version);
        return this;
    }

    /**
     * Returns the version of the application/library. The version might be used in Manifest file,
     * docker image name or Maven publication.
     */
    public JkVersion getVersion() {
        return versionSupplier.get();
    }

    /**
     * Returns the module ID for this object.
     * The module ID is used for naming Docker image and in Maven publication.
     */
    public JkModuleId getModuleId() {
        return module;
    }

    /**
     * Sets the module ID for this object. The module id might be used for naming Docker image
     * and in Maven publication.
     *
     * @param moduleId The module ID formatted as <i>group:name</i>.
     */
    public BaseKBean setModuleId(String moduleId) {
        this.module = JkModuleId.of(moduleId);
        return this;
    }

    /**
     * Returns the actual main class to be used for launching the application or executable JAR.
     * This method returns <code>null</code> if no main class has been detected.
     */
    public String getMainClass() {
        return mainClassFinder.get();
    }

    /**
     * Returns the JkBaseScaffold object associated with this BaseKBean.
     * The JkBaseScaffold provides methods for configuring the project scaffold,
     * such as adding file entries and setting options.
     */
    public JkBaseScaffold getBaseScaffold() {
        return baseScaffold;
    }

    /**
     * Sets the main class finder for this project. The main class finder is responsible for
     * providing the name of the main class to use in the project. This can be used for running
     * the project or building Docker images.
     */
    public BaseKBean setMainClassFinder(Supplier<String> mainClassFinder) {
        this.mainClassFinder = mainClassFinder;
        return this;
    }

    /**
     * Returns the application classpath. This contains class dir + libraries.
     */
    public List<Path> getAppClasspath() {
        return getRunbase().getExportedClasspath().getEntries();
    }

    /**
     * Returns a List of Path objects representing the libraries used by the application.
     * It contains the classpath minus the class dir.
     */
    public List<Path> getAppLibs() {
        return getAppClasspath().stream()
                .filter(entry -> !entry.toAbsolutePath().normalize()
                        .equals(getAppClasses().getRoot().toAbsolutePath().normalize()))
                .collect(Collectors.toList());
    }

    /**
     * Returns a {@link JkPathTree} representing the class files and sub-folders contained in the "bin" directory.
     * The tree includes all files in the root directory and its subdirectories,
     * except for files matching the specified patterns.
     */
    public JkPathTree getAppClasses() {
        return JkPathTree.of(getBaseDir().resolve(JkConstants.JEKA_SRC_CLASSES_DIR))
                .andMatching(false, "_*", "_*/**", ".*", "**/.*");
    }

    /**
     * Returns the {@link JkManifest} for the application.
     * The manifest includes the created by attribute,
     * the main class attribute, and the build JDK attribute.
     */
    public JkManifest getManifest() {
        JkManifest manifest = JkManifest.of()
                .addImplementationInfo(getModuleId(), getVersion())
                .addMainClass(getMainClass())
                .addBuildInfo();
        manifestCustomizers.accept(manifest);
        return manifest;
    }

    /**
     * Creates a main JAR file at the specified target path.
     */
    public void createMainJar(Path target) {
        jarMaker.accept(target);
    }

    /**
     * Creates a Javadoc Jar file at the specified target path.
     */
    public void createJavadocJar(Path target) {
        JkUtilsPath.deleteIfExists(target);
        Path tempFolder = JkUtilsPath.createTempDirectory("jk-self-sources");
        JkJavadocProcessor.of()
                .make(getAppLibs(), getAppSources().toSet(), tempFolder);
        JkPathTree.of(tempFolder).zipTo(target);
        JkPathTree.of(tempFolder).deleteRoot();
    }

    /**
     * Creates a source JAR file at the specified target path.
     */
    public void createSourceJar(Path target) {
        JkUtilsPath.deleteIfExists(target);
        getAppSources().zipTo(target);
    }

    /**
     * Returns a JkPathTree representing the application sources.
     */
    public JkPathTree getAppSources() {
        return JkPathTree.of(getBaseDir().resolve(JkConstants.JEKA_SRC_DIR)).withMatcher(
                JkConstants.PRIVATE_IN_DEF_MATCHER.negate());
    }

    /**
     * Prepares a {@link JkJavaProcess ready to run.
     */
    public JkJavaProcess prepareRunJar() {
        Path jarPath = getJarPath();
        if (!Files.exists(jarPath)) {
            buildJar();
        }
        return JkJavaProcess.ofJavaJar(getJarPath())
                .setLogCommand(true)
                .setInheritIO(true)
                .setDestroyAtJvmShutdown(true)
                .addJavaOptions(JkUtilsString.parseCommandline(jvmOptions))
                .addParams(JkUtilsString.parseCommandline(programArgs));
    }

    public BaseKBean setMainArtifactJarType(JkProjectPackaging.JarType jarType) {
        if (jarType == JkProjectPackaging.JarType.REGULAR) {
            jarMaker = this::regularJar;
        } else if (jarType == JkProjectPackaging.JarType.FAT) {
           jarMaker = this::fatJar;
        } else if (jarType == JkProjectPackaging.JarType.SHADE) {
            jarMaker = this::shadeJar;
        } else {
            throw new IllegalArgumentException("Jar type " + jarType + " is not handled.");
        }
        return this;
    }

    private String findMainClass() {
        JkUrlClassLoader ucl = JkUrlClassLoader.of(getBaseDir().resolve(JkConstants.JEKA_SRC_CLASSES_DIR));
        return ucl.toJkClassLoader().findClassesHavingMainMethod().stream()
                .filter(candidate -> !candidate.startsWith("_"))
                .findFirst()
                .orElse("dev.jeka.core.tool.Main");
    }

    private void fatJar(Path jarPath) {
        JkLog.startTask("create-fat-jar");
        JkJarPacker.of(getAppClasses())
                .withManifest(getManifest())
                .makeFatJar(jarPath, getAppLibs(), JkPathMatcher.of());
        JkLog.info("Jar created at : " + jarPath);
        JkLog.endTask();

    }

    private void regularJar(Path jarPath) {
        JkLog.startTask("create-bin-jar");
        JkJarPacker.of(getAppClasses())
                .withManifest(getManifest())
                .makeJar(jarPath);
        JkLog.info("Jar created at : " + jarPath);
        JkLog.endTask();
    }

    private void shadeJar(Path jarPath) {
        JkLog.startTask("create-shade-jar");
        Path mainJar = JkUtilsPath.createTempFile("jk_original-shade-", ".jar");
        JkUtilsPath.deleteIfExists(mainJar);;
        regularJar(mainJar);
        Iterable<Path> classpath = getAppClasspath();
        JkRepoSet repos = getRunbase().getDependencyResolver().getRepos();
        JkJarPacker.makeShadeJar(repos, mainJar, classpath, jarPath);
        JkUtilsPath.deleteIfExists(mainJar);;
        JkLog.info("Shade jar created at: " + jarPath);
        JkLog.endTask();
    }

    public static class BaseScaffoldOptions extends JkScaffoldOptions {

        @JkDoc("Kind of Jeka base to generate.")
        public JkBaseScaffold.Kind kind = JkBaseScaffold.Kind.JEKA_SCRIPT;

    }

    public JkBuildable asBuildable() {

        return new JkBuildable() {

            @Override
            public JkArtifactLocator getArtifactLocator() {
                return JkArtifactLocator.of(BaseKBean.this.getBaseDir(),
                        BaseKBean.this.getJarPathBaseName());
            }

            @Override
            public Path getClassDir() {
                Path tempDirClass = JkUtilsPath.createTempDirectory("jk-");
                BaseKBean.this.getAppClasses().copyTo(tempDirClass);
                return tempDirClass;
            }

            @Override
            public JkResolveResult resolveRuntimeDependencies() {
                JkDependencySet deps = getRunbase().getExportedDependencies()
                        .andVersionProvider(JkConstants.JEKA_VERSION_PROVIDER);
                return getRunbase().getDependencyResolver().resolve(deps);
            }



            @Override
            public List<Path> getRuntimeDependenciesAsFiles() {
                return BaseKBean.this.getAppClasspath();
            }

            @Override
            public JkVersion getVersion() {
                return BaseKBean.this.getVersion();
            }

            @Override
            public JkModuleId getModuleId() {
                return BaseKBean.this.getModuleId();
            }

            @Override
            public Path getOutputDir() {
                return BaseKBean.this.getOutputDir();
            }

            @Override
            public Path getBaseDir() {
                return BaseKBean.this.getBaseDir();
            }

            @Override
            public String getMainClass() {
                return BaseKBean.this.getMainClass();
            }

            @Override
            public void compileIfNeeded() {
                // base source are always compiled when running
            }

            @Override
            public JkDependencyResolver getDependencyResolver() {
                return getRunbase().getDependencyResolver();
            }

            @Override
            public Path getMainJarPath() {
                return BaseKBean.this.getJarPath();
            }

            @Override
            public Adapted getAdapted() {
                return Adapted.BASE;
            }

            @Override
            public boolean compile(JkJavaCompileSpec compileSpec) {
                return JkJavaCompilerToolChain.of().compile(compileSpec) != JkJavaCompilerToolChain.Status.FAILED;
            }

            @Override
            public JkDependencySet getCompiledDependencies() {
                return BaseKBean.this.getRunbase().getExportedDependencies();
            }

            @Override
            public JkDependencySet getRuntimesDependencies() {
                return BaseKBean.this.getRunbase().getExportedDependencies();
            }

            @Override
            public JkCoordinate.ConflictStrategy getDependencyConflictStrategy() {
                return JkCoordinate.ConflictStrategy.TAKE_FIRST;
            }

            @Override
            public void createSourceJar(Path targetFile) {
                BaseKBean.this.createSourceJar(targetFile);
            }

            @Override
            public void createJavadocJar(Path targetFile) {
                BaseKBean.this.createJavadocJar(targetFile);
            }

            @Override
            public void setVersionSupplier(java.util.function.Supplier<JkVersion> versionSupplier) {
                BaseKBean.this.setVersionSupplier(versionSupplier);
            }

            @Override
            public JkConsumers<JkManifest> getManifestCustomizers() {
                return BaseKBean.this.manifestCustomizers;
            }

            @Override
            public JkJavaProcess prepareRunJar() {
                return BaseKBean.this.prepareRunJar();
            }

            public String toString() {
                return BaseKBean.this.toString();
            }
        };
    }



}