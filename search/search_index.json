{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to JeKa","text":"<p>JeKa is a modern build tool for Java, designed to simplify and streamline your development experience. It reshapes Java application building for a generation of developers seeking lightweight, accessible, yet powerful solutions.</p>"},{"location":"#next-gen-java-build-tool","title":"Next-Gen Java Build Tool","text":"<p>Java is evolving to become more developer-friendly and cloud-native ready. Developers no longer want to deal with heavy tools,  verbose XML configurations, or external DSLs. JeKa aligns with this vision by offering:</p> <ul> <li>Simplicity at its Core: Configure with properties or pure Java\u2014no XML, no DSL.</li> <li>No Setup Hassle: Start building regular or cloud-native applications immediately, with minimal configuration and requirements.</li> <li>Gradual Complexity: Handle advanced scenarios using intuitive mechanisms without unnecessary complexity.</li> <li>DevOps Bridge: Implement complex pipeline logic with robust Java and share it across your teams.</li> <li>Super-lightweight: JeKa consists of a single zero-dependency JAR under 2MB. Install and upgrade in a flash.</li> </ul>"},{"location":"#ready-to-explore","title":"Ready to explore?","text":"<p>The easiest way to get started is by using the IntelliJ Plugin.  You don't need to install JeKa for that.</p> <ol> <li> <p>Start a new project and play with the scaffolded example. You can have a brief look at the tutorial to get an idea of what you can do.</p> </li> <li> <p>You can create projects in the IDE using Project - Java App/Lib or Project - Spring Boot templates. They scaffold basic projects, providing code and build instructions in <code>README.md</code> files.</p> </li> <li> <p>Explore and experiment with examples.</p> </li> </ol> <p>Have fun!</p>"},{"location":"cheat-sheet/","title":"Cheat Sheet","text":""},{"location":"cheat-sheet/#useful-commands","title":"Useful Commands","text":"Command Description <code>--doc</code> Displays available methods, options, and KBeans. <code>intellij: sync -f</code> Generates <code>.iml</code> file for IntelliJ IDEA. <code>intellij: initProject</code> Initializes IntelliJ IDEA Project. <code>eclipse: sync</code> Same purpose as above to generate metadata files for Eclipse. <code>project: scaffold</code> Generates files to create a basic JeKa project from scratch. <code>project: pack</code> Build JARs and other optional artifacts from a project. <code>base: scaffold</code> Creates files for a base workspace without a project."},{"location":"cheat-sheet/#standard-properties","title":"Standard Properties","text":"Property Name Default Value Description jeka.version The JeKa version to use. It will be fetched from the repository specified in the <code>jeka.distrib.repo</code> property. Use <code>jeka.version=.</code> to force the use of the locally installed version. jeka.distrib.location The exact location (directory) to get the JeKa distribution. If set, both <code>jeka.version</code> and <code>jeka.distrib.repo</code> will be ignored. jeka.java.version The version of the JDK used to run JeKa and compile code located in <code>jeka-src</code>. jeka.java.distrib <code>temurin</code> The distribution of JDK to fetch when <code>jeka.java.version</code> is mentioned. Should be 21 or higher. jeka.repos.download <code>local, mavenCentral</code> Comma-separated string of repositories to fetch Maven dependencies. More details here. jeka.repos.publish Comma-separated string of repositories to publish Maven artifacts. More details here. jeka.program.build <code>project: pack -Djeka.test.skip=true</code> Command line to execute to build the project when execution files are absent. jeka.kbean.default Name or class name of the KBean to use as default (when none is specified). jeka.test.skip Skip tests when building projects or codebases. jeka.platform.os linux, windows or mac Provides the OS of the running machine."},{"location":"cheat-sheet/#jdk-selection-rules","title":"JDK Selection Rules","text":"<ol> <li>If <code>JEKA_JDK_HOME</code> is set, use this JDK.</li> <li>If <code>jeka.java.version</code> is specified:<ul> <li>Use JDK from <code>jeka.jdk.[version]</code> if available.</li> <li>Otherwise, fetch JDK from local cache or download it.</li> </ul> </li> <li>If no version is specified:<ul> <li>Use JDK from <code>JAVA_HOME</code> if set.</li> <li>Otherwise, fetch JDK 21 from local cache or download it.</li> </ul> </li> </ol>"},{"location":"cheat-sheet/#how-jeka-reads-properties","title":"How JeKa Reads Properties","text":"<p>JeKa reads properties in this order:</p> <ul> <li>Command-line arguments (as <code>-Dmy.prop=xxx</code>).</li> <li>Environment variables (<code>my.prop</code> or <code>MY_PROP</code>).</li> <li>The <code>jeka.properties</code> file in the base directory.</li> <li>The <code>jeka.properties</code> file in parent directories, until it is not found.</li> <li>The <code>global.properties</code> file in <code>[JEKA_USER_HOME]</code>.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>You can find some examples below to learn more about JeKa:</p>"},{"location":"examples/#zero-configuration-build-and-run","title":"Zero-Configuration Build and Run","text":"<ul> <li>Java Project</li> <li>Java Projectless Codebase</li> </ul>"},{"location":"examples/#run-from-git","title":"Run from Git","text":"<ul> <li>Cowsay Command-Line App</li> <li>Calculator GUI App</li> <li>A collection of developer utilities in a single JavaFX application</li> </ul>"},{"location":"examples/#builds-and-pipelines","title":"Builds and Pipelines","text":"<ul> <li>Publish a Java Lib on Maven Central</li> <li>Spring Boot App</li> <li>Spring Boot App - Java configuration</li> <li>Spring Boot - Angular - SonarQube - Docker - E2E testing</li> </ul>"},{"location":"examples/#multi-module-projects","title":"Multi-module Projects","text":"<ul> <li>Core and plugin modules in a single project</li> </ul>"},{"location":"examples/#reuse-build-conventions","title":"Reuse Build Conventions","text":"<ul> <li>Spring Boot - ReactJS - built with only 3 lines of configuration</li> </ul>"},{"location":"examples/#combine-with-maven","title":"Combine with Maven","text":"<ul> <li>JeKa wrapping a Quarkus native app Maven build</li> <li>JeKa wrapping a Spring Boot native Maven build</li> </ul>"},{"location":"examples/#native-and-docker-images","title":"Native and Docker Images","text":"<ul> <li>Spring Boot Docker Native Images</li> <li>Kotlin Spring Boot ReactJS Docker Native Image</li> </ul>"},{"location":"examples/#kotlin-and-reactjs","title":"Kotlin and ReactJS","text":"<ul> <li>Kotlin Spring Boot ReactJS App</li> </ul>"},{"location":"examples/#others","title":"Others","text":"<ul> <li> <p>Samples are used for testing JeKa.</p> </li> <li> <p>Miscellaneous examples are more complex use case demos.</p> </li> </ul>"},{"location":"external-resources/","title":"External Resources","text":"<p>You can find some resources below to learn more about JeKa:</p> <ul> <li>Dev.to series about \"JeKa: The simplest way to...\"</li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"faq/#network-security","title":"Network - Security","text":""},{"location":"faq/#my-organization-prevents-access-to-maven-central-what-can-i-do","title":"My organization prevents access to Maven Central. What can I do?","text":"<p>You can configure Maven repositories in a central place by editing the <code>[USER HOME]/.jeka/global.properties</code> file.</p> <pre><code>jeka.repos.download=https://my.company/repo\n\n# You can specify username/password\njeka.repos.download.username=myName\njeka.repos.download.password=myPassw0rd!\n\n# ... or specify Authorization header to avoid password in clear\njeka.repos.download.headers.Authorization=Basic hKXhhtggjREfg4P=\n</code></pre> <p>To fetch JeKa distributions, specify the <code>jeka.distrib.location</code> property, pointing to a folder.  This property is better placed in the <code>jeka.properties</code> file, as it may vary from one project to another.</p>"},{"location":"faq/#my-organization-prevents-downloading-jdks-what-can-i-do","title":"My organization prevents downloading JDKs. What can I do?","text":"<p>You can specify a local location for each JDK version you are using as follows: <pre><code>jeka.jdk.11=/my/path/to/jdk11/home\njeka.jdk.17=/my/path/to/jdk17/home\n...\n</code></pre> This information can be stored in the project's <code>jeka.properties</code> file, in <code>[USER HOME]/.jeka/global.properties</code>, or passed as environment variables.</p>"},{"location":"faq/#im-behind-a-proxy-how-should-i-configure-jeka","title":"I'm behind a proxy, how should I configure JeKa?","text":"<p>JeKa just leverages the standard Java mechanism to handle proxies. For example, you can:</p> <ul> <li>Set the <code>JAVA_TOOL_OPTIONS</code> environment variable to <code>-Dhttps.proxyHost=my.proxy.host -Dhttps.proxyPort=8888</code>.</li> <li>Or specify proxy properties to the JeKa command line, such as: <code>-Dhttps.proxyHost=my.proxy.host -Dhttps.proxyPort=8888</code>.</li> </ul> <p>See here for more details on arguments.</p>"},{"location":"faq/#legacy-tools","title":"Legacy Tools","text":""},{"location":"faq/#how-can-i-use-mavengradle-in-conjunction-with-jeka","title":"How can I use Maven/Gradle in conjunction with JeKa?","text":"<p>Nothing prevents using JeKa alongside Maven or Gradle in the same project, except that in an IDE, synchronization may interfere between the two systems.</p> <p>To avoid this, the <code>jeka-src</code> folder should exist in its own IntelliJ module. JeKa provides a simple way to achieve this.</p> <p>From an existing Maven/Gradle project, execute: <pre><code>jeka base: scaffold\n</code></pre> Edit the <code>jeka.properties</code> file, and add: <pre><code>@intellij.splitModule=true\n</code></pre> Generate the <code>.iml</code> file by synchronizing within the IDE, or by running: <pre><code>jeka intellij: sync\n</code></pre> In IntelliJ, go to <code>Project Settings</code> -&gt; <code>Modules</code> -&gt; <code>Import Module</code> -&gt; choose <code>[project dir]/.idea/xxxx-jeka.iml</code>.</p>"},{"location":"faq/#how-can-i-migrate-my-project-from-maven","title":"How can I migrate my project from Maven?","text":"<p>JeKa helps translate all dependencies declared in a Maven project into the equivalent Java code.</p> <p>Assuming Maven is already installed and there is a <code>pom.xml</code> file at the root of the project,  execute <code>jeka maven: migrateDeps</code> to display the Java code/configuration to  copy-paste into a build class or <code>jeka.project.deps</code> file.</p>"},{"location":"faq/#performancecaching","title":"Performance\u2014Caching","text":""},{"location":"faq/#how-to-cache-downloaded-dependencies-in-github-actions","title":"How to cache downloaded dependencies in GitHub Actions?","text":"<p>JeKa caches downloaded dependencies (JDKs, JeKa distributions, Maven artifacts, Node.js executables, etc.) in a single  directory at <code>[USER HOME]/.jeka/cache</code>.</p> <p>When running as a GitHub Action, this directory is empty at the start of the build. We need to save/restore it in  order to make it persist from one build to another.</p> <p>For this, we can use the cache action as follows: <pre><code>    - name: Restore JeKa cache\n      uses: actions/cache/restore@v4\n      with:\n        path: ~/.jeka/cache\n        key: ${{ runner.os }}\n\n    - name: Run some JeKa commands\n      run: \"./jeka project: pack ...\"\n\n    - name: Save JeKa cache\n      uses: actions/cache/save@v4\n      with:\n        path: ~/.jeka/cache\n        key: ${{ runner.os }}\n</code></pre></p>"},{"location":"faq/#errors","title":"Errors","text":""},{"location":"faq/#junit-platform","title":"JUnit Platform","text":"<p>I see this error message when I launch tests. What can I do? <pre><code>OutputDirectoryProvider not available; probably due to unaligned versions of the junit-platform-engine and junit-platform-launcher jars on the classpath/module path.\n</code></pre> You can explicitly declare the JUnit component versions in <code>jeka.project.deps</code> as: <pre><code>[test]\norg.junit.platform:junit-platform-launcher:1.12.2\norg.junit.jupiter:junit-jupiter:5.12.2\n</code></pre></p>"},{"location":"faq/#misc","title":"Misc","text":""},{"location":"faq/#how-do-i-configure-projects-from-code","title":"How do I configure projects from code?","text":"<p>If you want to configure a project programmatically, either within the project itself or to create a plugin, you should access the <code>JkProject</code> instance directly instead of using the <code>ProjectKBean</code>.</p> <p>The <code>ProjectKBean</code> initializes the project and configures it with its own settings in its <code>init</code> method. After that, it should not be modified. If you change the <code>ProjectKBean</code> instance in your code, the underlying <code>JkProject</code> instance will already have been configured by the <code>ProjectKBean</code>, meaning your changes will have no effect.</p> <pre><code>public class Build extends KBean {\n\n    JkProject project = load(ProjectKBean.class).project;\n\n    @Override\n    protected void init() {\n        project.testing.testProcessor.engineBehavior.setProgressDisplayer(STEP);\n    }\n}\n</code></pre>"},{"location":"faq/#how-can-i-use-the-eclipse-compiler-in-jeka","title":"How can I use the Eclipse compiler in JeKa?","text":"<p>JeKa can use any JSR199 Java compiler to compile your Java code. Just set the compiler instance you need as follows:</p> <pre><code>import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler;\n\n@JkDep(\"org.eclipse.jdt.core.compiler:ecj:4.6.1\")\npublic class Build extends KBean {\n\n    @Override\n    protected void init() {\n        JkProject project = load(ProjectKBean.class).project;\n        project.compilerToolChain.setCompileTool(new EclipseCompiler());\n\n        // You may pass additional options to the compiler\n        project.compilation.addJavaCompilerOptions(\"-nowarn\");\n    }\n}\n</code></pre>"},{"location":"faq/#how-can-i-sync-eclipseintellij-without-using-projectkbean","title":"How can I sync Eclipse/IntelliJ without using <code>ProjectKBean</code>?","text":"<p><code>ProjectKBean</code> and <code>BaseKBean</code> provide IDE synchronization out-of-the-box, but you may prefer not to use them.</p> <p>If you use a different structure to build your project, simply let your <code>KBean</code> implement <code>JkJavaIdeSupport</code> and implement the required method to provide the information necessary to generate IDE metadata files.</p> <p>For synchronization, just execute <code>jeka intellij: sync</code> as usual.</p>"},{"location":"installation/","title":"CLI Installation","text":""},{"location":"installation/#windows","title":"Windows","text":"<pre><code>iex \"&amp; { $(iwr -useb https://jeka.dev/install.ps1) } install check\"\n</code></pre>"},{"location":"installation/#sdkman","title":"SDKMAN!","text":"<pre><code>sdk install jeka\n</code></pre>"},{"location":"installation/#macos-and-linux","title":"MacOS and Linux","text":"<pre><code>curl -sL https://jeka.dev/install.sh | $(echo $0) -s - install check\n</code></pre> <p>Note</p> <p>JeKa requires bash, curl, and unzip, usually available on macOS and Linux. On Ubuntu, install tools with:  <pre><code>apt-get update &amp;&amp; apt-get install -y curl unzip git gcc zlib1g-dev\n</code></pre></p>"},{"location":"installation/#manual-installation","title":"Manual installation","text":"<p>The manual installation is straightforward and may help when script installation fails.</p> <ul> <li>Download latest JeKa distrib from maven central   and download file named jeka-core-xxx-distrib.zip.</li> <li>Unzip the content of the zip file and copy the content of the <code>bin</code> directory to <code>[USER HOME]/.jeka/bin</code>. </li> <li>Add <code>[USER HOME]/.jeka/bin</code> and <code>[USER HOME]/.jeka/apps</code> to your <code>PATH</code> environment variable.</li> </ul>"},{"location":"installation/#post-install","title":"Post Install","text":"<p>Installation via scripts may include a sanity check that triggers a JDK download (because of the <code>check</code> argument passed to the install script).</p> <p>Once installed, you will rarely need to upgrade, as JeKa will execute the JeKa version specified in the application to run. However, you'll be able to upgrade your base install by executing: <pre><code>jeka-update\n</code></pre></p> <p>Open a new terminal session and execute the following command to access JeKa help: <pre><code>jeka --help\n</code></pre></p>"},{"location":"installation/#docker-image-zero-install","title":"Docker Image - Zero Install","text":"<p>JeKa can be executed using the Docker image jekadev/jeka.</p> <p>To do this, execute: </p> <ul> <li>Linux/macOS: <code>docker run -v $HOME/.jeka/cache4c:/cache -v .:/workdir jekadev/jeka [JEKA ARGUMENTS]</code></li> <li>Windows PowerShell: <code>docker run -v ${HOME}\\.jeka\\cache4c:/cache -v ${PWD}:/workdir jekadev/jeka [JEKA ARGUMENTS]</code></li> <li>Windows cmd: <code>docker run -v %USERPROFILE%\\.jeka\\cache4c:/cache -v %cd%:/workdir jekadev/jeka [JEKA ARGUMENTS]</code></li> </ul> <p>Note</p> <p><code>-v $HOME/.jeka/cache4c:/cache</code> </p> <p>Tells JeKa to use a specific cache when running with a container, as JDK or other tools  cached by JeKa may differ from the ones used by the host system.</p> <p><code>-v .:/workdir</code> </p> <p>Lets JeKa operate in the current directory of the host machine.</p> <p><code>[JEKA ARGUMENTS]</code> </p> <p>Stands for regular JeKa arguments you would pass to JeKa command line such as <code>project: pack</code> or <code>--help</code>.</p>"},{"location":"migration-guide/","title":"Migration Guide","text":"<p>This page helps you migrate from JeKa 0.10 to JeKa 0.11.</p>"},{"location":"migration-guide/#command-line-and-wrapper","title":"Command Line and Wrapper","text":"<p>The command line has been unified: <code>jekaw</code> has been replaced by <code>jeka</code>.</p> <p>The wrapper is now entirely included in the shell scripts.</p> <p>The <code>jeka.version</code> property is now located in the <code>jeka.properties</code> file along with other properties.</p>"},{"location":"migration-guide/#project-structure","title":"Project Structure","text":"<p>The nested <code>jeka</code> directory has been removed in favor of a flat structure.</p> <p>Also, the entire wrapper is contained inside shell scripts, so the <code>jeka/wrapper</code> directory is no longer needed.</p> <ul> <li><code>jeka/def</code> directory -&gt; <code>jeka-src</code></li> <li><code>jeka/output</code> -&gt; <code>jeka-output</code></li> <li><code>jeka/.work</code> -&gt; <code>.jeka-work</code></li> <li><code>jeka/local.properties</code> -&gt; <code>jeka.properties</code></li> <li><code>jekaw.bat</code> -&gt; <code>jeka.ps1</code></li> <li><code>jekaw</code> -&gt; <code>jeka</code></li> <li><code>jeka/project-dependencies.txt</code> -&gt; <code>jeka.project.deps</code></li> <li><code>jeka/project-libs</code> directory -&gt; <code>libs</code></li> </ul>"},{"location":"migration-guide/#major-api-changes","title":"Major API Changes","text":"<ul> <li>KBean classes are now suffixed with <code>KBean</code> instead of <code>JkBean</code> (e.g., <code>ProjectKBean</code>).</li> <li><code>JkBean.getBean()</code> -&gt; <code>KBean.load()</code></li> </ul>"},{"location":"migration-guide/#properties","title":"Properties","text":"<ul> <li><code>jeka.classpath.inject</code> -&gt; <code>jeka.inject.classpath</code></li> <li>KBean field reference has changed from <code>myKBean#xxx</code> to <code>@myKBean.xxx</code>.</li> </ul>"},{"location":"migration-guide/#command-line","title":"Command Line","text":"<ul> <li>KBean method invocation has changed from <code>myKBean#pack</code> to <code>myKBean: pack</code>.</li> </ul> <p>Example: <code>project#pack project#tests.skip=true</code></p> <p>Is now: <code>project: pack tests.skip=true</code> </p> <ul> <li>Use <code>jeka --help</code> as a starting point for command-line help.</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":"<p>Welcome to JeKa! This guide will help you get up and running in minutes.</p>"},{"location":"quick-start/#installation","title":"Installation","text":"<p>You can get JeKa in two ways:</p> <ul> <li>IntelliJ Plugin (Recommended): Install the JeKa Plugin. It's the fastest way to start, providing wizards for scripts, apps, and Spring Boot projects.</li> <li>CLI: Install JeKa CLI manually or via SDKMAN!: <code>sdk install jeka</code>.</li> </ul>"},{"location":"quick-start/#choose-your-path","title":"Choose Your Path","text":"<p>This guide covers several use cases:</p> <ul> <li>Create scripts in Java to automate your tasks.</li> <li>Create a Base Application or Library for simple, pure Java projects.</li> <li>Create a Java Project for more complex, standard layouts.</li> <li>Create a Spring Boot Project with a pre-configured setup.</li> </ul> <p>IntelliJ IDEA Users</p> <p>After scaffolding or modifying dependencies, synchronize your project by executing: <pre><code>jeka intellij: sync\n</code></pre></p>"},{"location":"quick-start/#create-scripts","title":"Create Scripts","text":"<p>Create a directory to host the codebase. Navigate into it and execute: <pre><code>jeka base: scaffold\n</code></pre> This generates a structure as: <pre><code>.                        &lt;- Project root directory\n\u251c\u2500\u2500 jeka-src             &lt;- Source dir for JeKa scripts and configuration code\n\u2502   \u2514\u2500\u2500 Script.java     \n\u2514\u2500\u2500 jeka.properties      &lt;- JeKa configuration (Java and JeKa version, default parameters...)\n</code></pre> This script class looks like: <pre><code>@JkDoc(\"Minimalist script for demo purpose.\")\nclass Script extends KBean {\n\n    @JkDoc(\"Person to whom the greeting is intended\")\n    public String name = \"World\";\n\n    @JkDoc(\"Print greeting on console\")\n    public void hello() {\n        String greetings = \"Hello \" + name + \" !\";\n        System.out.println(greetings);\n    }\n}\n</code></pre></p>"},{"location":"quick-start/#run-methods","title":"Run methods","text":"<p>You can run the method <code>hello()</code> and change the parameter, by executing: <pre><code>jeka hello name=\"JeKa\"\n</code></pre> This displays the following text on the console: <pre><code>Hello JeKa !\n</code></pre></p>"},{"location":"quick-start/#write-extra-methods","title":"Write Extra Methods","text":"<p>You can add extra methods relying or not on third-party dependencies as: <pre><code>import com.github.lalyos.jfiglet.FigletFont;\nimport com.google.common.base.Strings;\nimport dev.jeka.core.tool.JkDep;\nimport dev.jeka.core.tool.KBean;\n\n@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")\n@JkDep(\"com.google.guava:guava:33.3.1-jre\")\nclass Script extends KBean {\n\n    public void header() throws Exception {\n        System.out.println(Strings.repeat(\"-\", 80));\n        System.out.println(FigletFont.convertOneLine(\"Hello Ascii Art !\"));\n        System.out.println(Strings.repeat(\"-\", 80));\n    }\n}\n</code></pre> Execute: <pre><code>jeka header\n</code></pre> This will display the following text on the console: <pre><code>--------------------------------------------------------------------------------\n  _   _      _ _            _             _ _      _         _     _ \n | | | | ___| | | ___      / \\   ___  ___(_|_)    / \\   _ __| |_  | |\n | |_| |/ _ \\ | |/ _ \\    / _ \\ / __|/ __| | |   / _ \\ | '__| __| | |\n |  _  |  __/ | | (_) |  / ___ \\\\__ \\ (__| | |  / ___ \\| |  | |_  |_|\n |_| |_|\\___|_|_|\\___/  /_/   \\_\\___/\\___|_|_| /_/   \\_\\_|   \\__| (_)\n\n\n--------------------------------------------------------------------------------\n</code></pre></p> <p>Note</p> <ul> <li>You can define multiple script methods in <code>Script.java</code>. These methods must be public, non-static, take no arguments, and return <code>void</code>.</li> <li>You can rename <code>Script.java</code> to any name and place it in any package.</li> <li>You can create multiple script classes. To run a specific script, use the class name, e.g., <code>jeka script2: hi</code>.</li> <li>You can also use classes provided by JeKa without explicitly declaring them.</li> </ul>"},{"location":"quick-start/#kbeans","title":"KBeans","text":"<p>Every script should inherit from the <code>KBean</code> class. </p> <p>KBeans can either be provided as source code (located in the <code>jeka-src</code> directory) or as compiled classes available in the classpath.</p> <p>JeKa includes several standard KBeans, which you can list by running: <pre><code>jeka --doc\n</code></pre></p>"},{"location":"quick-start/#change-java-version","title":"Change Java Version","text":"<p>To change version of Java, edit <code>jeka.properties</code>: <pre><code>jeka.java.version=23\n</code></pre> This will automatically download Java 23 (if not already installed) on the next method run.</p>"},{"location":"quick-start/#source-runnable-applications","title":"Source-Runnable Applications","text":"<p>Run <code>hello</code> from another directory: <pre><code>jeka -r /path/to/script/root-dir hello\n</code></pre></p> <p>Run <code>hello</code> from a remote Git repository: <pre><code>jeka -r https://github.com/jeka-dev/demo-base hello\n</code></pre></p> <p>JeKa acts as an application source manager, allowing you to run or install applications directly from their source code. For more details, see the Source-Runnable Applications tutorial.</p>"},{"location":"quick-start/#common-options-commands","title":"Common Options &amp; Commands","text":"<pre><code>jeka --help          # Displays help message\njeka --doc           # Displays documentation on available KBeans\njeka --inspect       # Displays details about JeKa setup and properties\njeka base: depTree   # Show dependency tree\n</code></pre>"},{"location":"quick-start/#resources","title":"Resources","text":"<ul> <li>Basics Tutorial</li> <li>Write Scripts in Java Video</li> </ul>"},{"location":"quick-start/#create-a-base-application-or-library","title":"Create a Base Application or Library","text":"<p>JeKa's base mode is the simplest way to build pure Java applications or libraries. It avoids the complexity of traditional Maven/Gradle structures while supporting full-featured builds, testing, native compilation, and Docker packaging.</p> <p>To create a new code structure, run the following command: <pre><code>jeka base: scaffold scaffold.kind=APP\n</code></pre> This creates a structure like this: <pre><code>. \n\u251c\u2500\u2500 jeka-src             &lt;- Source root directory\n\u2502   \u251c\u2500\u2500 _dev             &lt;- Optional package containing all non-prod (build and test)\n\u2502   \u2502   \u251c\u2500\u2500 test\n\u2502   \u2502   \u2514\u2500\u2500 Build.java  \n\u2502   \u2514\u2500\u2500 app              &lt;- Suggested base package for production code/resources\n\u2502       \u2514\u2500\u2500 App.java     \n\u251c\u2500\u2500 jeka-output          &lt;- Directory where generated artifacts (JARs, reports) are stored\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration (Java and JeKa version, KBean configurations, ...)\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands\n</code></pre></p> <p>Follow the tutorial for more details.</p>"},{"location":"quick-start/#create-a-java-project","title":"Create a Java Project","text":"<p>For more complex needs, Project mode provides a standard layout similar to Maven or Gradle, supporting multi-module builds and advanced dependency management.</p> <p>To create a new project structure, execute: <pre><code>jeka project: scaffold\n</code></pre> This generates a project structure as: <pre><code>.\n\u251c\u2500\u2500 src                  \n\u2502   \u251c\u2500\u2500 main             &lt;- Java code and resources\n\u2502   \u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2514\u2500\u2500 resources    \n\u2502   \u2514\u2500\u2500 test             &lt;- Java code and resources for tests\n\u2502       \u251c\u2500\u2500 java\n\u2502       \u2514\u2500\u2500 resources \n\u251c\u2500\u2500 jeka-src             &lt;- Optional Java (or Kotlin) code for building the project\n\u2502   \u2514\u2500\u2500 Build.java      \n\u251c\u2500\u2500 jeka-output          &lt;- Directory where generated artifacts (JARs, reports) are stored\n\u251c\u2500\u2500 jeka.project.deps   &lt;- Dependency lists for compile, runtime and testing\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration (Java and JeKa version, KBean configurations, ...)\n\u251c\u2500\u2500 jeka.ps              &lt;- Optional PowerShell script to boot JeKa on Windows\n\u251c\u2500\u2500 jeka                 &lt;- Optional bash script to boot JeKa on Linux/MacOS\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands for building the project\n</code></pre></p> <p>Follow the tutorial for more details.</p>"},{"location":"quick-start/#create-a-spring-boot-project","title":"Create a Spring Boot Project","text":"<p>To create a new Spring Boot project, execute: <pre><code>jeka -cp=dev.jeka:springboot-plugin project: scaffold springboot:\n</code></pre></p> <p>This generates the following project structure: <pre><code>.\n\u251c\u2500\u2500 src                  \n\u2502   \u251c\u2500\u2500 main             \n\u2502   \u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 app\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 Application.java      &lt;- Spring Boot app class\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 Controller.java       &lt;- REST controller\n\u2502   \u2502   \u2514\u2500\u2500 resources    \n\u2502   \u2514\u2500\u2500 test             \n\u2502       \u251c\u2500\u2500 java\n\u2502       \u2502   \u2514\u2500\u2500 app\n\u2502       \u2502       \u2514\u2500\u2500 ControllerIT.java     &lt;- Integration Test for REST controller \n\u2502       \u2514\u2500\u2500 resources \n\u251c\u2500\u2500 jeka-src             \n\u2502   \u2514\u2500\u2500 Build.java       &lt;- Optional build class (if needed)\n\u251c\u2500\u2500 jeka-output          &lt;- Directory where generated artifacts (JARs, reports) are stored\n\u251c\u2500\u2500 jeka.project.deps   &lt;- Spring Boot and extra dependencies\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration \n\u251c\u2500\u2500 jeka.ps              \n\u251c\u2500\u2500 jeka                 \n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands for building the project\n</code></pre> This contains a minimal workable project with production and test code. </p>"},{"location":"quick-start/#modify-layout","title":"Modify Layout","text":"<p>You can choose a simpler code layout structure by setting the following properties: jeka.properties<pre><code>@project.layout.style=SIMPLE\n@project.layout.mixSourcesAndResources=true\n</code></pre> You'll end up with the following code layout: <pre><code>.\n\u251c\u2500\u2500 src       &lt;- Contains both Java code and resources    \n\u251c\u2500\u2500 test      &lt;- Contains both Java code and resources for testing\n</code></pre></p>"},{"location":"quick-start/#modify-dependencies","title":"Modify Dependencies","text":"<p>The dependencies are generated with the latest Spring Boot version: jeka.project.deps<pre><code>[version]\norg.springframework.boot:spring-boot-dependencies:3.4.1@pom\n\n[compile]\norg.springframework.boot:spring-boot-starter-web\n\n[test]\norg.springframework.boot:spring-boot-starter-test\n</code></pre> You can start from here for modifying, adding code, tests and dependencies.</p>"},{"location":"quick-start/#execute-commands","title":"Execute Commands","text":"<p>These are the most useful commands for developing Spring Boot applications.</p> Common Commands<pre><code>jeka project: test       # Compiles and run tests\njeka project: pack       # Compiles and creates Bootable Jar\njeka project: runJar     # Runs the bootable JAR\njeka project: build      # All-in-one: compile, test, pack, and verification\njeka project: depTree    # Displays the dependency tree\n\njeka docker: build       # Creates Docker image containing the Spring Boot application\njeka docker: buildNative # Creates Docker image for the native-compiled application\n</code></pre>"},{"location":"quick-start/#customize-docker-file","title":"Customize Docker File","text":"<p>To reduce a Docker native image size, use a distroless base image. The native executable must be statically linked as libc is unavailable in such distributions. Configure it as follows: jeka.properties<pre><code>@native.staticLink=MUSL\n@docker.nativeBaseImage=gcr.io/distroless/static-debian12:nonroot\n</code></pre></p>"},{"location":"quick-start/#what-next","title":"What Next?","text":"<p>Explore more advanced topics and real-world examples:</p> <ul> <li>Source-Runnable Applications: Run or install apps directly from Git.</li> <li>Spring Boot + Angular + SonarQube Example: A complete full-stack example.</li> <li>Kotlin + Spring Boot + ReactJS Example: Using Kotlin with modern web frameworks.</li> <li>JeKa + Spring Boot + GraalVM Video: Watch JeKa in action.</li> <li>Basics Tutorial: Deep dive into JeKa core concepts.</li> </ul>"},{"location":"under-the-hood/","title":"Under the Hood","text":"<p>JeKa consists of a single zero-dependency JAR file, along with two shell scripts (one PowerShell script for Windows and one Bash script for Linux/macOS).</p>"},{"location":"under-the-hood/#inside-the-jeka-jar","title":"Inside the JeKa JAR","text":"<p>The JeKa JAR is structured as follows:</p> <ul> <li> <p><code>dev.jeka.core.tool</code> package:</p> <p>Contains classes for running Java externally, including the <code>dev.jeka.core.tool.Main</code> class and the component model.</p> </li> <li> <p><code>dev.jeka.core.tool.builtin</code> package: </p> <p>Contains KBeans bundled with JeKa, such as <code>ProjectKBean</code>, <code>DockerKBean</code> or <code>NativeKBean</code>.</p> </li> <li> <p><code>dev.jeka.core.api</code> package:</p> </li> </ul> <p>Includes libraries for building projects. These classes can be easily used outside JeKa and embedded in your product.    </p> <pre><code>graph TD\n    subgraph dev.jeka.core\n        subgraph tool \n            engine[dev.jeka.core.tool]\n            builtin[dev.jeka.core.tool.builtin]\n        end\n\n        subgraph api\n            project[dev.jeka.core.api.project]\n            java[dev.jeka.core.api.java]\n            system[dev.jeka.core.api.system]\n            dep[dev.jeka.core.api.depmanagement]\n            file[dev.jeka.core.api.file]\n            utils[def.jeka.core.api.utils]\n            misc[...]\n        end\n\n\n    end\n\n    engine --&gt; java\n    engine --&gt; system\n    engine --&gt; dep\n    builtin --&gt; engine\n    builtin --&gt; api\n    java --&gt; utils\n    dep --&gt; utils\n    file --&gt; utils\n    system --&gt; utils</code></pre>"},{"location":"adrs/01-cmdline-kbean-maker/","title":"Title","text":"<p>Command line KBean notation</p>"},{"location":"adrs/01-cmdline-kbean-maker/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/01-cmdline-kbean-maker/#context","title":"Context","text":"<p>We need to differentiate KBean, methods, and properties when parsing command lines. </p> <p>KBean names can be all lowercase, causing confusion with method names.  Using <code>@KBeanName method1 method2 ...</code> might face conflict with @file-arguments  and may require using shift key on some keyboards. </p> <p>However, a colon as <code>KBeanName: method1 method2 ...</code> doesn't require to use <code>shift</code> key, despite being less noticeable.</p>"},{"location":"adrs/01-cmdline-kbean-maker/#decision","title":"Decision","text":"<p>Jeka adopts the colon notation for KBean.</p>"},{"location":"adrs/01-cmdline-kbean-maker/#consequences","title":"Consequences","text":"<p>To mention default KBean, we'll simply use <code>:</code> as in <code>jeka project: pack : e2e</code></p>"},{"location":"adrs/02-name-for-skip-test-property/","title":"Title","text":"<p>Property Name for Skipping Tests</p>"},{"location":"adrs/02-name-for-skip-test-property/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/02-name-for-skip-test-property/#context","title":"Context","text":"<p>A unique property is required for skipping tests in both projects and bases. This ensures the same property can be applied when running commands like <code>jeka base:pack</code> or <code>jeka project:pack</code>.  It also simplifies invoking builds directly from OS scripts.</p>"},{"location":"adrs/02-name-for-skip-test-property/#decision","title":"Decision","text":"<p>The property will be named <code>jeka.test.skip</code>, aligning with the <code>$Maven$</code> equivalent <code>maven.skip.test</code>.</p>"},{"location":"adrs/02-name-for-skip-test-property/#consequences","title":"Consequences","text":"<p>To build without running tests, use the following commands: - <code>jeka project:pack -Djeka.test.skip</code> - <code>jeka base:pack -Djeka.test.skip</code></p>"},{"location":"adrs/03-default-include-test-pattern/","title":"Title","text":"<p>Default include patterns for running tests. </p>"},{"location":"adrs/03-default-include-test-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/03-default-include-test-pattern/#context","title":"Context","text":"<p>By default, Maven runs only test classes suffixed with <code>Test</code>. In the opposite, IDEs and Gradle runs all tests.</p>"},{"location":"adrs/03-default-include-test-pattern/#decision","title":"Decision","text":"<p>Jeka will runs all the tests by default as it is consistent with IDE and not an isolated behavior  in the java build tool landscape.</p>"},{"location":"adrs/03-default-include-test-pattern/#consequences","title":"Consequences","text":"<p>When running <code>jeka project: test</code>, all tests are executed unless explicitly specified.</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/","title":"Title","text":"<p>Run All Tests When the Include Pattern Is Empty</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#context","title":"Context","text":"<p>Test selection allows filtering tests based on class names or tag presence. How should we interpret the behavior when no include pattern is specified? Should it mean \"include all\" or \"exclude all\"?</p> <p>At first glance, \"exclude all\" might seem more logical. However, the JUnit platform considers an empty include pattern to mean \"include all.\"</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#decision","title":"Decision","text":"<p>We decided to follow the JUnit platform behavior, both for class names and tags.</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#consequences","title":"Consequences","text":"<p>Include all tests when the include pattern is empty.</p>"},{"location":"reference/api-dependency-management/","title":"Dependency Management","text":"<p>For Jeka, a dependency is something that can be resolved to a set of files by a <code>JkDependencyResolver</code>. Generally a dependency resolves to 1 file (or folder) but it can also be 0 or many.</p> <p>Compared to mainstream build tools, Jeka offers a simpler and more flexible model to deal with multiple dependency configurations required to build a project.</p>"},{"location":"reference/api-dependency-management/#types-of-dependency","title":"Types of Dependency","text":"<p>A dependency is always an instance of <code>JkDependency</code>.</p> <p>Jeka distinguishes between 3 main types of dependency :</p> <ul> <li>Arbitrary files located on the file system (represented by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system while the build is running.</li> <li>Files produced by a computation (represented by <code>JkComputedDependency</code> class). These files may be present on file system, or not. If they are not present, the computation is run in order to produce the missing files. Usually the computation stands for the build of an external project.</li> <li>Coordinate pointing to a remote artifact (represented by <code>JkCoordinateDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and transitively resolve any artifact located in a repository as you would do with Maven, Ivy, or Gradle.</li> </ul> <p>Lastly, Jeka uses Ivy 2.5.1 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code.</p> <p>Dependency type hierarchy: <pre><code>graph TD\n\n    JkCoordinateDependency --&gt; JkDependency\n    JkFileDependency --&gt; JkDependency\n\n    JkComputedDependency --&gt; JkFileDependency\n    JkFileSystemDependency --&gt; JkFileDependency\n    JkLocalProjectDependency --&gt; JkFileDependency</code></pre></p>"},{"location":"reference/api-dependency-management/#coordinate-dependency","title":"Coordinate dependency","text":"<p>This type of dependency is represented by a <code>JkCoordinateDependency</code> class. It stands for a Maven/Ivy dependency expressed with coordinates (e.g. group:module:version).</p> <p>This is for declaring a dependency on a module hosted in the Maven or Ivy repositories.  Basically you instantiate a <code>JkCoordinateDependency</code> from its group, name, and version.</p>"},{"location":"reference/api-dependency-management/#string-notation","title":"String Notation","text":"<p>The string representation follows the Gradle short notation,  and accept the similar Ivy versioning.</p> <p>Additionally, the Jeka notation allow to express extensions, classifiers and BOMs. Many string formats are accepted to specify a module coordinate :</p> <ul> <li>group:name</li> <li>group:name:version</li> <li>group:name:classifier:version</li> <li>group:name:classifier:extension:version</li> </ul> <p>Examples: <pre><code>org.slf4j:slf4j-api:2.0.16                       &lt;-- Declares an exact version\norg.slf4j:slf4j-api:2.0.16+                      &lt;-- Declares a lower bound version\norg.slf4j:slf4j-api:[2.0.0,2.0.16[               &lt;-- Declares a bounded version\n\norg.mock-server:mockserver-netty:shaded:5.15.0   &lt;-- Declare a dependency on the -shaded- classifier\norg.lwjgl:lwjgl:natives_linux:3.1.0              &lt;-- Declare a dependency on the natives_linux classifier\norg.slf4j:slf4j-bom::pom:2.0.16                  &lt;-- Declare a bom dependency \n</code></pre></p>"},{"location":"reference/api-dependency-management/#bom","title":"BOM","text":"<p>To mention a BOM dependency, we just need to reference the POM extension of this dependency. For example, Springboot defines a BOM in <code>org.springframework.boot:spring-boot-dependencies</code> Maven module.</p> <p>To reference this BOM in our dependencies, we just need to specify the POM extension as in <code>org.springframework.boot:spring-boot-dependencies::pom:3.3.6</code>.</p>"},{"location":"reference/api-dependency-management/#transitivity","title":"Transitivity","text":"<p>By default, dependencies specifying a classifier or an extension are not considered to be transitive.  Although, transitivity can be explicitly defined programmatically.</p> <p>By default, Jeka uses the most relevant transitivity according to the declaration context, so users don't need to specify it unless they want a specific one.</p> <p>Example of programmatic instantiation of a coordinate dependency: <pre><code>var dep = JkCoordinateDependency.of(\"group:name:version\")\n                                .withTransitivity(JkTransitivity.RUNTIME);\n</code></pre></p> <p>See later for more details about transitivity.</p>"},{"location":"reference/api-dependency-management/#file-system-dependencies","title":"File System Dependencies","text":"<p>This type of dependency is represented by the <code>JkFileSystemDependency</code> class.</p> <p>Just mention the path of one or several files. If one of the files does not exist at the time of resolution (when the dependency is actually retrieved), build fails.</p> <pre><code>JkDependencySet.of().andFiles(\"libs/my.jar\", \"libs/my.testingtool.jar\");\n</code></pre>"},{"location":"reference/api-dependency-management/#computed-dependencies","title":"Computed Dependencies","text":"<p>This type of dependency is represented by the <code>JkComputedDependency</code> class.</p> <p>It is typically used for multi-modules or multi-techno projects.</p> <p>The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails.</p> <p>This mechanism is quite simple yet powerful as it addresses the following use cases :</p> <ul> <li>Dependencies on files produced by an artifact producer (<code>JkArtifactProducer</code>). A <code>JkProject</code> is an artifact producer.</li> <li>Dependencies on files produced by external build tools (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...).</li> <li>... In other words, files produced by any means.</li> </ul> <p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p> <p>The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka. <pre><code>Path mavenProject = Paths.get(\"../a-maven-project\");\nPath mavenProjectJar = mavenProject.resolve(\"target/maven-project.jar\");\nPath externalProject = Paths.get(\"../a-jeka-project\");\n\nJkProcess mavenBuild = JkProcess.of(\"mvn\", \"clean\", \"install\").withWorkingDir(mavenProject);\n\nJkJavaProject externalProject = JkJavaProject.of(externalProject); \n\nJkDependencySet deps = JkDependencySet.of()\n    .and(JkComputedDependency.of(mavenBuild, mavenProjectJar))\n    .and(externalProject);\n</code></pre></p>"},{"location":"reference/api-dependency-management/#dependency-set","title":"Dependency Set","text":"<p>A dependency set (<code>JkDependencySet</code>) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of <code>JkDependency</code>. See here</p> <p>dependencySet also defines :</p> <ul> <li>A version provider to define which version of a module should be used in case it is not explicitly mentioned. </li> <li>A set of transitive dependency exclusion rules.</li> </ul> <p>It is designed as an immutable object where we can apply set theory operations for adding, removing, or merging with other dependencies and dependencySet.</p> Example.java<pre><code>...\nJkDependencySet deps = JkDependencySet.of()\n    .and(\"com.google.guava\") \n    .and(\"org.slf4j:slf4j-simple\")\n    .and(\"com.orientechnologies:orientdb-client:2.0.8\")\n    .andFile(\"../libs.myjar\")\n    .withVersionProvider(myVersionProvider);\n</code></pre> <p>Note</p> <ul> <li>Module versions can be omitted when declaring dependencies. Versions can be provided by a <code>JkVersionProvider</code> or a BOM dependency.</li> <li>Instances of <code>JkDependencySet</code> can be combined in order to construct a large dependencySet from smaller ones.</li> </ul>"},{"location":"reference/api-dependency-management/#transitivity_1","title":"Transitivity","text":"<p>For each dependency, mainstream build tools use a single concept (scope or configuration) to determine :</p> <ol> <li>which part of the build needs the dependency</li> <li>which transitive dependencies to fetch along the dependency</li> <li>with which transitivity the dependency must be published</li> </ol> <p>This confusion leads to dependency management systems that are bloated, difficult to reason with, and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a smaller number, but with limitations and not-so-clear transitivity/publish rules.</p> <p>In the opposite, Jeka distinguishes clearly the following three purposes :</p> <ol> <li>Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be    defined relatively to another using set theory operations.</li> <li>For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency.</li> <li>For publishing, we can optionally re-define a specific dependencySet, exposing exactly what we want.</li> </ol> <p>Jeka defines by default, three levels of transitivity :</p> <ul> <li>NONE : Not transitive</li> <li>COMPILE : Also fetches transitive dependencies declared with scope 'compile' in the dependency published pom.</li> <li>RUNTIME : Also fetches transitive dependencies declared with any scope in the dependency published pom.</li> </ul> <p>Notes</p> <p>On Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'.</p> <p>For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'.</p> <p>The below example shows a JkJavaProject declaration using explicit transitivity.</p> <p><pre><code>JkJavaProject.of().simpleFacade()\n    .configureCompileDeps(deps -&gt; deps\n            .and(\"com.google.guava:guava:23.0\", JkTransitivity.NONE)\n            .and(\"javax.servlet:javax.servlet-api:4.0.1\"))\n    .configureRuntimeDeps(deps -&gt; deps\n            .and(\"org.postgresql:postgresql:42.2.19\")\n            .withTransitivity(\"com.google.guava:guava\", JkTransitivity.RUNTIME)\n            .minus(\"javax.servlet:javax.servlet-api\"))\n    .configureTestDeps(deps -&gt; deps\n            .and(Hint.first(), \"org.mockito:mockito-core:2.10.0\")\n    )\n</code></pre> It results in : <pre><code>Declared Compile Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:NONE\n  javax.servlet:javax.servlet-api:4.0.1\n\nDeclared Runtime Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n\nDeclared Test Dependencies : 4 elements.\n  org.mockito:mockito-core:2.10.0\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n  javax.servlet:javax.servlet-api:4.0.1\n</code></pre> Dependencies without any transitivity specified will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies.</p> <p>The API allows you to redefine the transitivity declared in a upper dependency set.</p> <p>Note that transitivity can only apply to <code>JkModuleDependency</code> (like com.google.guava:guava:23.0) and <code>JkLocalProjectDependency</code>.</p>"},{"location":"reference/api-dependency-management/#resolve-dependencies","title":"Resolve Dependencies","text":"<p>The <code>JkDependencyResolver</code> class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning <code>JkResolveResult</code> from a <code>JkdependencySet</code>.</p> <pre><code>JkDependencySet deps = JkDependencySet.of()\n                            .and(\"org.apache.httpcomponents:httpclient:4.5.3\")\n                            .andFile(\"libs/my.jar\");\n\n// Here, module dependencies are fetched from Maven central repo\nJkDependencyResolver resolver = \n        JkDependencyResolver.of(JkRepo.ofMavenCentral());  \nJkResolveResult result = resolver().resolve(deps);\n</code></pre> <p>From the result you can :</p> <ul> <li>Navigate in the resolved dependency tree as :</li> </ul> <pre><code>JkDependencyNode slfjApiNodeDep = result.getDependencyTree()\n        .getFirst(JkModuleId.of(\"org.slf4j:slf4j-api\"));\nSystem.out.println(slfjApiNode.getModuleInfo().getResolvedVersion());\n</code></pre> <ul> <li>Get the direct list of artifact files</li> </ul> <pre><code>JkPathSequence sequence = result.getFiles();  \nsequence.forEach(System.out::println); // print each files part of the result\n</code></pre>"},{"location":"reference/api-dependency-management/#publication","title":"Publication","text":"<p>Jeka is able to publish on both the Maven and Ivy repositories. This includes repositories such as Sonatype Nexus.</p> <p>Maven and Ivy have different publication models, so Jeka proposes specific APIs according to whether you want to publish on a Maven or Ivy repository.</p>"},{"location":"reference/api-dependency-management/#publish-on-a-maven-repository","title":"Publish on a Maven repository","text":"<p>Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according to provided elements.</p> <p>Find an example here</p> <p>Notice that Jeka allows you to :</p> <ul> <li>Publish more than one artifact.</li> <li>Produce &amp; publish checksum files for each published artifact.</li> <li>Mention using unique snapshots (What is it ?).</li> <li>Feed generated pom with data necessary to publish on central repository.</li> <li>Sign published artifacts with PGP</li> <li>Publish to multiple repositories by creating the publisher using a <code>JkRepoSet</code> instead of a <code>JkRepo</code>.</li> </ul> <p>To sign with PGP, there is no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts.</p>"},{"location":"reference/api-dependency-management/#publish-to-a-ivy-repository","title":"Publish to a Ivy repository","text":"<p>Publishing on Ivy repo is pretty similar to publishing on Maven, though there are options specific to Ivy.</p> <p>See also here</p>"},{"location":"reference/api-dependency-management/#common-classes","title":"Common Classes","text":"<ul> <li> <p><code>JkRepo</code> and <code>JkRepoSet</code> represent both download and upload repositories. </p> </li> <li> <p><code>JkRepoFromProperties</code>provides configured repositories according to global or project scopes properties.</p> </li> <li> <p><code>JkDependencySet</code> represents a set of dependencies.</p> </li> <li> <p><code>JkDependencyResolver</code> resolves dependencies to classpaths and resolution results that allow resolution exploration.</p> </li> <li> <p><code>JkModuleFileProxy</code> provides an smart way to get a file from its coordinates.</p> </li> </ul>"},{"location":"reference/api-docker/","title":"Docker API","text":"<p>The Docker API provides classes for defining and building Docker images programmatically. It relies on the Docker CLI, so a Docker installation (e.g., Docker Desktop) is required to invoke Docker commands from Java code.</p>"},{"location":"reference/api-docker/#features","title":"Features","text":"<ul> <li>Define Dockerfiles and build-context directories programmatically.</li> <li>Generate optimized Docker images (JVM-based and native) directly from a project definition (e.g., a <code>JKProject</code> instance).</li> </ul>"},{"location":"reference/api-docker/#classes","title":"Classes","text":"<p>The classes are located in package <code>dev.jeka.core.api.tooling.docker</code>.</p>"},{"location":"reference/api-docker/#jkdocker","title":"<code>JkDocker</code>","text":"<p>Provides helper methods to:</p> <ul> <li>Execute Docker commands conveniently.</li> <li>Retrieve a list of image names present in the Docker registry.</li> </ul> <pre><code>JkDocker.execCmdLine(\"run\", \"--rm -p8080:8080 io.my-registry/my-image:latest\");\n</code></pre>"},{"location":"reference/api-docker/#jkdockerbuild","title":"<code>JkDockerBuild</code>","text":"<p>Represents a Docker build context. It enables defining the build context directory and Dockerfile, as well as invoking Docker to build an image.</p> <p>Key features include:</p> <ul> <li>Define Dockerfiles and build-context directory contents programmatically.</li> <li>Build images based on the defined build context.</li> <li>Simplify Dockerfile editing:</li> <li>Add a non-root user.</li> <li>Copy files into the build context.</li> <li>Adjust cursor position to insert build steps at specific locations.</li> <li>And more...</li> </ul> Example<pre><code>JkDockerBuild dockerBuild = JkDockerBuild.of()\n    .setBaseImage(\"eclipse-temurin:21-jdk-alpine\")\n    .setExposedPorts(8080);\n\ndockerBuild.dockerfileTemplate\n    .addCopy(Paths.get(\"/users/me/jars/my-app.jar\"), \"/app/my-app.jar\")\n    .add(\"WORKDIR /app\")\n    .addEntrypoint(\"java\", \"-jar\", \"/app/my-app.jar\");\n\ndockerBuild.buildImageInTemp(\"my-image:latest\");  // Create the Docker image in a random temp dir\n</code></pre> Generated Dockerfile<pre><code>FROM eclipse-temurin:21-jdk-alpine\nRUN addgroup --gid 1002 nonrootgroup &amp;&amp; \\\n    adduser --uid 1001 -g 1002 --disabled-password nonroot\nUSER nonroot\nCOPY imported-files/hello-jeka.jar /app/my-app.jar\nWORKDIR /app\nENTRYPOINT [\"java\", \"-jar\", \"/app/my-app.jar\"]\nEXPOSE 8080\n</code></pre> <p>Key Notes:</p> <ul> <li>The non-root user has been automatically added as part of the Dockerfile.</li> <li>Jar files from the filesystem have been imported into the [build context]/imported-files directory.</li> </ul> <p>For more details, refer to the Javadoc.</p>"},{"location":"reference/api-docker/#jkdockerjvmbuild","title":"<code>JkDockerJvmBuild</code>","text":"<p>An extension of <code>JkDockerBuild</code> that provides additional methods to:</p> <ul> <li>Generate optimized JVM-based Docker images directly from a project definition.</li> <li>Add agents to the program for runtime enhancements.</li> </ul> Example<pre><code>JkProject project = project();\nJkDockerJvmBuild dockerJvmBuild = JkDockerJvmBuild.of(project.asBuildable())\n    .addAgent(\"io.opentelemetry.javaagent:opentelemetry-javaagent:2.10.0\", \"myAgentOption\");\n\ndockerBuild.buildImageInTemp(\"my-jvm-image:latest\");  // Create the Docker image in a random temp dir\n</code></pre> <p>Generated Dockerfile<pre><code>FROM eclipse-temurin:23-jdk-alpine\nRUN addgroup --gid 1002 nonrootgroup &amp;&amp; \\\n    adduser --uid 1001 -g 1002 --disabled-password nonroot\nRUN mkdir -p /app &amp;&amp; chown -R nonroot:nonrootgroup /app \\\n    &amp;&amp; mkdir -p /workdir &amp;&amp; chown -R nonroot:nonrootgroup /workdir\nUSER nonroot\nCOPY agents /app/agents\nCOPY libs /app/libs\nCOPY snapshot-libs /app/snapshot-libs\nCOPY classpath.txt /app/classpath.txt\nCOPY resources /app/classes\nCOPY classes /app/classes\nWORKDIR /workdir\nENTRYPOINT [ \"java\", \"-javaagent:/app/agents/opentelemetry-javaagent-2.10.0.jar=myAgentOption\", \"-cp\", \"@/app/classpath.txt\", \"dev.jeka.core.tool.Main\" ]\nCMD []\n</code></pre> Key Notes:</p> <ul> <li>The Docker image is layered for optimal caching. If a class changes without modifying dependencies, only the final step is re-executed, significantly speeding up the image creation process.</li> <li>The OpenTelemetry agent has been included and referenced in the command-line arguments.</li> </ul>"},{"location":"reference/api-docker/#jkdockernativebuild","title":"<code>JkDockerNativeBuild</code>","text":"<p>An extension of <code>JkDockerBuild</code> offering additional methods for creating compact and efficient native executable images.</p> <p>*Example: Creating a Minimalist Distroless Image</p> <p>This approach produces images with a minimal package set to reduce the attack surface. It requires building a native executable with static linking on <code>libc</code> (e.g., using MUSL).</p> Example<pre><code>JkNativeCompilation nativeCompilation = getNativeCompilation()\n    .setStaticLinkage(MUSL);\n\nJkDockerNativeBuild dockerBuild = JkDockerNativeBuild.of(nativeCompilation)\n    .setBaseImage(\"gcr.io/distroless/static-debian12:nonroot\");\n\ndockerBuild.buildImageInTemp(\"my-jvm-image:latest\");  // Create the Docker image in a random temp dir\n</code></pre> Generated Dockerfile<pre><code>FROM ghcr.io/graalvm/native-image-community:23-muslib AS build\nCOPY imported-files/j2objc-annotations-3.0.0.jar /root/cp/j2objc-annotations-3.0.0.jar\nCOPY imported-files/error_prone_annotations-2.28.0.jar /root/cp/error_prone_annotations-2.28.0.jar\nCOPY imported-files/checker-qual-3.43.0.jar /root/cp/checker-qual-3.43.0.jar\nCOPY imported-files/jsr305-3.0.2.jar /root/cp/jsr305-3.0.2.jar\nCOPY imported-files/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar /root/cp/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar\nCOPY imported-files/failureaccess-1.0.2.jar /root/cp/failureaccess-1.0.2.jar\nCOPY imported-files/guava-33.3.1-jre.jar /root/cp/guava-33.3.1-jre.jar\nCOPY imported-files/hello-jeka.jar /root/cp/hello-jeka.jar\nCOPY imported-files/jeka-native-image-arg-file-5771078964740361323.txt /argfile\nRUN native-image @/argfile\n\nFROM gcr.io/distroless/static-debian12:nonroot\n\nCOPY  --from=build /my-app /app/myapp\n\nWORKDIR /app\nENTRYPOINT [\"/app/myapp\"]\n</code></pre> <p>Key Notes:</p> <ul> <li>The native executable is generated within a container using a multi-stage build.</li> <li>No non-root user has been created because the base image is inferred to already include one (based on its name).</li> <li>Native-based Docker images can be created directly from Windows or macOS workstations without any prerequisites other than Docker.</li> </ul>"},{"location":"reference/api-files/","title":"Files API","text":"<p>File manipulation is a key aspect of software development. Jeka extends the java.nio.file API by introducing additional concepts to offer a powerful and fluent API for performing common tasks with minimal effort.  </p> <p>The file-api classes are located in the <code>dev.jeka.core.api.file</code> package. Visit the Javadoc.</p>"},{"location":"reference/api-files/#jkpathfile","title":"<code>JkPathFile</code>","text":"<p>A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods.</p> Example<pre><code>JkPathFile.of(\"my-new-file.txt\")\n    .fetchContentFrom(\"https://www.bgreco.net/fortune.txt\")\n    .copyToDir(myFolder);\n</code></pre>"},{"location":"reference/api-files/#jkpathtree","title":"<code>JkPathTree</code>","text":"<p>An Immutable root folder along a <code>PathMatcher</code> providing operations to copy, navigate, zip, iterate, or watch. This is a central class in Jeka API.</p> Examples<pre><code>// copies all non java source files to another directory preserving structure\nJkPathTree.of(\"src\").andMatching(false, \"**/*.java\").copyTo(\"build/classes\");\n\n// One liner to zip an entire directory\nJkPathTree.of(\"build/classes\").zipTo(Paths.get(\"mylib.jar\"));\n\n// Traverse the tree in breath first (opposite to deep-first) \nJkPathTree.of(\"build/classes\").streamBreathFirst().forEach(file -&gt; ...);\n\n// Compute MD5\nString md5 = JkPathTree.of(\"src/main/java\").checksum();\n</code></pre>"},{"location":"reference/api-files/#jkpathsequence","title":"<code>JkPathSequence</code>","text":"<p>An Immutable sequence of <code>java.nio.file.Path</code> providing methods for filtering or appending. Example<pre><code>URL[] urls = JkPathSequence.of(paths)\n                .and(embeddedLibs())\n                .toUrls();\n</code></pre></p>"},{"location":"reference/api-files/#jkpathmatcher","title":"<code>JkPathMatcher</code>","text":"<p>An immutable <code>java.nio.file.PathMatcher</code> based on <code>java.nio.file</code> glob pattern or regerxp.   Used by <code>JkPathTree</code> to filter in/out files according name patterns.</p>"},{"location":"reference/api-files/#jkziptree","title":"<code>JkZipTree</code>","text":"<p>Same as <code>JkPathTree</code> but using a zip file instead of a directory. It allows you to manipulate a zip file   as a regular folder. </p>"},{"location":"reference/api-files/#jkpathtreeset","title":"<code>JkPathTreeSet</code>","text":"<p>An Immutable set of <code>JkPathTree</code>. Helpful to define a set of sources/resources and create jar/zip files.</p>"},{"location":"reference/api-files/#jkresourceprocessor","title":"<code>JkResourceProcessor</code>","text":"<p>A mutable processor for copying a set of files, preserving the structure and   replacing some texts with others. Typically used for replacing tokens <code>${server.ip}</code> with an actual values.</p>"},{"location":"reference/api-git/","title":"Git API","text":"<p>The Git API provides classes for conveniently working with Git in Java. The classes are part of the <code>dev.jeka.core.api.tooling.git</code> package.</p>"},{"location":"reference/api-git/#jkgit-class","title":"<code>JkGit</code> class","text":"<p>The <code>JkGit</code> class extends <code>JkProcess</code>, which means it inherits methods that make process execution easier.</p> Sequence og Git calls<pre><code>JkGit git = JkGit.of(rootDir);\ngit\n    .execCmdLine(\"add .\")\n    .execCmdLine(\"config user.name  jeka-bot\")\n    .execCmdLine(\"config user.email jeka-bot@github-action.com\")\n    .execCmdLine(\"commit -m update-javadoc --allow-empty\")\n    .execCmdLine(\"push\");\n</code></pre> <p>The tool offers many useful methods for executing standard DevOps commands like checking the workspace state, retrieving commit messages, and viewing current tags. For more details, visit the Javadoc.</p> Conenient method calls<pre><code>List&lt;String&gt; tagNames = git.getTagsOnCurrentCommit();\nString commit         = git.getCurrentCommit();\nString messageToken   = git.extractSuffixFromLastCommitMessage(\"release:\");\n...\n</code></pre>"},{"location":"reference/api-git/#jkversionfromgit-class","title":"<code>JkVersionFromGit</code> class","text":"<p>This class infers project versions from Git information based on the current tag or branch.</p> <ul> <li>If the current commit is on a tag, the returned version is <code>tag-name</code>.</li> <li>If not on a tag, the returned version is <code>branch-name-SNAPSHOT</code>.</li> </ul> <pre><code>JkVersionFromGit versionFromGit = JkVersionFromGit.of(\"v\");  // consider only tags starting with 'v'\nSystem.out.println(versionFromGit.getVersion());\n\nJkProject project = getProject();\nversionFromGit.handleVersioning(project);\n</code></pre>"},{"location":"reference/api-intro/","title":"Build Library","text":"<p>JeKa comes with a set of classes designed to help you programmatically accomplish build tasks. These classes are used to implement JeKa's engine and its bundled KBeans. You may find these classes useful for your own needs, as they cover the following concerns:</p> <ul> <li>File manipulation.</li> <li>Java specific actions (compilation, classloading, jar creation, ...). Visit Javadoc.</li> <li>Java specific actions (compilation, module). Visit source code.</li> <li>Cryptography signing. Visit source code.</li> <li>Dependency management.</li> <li>Project Building</li> <li>Testing (run tests on junit-jupiter engine). Visit Javadoc.</li> <li>Running external commands. Visit Visit Javadoc.</li> </ul>"},{"location":"reference/api-native/","title":"Native API","text":"<p>The Native API offers a <code>JkNativeCompilation</code> class that creates an executable file from compiled classes or JARs. </p> <p>An easy way to use it is by passing a <code>JkProject</code> when instantiating. This setup prepares everything for native compilation. The class automatically downloads GraalVM,  which includes the <code>nativeImage</code> executable used for compiling to native - you don't need to care about GraalVM installation. </p> <p>It also provides helpful methods to add resources to the native executable.</p> <p>Exemple<pre><code>JkProject project = ...\n\nJkNativeCompilation.of(project.asBuildable()\n    .setIncludesAllResources(true)\n    .make(Paths.get(\"build/my-app.exe\"));\n</code></pre> This code performs the following actions: - Checks if the system is running on GraalVM. If not, it fetches the latest GraalVM version (if not already available). - Includes all project resources located in src/main/resources. - Fetches the metadata repository and adds it to the compilation classpath. - Uses the <code>native-image</code> GraalVM tool to compile the application into a native binary.</p> <p>By default, JeKa will fetch GraalVM using the Foodjay API unless the <code>JEKA_GRAALVM_HOME</code> environment variable is set. If the environment variable's value starts with <code>DOWNLOAD_</code> (e.g., <code>DOWNLOAD_21</code>), the specified GraalVM version will be downloaded from the internet.</p>"},{"location":"reference/api-project/","title":"Project API","text":"<p>The Jeka Project API provides a high-level interface for building Java/JVM projects. At the core of this API is the <code>JkProject</code> class, which serves as the central entry point for performing build tasks.</p>"},{"location":"reference/api-project/#classes","title":"Classes","text":"<p>The classes are located in the <code>dev.jeka.core.api.project</code> package.</p>"},{"location":"reference/api-project/#jkproject","title":"<code>JkProject</code>","text":"<p>The <code>JkProject</code> class contains all the essential definitions for building a JVM project, including source locations, build output, testing, packaging (e.g., creating JAR files), compiler settings, dependencies, and more.</p> <p>Designed with multiple extension points, it provides flexibility for integrating custom or specific build behaviors.</p> <p>To manage all of these concerns efficiently, the class is structured as follows:</p> <p><pre><code>project\n\u251c\u2500 baseDir\n\u251c\u2500 outputDir\n\u251c\u2500 artifactLocator (define where artifact files are supposed to be created)\n\u251c\u2500 duplicateDependencyConflictStrategy\n\u251c\u2500 jvmTargetVersion\n\u251c\u2500 sourceEncoding\n\u251c\u2500 javaCompileToolChain\n\u251c\u2500 dependencyResolver\n\u251c\u2500 compilation  (produce individual binary files from production sources. This includes resource processing, code generation, processing on .class files, ...)\n\u2502  \u251c\u2500 layout (where are located source and resource files)\n\u2502  \u251c\u2500 source generators (plugin mechanism for generating source files)\n\u2502  \u251c\u2500 dependencies   (stands for compile dependencies)\n\u2502  \u251c\u2500 preCompileActions (including resources processing)\n\u2502  \u251c\u2500 compileActions (including java sources compilation. Compilation for other languages can be added here)\n\u2502  \u251c\u2500 postCompileActions\n\u2502  \u2514\u2500 methods : resolveDependencies(), run()\n\u251c\u2500 testing\n\u2502  \u251c\u2500 testCompilation (same as above 'prodcCompilation' but for test sources)\n\u2502  \u2502  \u251c\u2500 layout\n\u2502  \u2502  \u251c\u2500 dependencies (stands for test dependencies)\n\u2502  \u2502  \u2514\u2500 ...\n\u2502  \u251c\u2500 breakOnFailure (true/false)\n\u2502  \u251c\u2500 skipped (true/false)\n\u2502  \u251c\u2500 testProcessor\n\u2502  \u2502  \u251c\u2500 forkedProcess (configured the forked process who will run tests)\n\u2502  \u2502  \u251c\u2500 preActions\n\u2502  \u2502  \u251c\u2500 postActions\n\u2502  \u2502  \u251c\u2500 engineBehavior\n\u2502  \u2502  \u2502  \u251c\u2500 testReportDir\n\u2502  \u2502  \u2502  \u251c\u2500 progressDisplayer\n\u2502  \u2502  \u2502  \u2514\u2500 launcherConfiguration (based on junit5 platform API)\n\u2502  \u2502  \u2514\u2500 testSelection\n\u2502  \u2502     \u251c\u2500 includePatterns\n\u2502  \u2502     \u2514\u2500 includeTags\n\u2502  \u2514\u2500 method : run()\n\u251c\u2500 packaging (produces javadoc and source jar and bin jars)\n\u2502  \u251c\u2500 javadocConfiguration\n\u2502  \u251c\u2500 runtimeDependencies\n\u2502  \u251c\u2500 manifest\n\u2502  \u251c\u2500 fatJar (customize produced fat/uber jar if any)\n\u2502  \u2514\u2500 methods : createJavadocJar(), createSourceJar(), createBinJar(), createFatJar(), resolveRuntimeDependencies()\n\u2514\u2500 methods :  toDependency(transitivity), getIdeSupport(), pack(), getDependenciesAsXml(), includeLocalAndTextDependencies()           \n</code></pre> See a detailed example here.</p>"},{"location":"reference/api-project/#flat-facade","title":"Flat Facade","text":"<p>For convenience, <code>JkProject</code> offers a simplified facade to easily configure common settings without delving into its deeper structure.</p> <pre><code>JkProjectFlatFacade projectFacade = JkProject.of().flatFacade;\nprojectFacade\n       .setPublishedModuleId(\"dev.jeka:sample-javaplugin\")\n       .setVersionFromGitTag()\n       .mixResourcesAndSources()\n       .setLayoutStyle(SIMPLE)\n       .addTestExcludeFilterSuffixedBy(\"IT\", false);\nprojectFacade.dependencies.compile\n       .add(\"com.google.guava:guava:21.0\")\n       .add(\"com.sun.jersey:jersey-server:1.19.4\")\n       .add(\"org.projectlombok:lombok:1.18.36\");\nprojectFacade.dependencies.runtime\n       .remove(\"org.projectlombok:lombok\")\n       .add(\"com.github.djeang:vincer-dom:1.2.0\");\nprojectFacade.dependencies.test\n       .add(\"org.junit.vintage:junit-vintage-engine:5.6.0\");\nprojectFacade.doPack();  // compile, test and create jar\n</code></pre>"},{"location":"reference/api-project/#project-dependencies","title":"Project Dependencies","text":"<p>Project dependencies in Jeka are managed differently from Maven/Gradle.  Instead of a single collection of dependencies for a specific scope/configuration,  Jeka uses three distinct classpaths: compile, runtime, and test. Each is defined independently but can reference the others.</p> <ul> <li>Compile classpath: </li> </ul> <p>Classpath needed to compile the classes.</p> <ul> <li>Runtime classpath: </li> </ul> <p>Classpath needed to run the build application or to embedded with the built library (embedded in jar or specified as transitive dependencies).</p> <p>This classpath is automatically constructed by taking the compile classpath upon which other libraries can be added or removed.</p> <ul> <li>Test classpath: </li> </ul> <p>Classpath needed to compile and run the tests. </p> <p>This classpath is constructed by merging the compile and runtime classpaths upon which other libraries can be added or removed.</p> <p>Dependencies must follow the format: <code>group:module:[classifier]:[type]:[version]</code> where classifier, type, and version are optional. See <code>JkCoordinate</code> javadoc for details.</p> <p>To import a bill-of-materials (BOM), declare a dependency as: <code>group:module::pom:version</code>.</p> <p>Using the programmatic api, you can also declare filesystem dependencies, meaning jar files located in  the project code base.</p> <p></p>"},{"location":"reference/api-project/#jekaprojectdeps","title":"jeka.project.deps","text":"<p>Entire project dependencies can be declared in full text located in the [PROJECT_DIR]/jeka.project.deps file.</p> <p>Example: <pre><code>[version]\norg.junit:junit-bom:5.12.1@pom    # use this pom as a version provider for all junit dependencies\norg.postgresql:postgresql:42.5.0\norg.glassfish.jaxb:jaxb-*:4.0.5   # use joker to specify version according a pattern\n\n[compile]\nom.google.guava:guava:33.4.8-jre\norg.lwjgl:lwjgl:natives-linux:3.3.6  # specify the 'natives-linux' classifier for lwjgl\norg.glassfish.jaxb:jaxb-runtime      # version for org.glassfish.jaxb:jaxb-* is specified above\n../module-utils                      # specify a project directory located on file system\n\n[compile-only]\norg.projectlombok:lombok:1.18.36\norg.openjfx:javafx-base:${jeka.platform.os}:2.0.18  # properties are interpolated\n\n[runitme]\norg.postgresql:postgresql\n\n[test]\norg.junit.jupiter:junit-jupiter\norg.junit.platform:junit-platform-launcher\norg.fluentlenium:fluentlenium-junit:3.2.0\n    !org.apache.httpcomponents:httpclient  # exclude http-client from 'fluentlenium-junit' transitive dependencies\n!!net.sourceforge.htmlunit:htmlunit        # exclude htmlunit from all transitive dependencies\n</code></pre></p> <p>As shown in the example above, we can use the <code>@</code> and <code>@@</code> symbols to specify dependency exclusions. <code>[version]</code> Specifies the versions of dependencies to use when not explicitly defined. You can include all versions defined in a BOM by referencing its coordinates and appending <code>@pom</code>. The versions section inherits definitions from the version section in the <code>jeka.project.deps</code> file located in the parent directory.</p> <p><code>[compile]</code> Specifies dependencies required for both compiling and running the project.</p> <p><code>[compile-only]</code> Specifies dependencies required only for compiling the project, which are excluded at runtime.</p> <p><code>[runtime]</code> Specifies dependencies required only for running the project.</p> <p><code>[test]</code> Specifies dependencies for the test classpath. This includes dependencies from the compile, compile-only, and runtime sections, along with those specified in the test section.</p> <p>Tip</p> <p>If you're using the Jeka plugin for IntelliJ, press <code>ctrl+&lt;space&gt;</code> for autocomplete suggestions.</p> <p>Resolve Dependencies Programmatically</p> <p>To resolve dependencies that make up the runtime classpath, you can use one of the following methods:</p> <ul> <li><code>JkProject.packaging.resolveRuntimeDependencies()</code> to fetch the dependency resolution tree.</li> <li><code>JkProject.packaging.resolveRuntimeDependenciesAsFiles()</code> to get the resolved classpath as a list of JAR files.</li> </ul> <p>The second option may be faster as it caches the results of previous invocations.</p> <p>Display Dependency tree on the console</p> <p>The dependency tree and the resulting classpath can be displayed on the console using: <code>JkProject.displayDependencyTree()</code> methods.</p> <p>Change the Maven repository</p> <p>By default, the dependencies are resolved using Maven central repository.</p> <p>We can change it programatically, by using <code>JkProject.dependencyResolver.setRepos()</code> method.</p>"},{"location":"reference/api-project/#display-generic-info","title":"Display Generic Info","text":"<p>We can display project info such as locations, source file count, version, moduleID, and more by displaying the result of the <code>JkProject.getInfo()</code> method.</p>"},{"location":"reference/api-project/#build-project","title":"Build Project","text":"<p>Different phases of the build can be invoked using the following methods:</p> <ul> <li><code>JkProject.compilation.generateSources()</code>: Generates sources if any source generators are registered.</li> <li><code>JkProject.compilation.run()</code>: Runs the entire compilation process, including source generation and other registered compilation tasks.</li> <li><code>JkProject.testing.run()</code>: Compiles tests and runs them. This also includes production code compilation if it hasn't been done yet.</li> <li><code>JkProject.pack()</code>: Creates the main JAR and any additional JARs specifically configured. This includes running tests if they haven't been executed.</li> </ul> <p>In the next section, we'll detail the classes involved in the entire build process.</p>"},{"location":"reference/api-project/#jkprojectcompilation","title":"JkProjectCompilation","text":"<p>Handles the compilation tasks for a <code>JkProject</code>. This class is used for both production and test code compilation. It offers configuration methods for defining:</p> <ul> <li>The locations of source files and compiled classes.</li> <li>Dependencies required for compilation.</li> <li>The compiler and compilation options.</li> <li>Source code generators attached to the compilation task.</li> <li>Additional <code>pre</code> and <code>post</code> actions tied to the compilation phase.</li> <li>Interpolators for resource processing.</li> </ul>"},{"location":"reference/api-project/#jkprojectsourcegenerator","title":"JkProjectSourceGenerator","text":"<p>Implement this class to define a source generator. Register the generator in a project using: <code>JkProject.compilation.addSourceGenerator(JkProjectSourceGenerator sourceGenerator)</code>.</p> <p>Once registered, sources will be automatically generated during compilation or when explicitly calling: <code>JkProject.compilation.generateSources()</code>.</p>"},{"location":"reference/comparison/","title":"JeKa for Maven and Gradle Users","text":"<p>If you are coming from Maven or Gradle, this guide will help you map your existing knowledge to JeKa concepts.</p>"},{"location":"reference/comparison/#core-philosophies","title":"Core Philosophies","text":"Feature Maven Gradle JeKa Configuration XML (<code>pom.xml</code>) Groovy/Kotlin DSL Properties (<code>jeka.properties</code>) or Java Code Extensibility Plugins Plugins / Tasks KBeans (Java classes similar to JavaBeans) Build Logic Rigid Lifecycle Task Graph Method Invocations Dependencies XML Declarations DSL Declarations Text based(<code>jeka.project.deps</code>)"},{"location":"reference/comparison/#concept-mapping","title":"Concept Mapping","text":""},{"location":"reference/comparison/#project-structure","title":"Project Structure","text":"Maven/Gradle JeKa Notes <code>src/main/java</code> <code>src/main/java</code> Standard Java structure is supported by the <code>project</code> KBean. <code>src/test/java</code> <code>src/test/java</code> Standard Test structure is supported. <code>build.gradle</code> / <code>pom.xml</code> <code>jeka.properties</code> Global project settings and tool versions. Custom Task/Plugin <code>jeka-src/Custom.java</code> Any Java code in <code>jeka-src</code> is part of your build logic."},{"location":"reference/comparison/#common-commands","title":"Common Commands","text":"Maven Gradle JeKa <code>mvn compile</code> <code>gradle compileJava</code> <code>jeka project: compile</code> <code>mvn test</code> <code>gradle test</code> <code>jeka project: test</code> <code>mvn package</code> <code>gradle assemble</code> <code>jeka project: pack</code> <code>mvn install</code> <code>gradle publishToMavenLocal</code> <code>jeka maven: publishLocal</code> <code>mvn clean</code> <code>gradle clean</code> <code>jeka --clean</code>  or <code>jeka -c</code> <code>mvn help:describe</code> <code>gradle help</code> <code>jeka --doc</code> or <code>jeka project: --doc</code>"},{"location":"reference/comparison/#key-differences","title":"Key Differences","text":""},{"location":"reference/comparison/#1-unified-model-for-plugins-and-build-logic","title":"1. Unified Model for Plugins and Build Logic","text":"<p>Whether writing custom build logic or creating a reusable plugin, you use the same simple Java model: KBeans. They are similar to JavaBeans.</p>"},{"location":"reference/comparison/#2-pure-java-build-logic","title":"2. Pure Java Build Logic","text":"<p>Instead of learning a specific DSL (Domain Specific Language) like Gradle's Groovy/Kotlin, you use standard Java. If you can write a Java method, you can write a build task.</p>"},{"location":"reference/comparison/#3-immediate-feedback","title":"3. Immediate Feedback","text":"<p>JeKa compiles and runs your build logic on-the-fly. There is no \"configuring\" phase that takes several seconds before the build starts.</p>"},{"location":"reference/comparison/#4-no-xml-or-yaml","title":"4. No XML or YAML","text":"<p>Use properties for configuration and Java code for logic.</p>"},{"location":"reference/comparison/#example-adding-a-dependency","title":"Example: Adding a Dependency","text":"<p>Maven: <pre><code>&lt;dependency&gt;\n  &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n  &lt;artifactId&gt;guava&lt;/artifactId&gt;\n  &lt;version&gt;31.1-jre&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;org.threeten&lt;/groupId&gt;\n  &lt;artifactId&gt;threeten-extra&lt;/artifactId&gt;\n  &lt;version&gt;1.8.0&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n  &lt;groupId&gt;com.google.guava&lt;/groupId&gt;\n  &lt;artifactId&gt;guava&lt;/artifactId&gt;\n  &lt;version&gt;31.1-jre&lt;/version&gt;\n  &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre></p> <p>Gradle: <pre><code>implementation(\"com.google.guava:guava:31.1-jre\")\nimplementation(\"org.threeten:threeten-extra:1.8.0\")\ntest(\"org.mockito:mockito-core:5.22.0\")\n</code></pre></p> <p>JeKa (jeka.project.deps): <pre><code>[compile]\ncom.google.guava:guava:31.1-jre\norg.threeten:threeten-extra:1.8.0\n\n[test]\norg.mockito:mockito-core:5.22.0\n</code></pre></p>"},{"location":"reference/kbeans-app/","title":"App KBean","text":"<p>Provides a way to install, update, or remove applications from the user PATH.</p> <p>Applications are installed from a Git repository and built by the client before installation.</p> <p>Runtime modes: - JVM: Runs on a Jeka-managed JDK, installed in ~/.jeka/apps - NATIVE: Compiled as a native executable - BUNDLE: Runs with a tailored JRE bundled with the app, installed where the user decides</p> <p><code>AppKBean</code> manages the installation, update, and discovery of applications from remote repositories or catalogs.</p> <p>For a practical guide on running and installing applications from source, see the Source-Runnable Applications tutorial.</p> <p>Key Features</p> <ul> <li>Installs applications from remote Git repositories.</li> <li>Supports JVM, Native, and Bundle runtime modes.</li> <li>Manages application updates and uninstallation.</li> <li>Facilitates application discovery via catalogs.</li> <li>Provides security through trusted source verification.</li> </ul>"},{"location":"reference/kbeans-app/#install-applications","title":"Install Applications","text":"<pre><code>jeka app: install repo=REPO_URL\n</code></pre> <p>Applications can be installed in different runtime modes:</p>"},{"location":"reference/kbeans-app/#runtime-modes","title":"Runtime Modes","text":"<ul> <li>JVM (default): JVM application running on a JDK managed by Jeka. Binary is installed in <code>~/.jeka/apps</code> and available in PATH.</li> <li>NATIVE: Native executable compiled ahead-of-time using GraalVM.</li> <li>BUNDLE: Application bundled with a tailored JRE. Installed in a user-specified location.</li> </ul>"},{"location":"reference/kbeans-app/#using-the-runtime-parameter","title":"Using the <code>runtime</code> parameter","text":"<p>Install in native mode: <pre><code>jeka app: install repo=REPO_URL runtime=NATIVE\n</code></pre></p> <p>Install as a bundle: <pre><code>jeka app: install repo=REPO_URL runtime=BUNDLE\n</code></pre></p> <p>Examples: Install kill8 app as a JVM application: <pre><code>jeka app: install repo=https://github.com/djeang/kill8 name=killport\n</code></pre> or use the GitHub repo shorthand <pre><code>jeka app: install repo=kill8@djeang\n</code></pre></p> <p>or use an alternative application name or runtime mode <pre><code>jeka app: install repo=https://github.com/djeang/kill8 name=killport runtime=NATIVE\n</code></pre></p>"},{"location":"reference/kbeans-app/#list-installed-applications","title":"List Installed Applications","text":"<p><pre><code>jeka app: list\n</code></pre> This displays the name of the applications, along with their repo, version/status, and runtime type. <pre><code>App Name   \u2502 Repo                                      \u2502 Version  \u2502 Status     \u2502 Runtime \u2502 \ncalculator \u2502 https://github.com/djeang/Calculator-jeka \u2502 latest   \u2502 up-to-date \u2502 jvm     \u2502 \nkill8      \u2502 https://github.com/djeang/kill8           \u2502 &lt;master&gt; \u2502 up-to-date \u2502 native  \u2502 \n</code></pre></p>"},{"location":"reference/kbeans-app/#update-applications","title":"Update Applications","text":"<p><pre><code>jeka app: update name=kill8\n</code></pre> Updates the application to the highest semantic version tag. If a 'latest' tag exists, uses that tag. If no tags exist, uses the latest commit.</p>"},{"location":"reference/kbeans-app/#uninstall-applications","title":"Uninstall Applications","text":"<pre><code>jeka app: uninstall name=kill8\n</code></pre>"},{"location":"reference/kbeans-app/#catalogs","title":"Catalogs","text":"<p>Application catalogs are curated collections of Jeka applications that can be easily discovered and installed. Catalogs make it simple to share and distribute applications across teams or communities.</p>"},{"location":"reference/kbeans-app/#viewing-catalogs","title":"Viewing Catalogs","text":"<p>Display all registered catalogs: <pre><code>jeka app: catalog\n</code></pre></p> <p>This shows the catalog names, descriptions, and URLs sorted by repository.</p> <p>Display applications in a specific catalog: <pre><code>jeka app: catalog name=demo\n</code></pre></p> <p>This lists all applications available in the specified catalog, showing: - Application name and description - Application type (CLI, SERVER, SERVER-UI, etc.) - Commands to run or install the application - Available runtime modes (JVM, NATIVE, BUNDLE)</p>"},{"location":"reference/kbeans-app/#installing-from-catalogs","title":"Installing from Catalogs","text":"<p>Install an application using the catalog shorthand: <pre><code>jeka app: install repo=cowsay@jeka-dev\n</code></pre></p> <p>The format is <code>appName@catalogName</code>. This is equivalent to providing the full repository URL.</p>"},{"location":"reference/kbeans-app/#creating-a-catalog","title":"Creating a Catalog","text":"<p>To add a catalog, add the following lines to your <code>~/.jeka/global.properties</code> file: <pre><code>catalog.xxx.repo=[http location or git repo url]\ncatalog.xxx.desc=[Description of the catalog]\n</code></pre> where <code>xxx</code> stands for the name of your catalog.</p> <p>The <code>catalog.xxx.repo</code> value can be: 1. A full URL to the catalog properties file 2. A GitHub organization name (looks for <code>jeka-catalog</code> repository) 3. A GitHub organization/repository path</p> <p>Valid examples: <pre><code># GitHub organization - expects jeka-catalog repo at root\ncatalog.djeang.repo=djeang\ncatalog.djeang.desc=Personal applications\n\n# GitHub organization/repository - expects jeka-catalog.properties at root\ncatalog.demo.repo=jeka-dev/demo\ncatalog.demo.desc=Demo applications\n\n# Direct URL to catalog file\ncatalog.custom.repo=https://raw.githubusercontent.com/myorg/my-catalog/refs/heads/main/jeka-catalog.properties\ncatalog.custom.desc=Custom application catalog\n</code></pre></p>"},{"location":"reference/kbeans-app/#catalog-file-format","title":"Catalog File Format","text":"<p>A catalog file is a properties file named <code>jeka-catalog.properties</code> containing application definitions:</p> <pre><code># Application entries follow the pattern: app.&lt;name&gt;.&lt;property&gt;=&lt;value&gt;\n\napp.cowsay.repo=https://github.com/jeka-dev/demo-cowsay\napp.cowsay.desc=Java port of the Cowsay famous CLI.\napp.cowsay.type=CLI\napp.cowsay.native=true\napp.cowsay.bundle=false\n\napp.demo-springboot-angular.repo=https://github.com/jeka-dev/demo-project-springboot-angular\napp.demo-springboot-angular.desc=Manage a list of users. Written in Spring Boot and Angular.\napp.demo-springboot-angular.type=SERVER-UI\napp.demo-springboot-angular.native=false\napp.demo-springboot-angular.bundle=true\n</code></pre> <p>Available application properties:</p> <ul> <li><code>repo</code> (required): Git repository URL of the application</li> <li><code>desc</code> (required): Short description of the application</li> <li><code>type</code> (optional): Application type (CLI, SERVER, SERVER-UI, LIBRARY, etc.)</li> <li><code>native</code> (optional): Set to <code>true</code> if the app supports native compilation (default: false)</li> <li><code>bundle</code> (optional): Set to <code>true</code> if the app supports bundled distribution (default: false)</li> </ul>"},{"location":"reference/kbeans-app/#built-in-catalogs","title":"Built-in Catalogs","text":"<p>Jeka comes with a built-in catalog from the <code>jeka-dev</code> organization. Additional catalogs can be registered in: - <code>~/.jeka/global.properties</code> (user-level) - Project's <code>jeka.properties</code> (project-level)</p>"},{"location":"reference/kbeans-app/#security","title":"Security","text":"<p>Trusted URL prefixes are stored in the <code>jeka.apps.url.trusted</code> property, located in the <code>~/.jeka/global.properties</code> file. You can adjust this property later to make it more or less restrictive. The check validates the start of the Git URL after removing the protocol and identifier part.</p> <p>Example: <code>jeka.app.url.trusted=github.com/djeang/</code> will trust URLs formed as:</p> <ul> <li><code>https://github.com/djeang/xxx...</code> </li> <li><code>https://my-user-name@github.com/djeang/xxx...</code></li> <li><code>git@github.com/djeang/xxx..</code></li> <li><code>git@github.com:my-user-name/djeang/xxx..</code></li> <li>...</li> </ul>"},{"location":"reference/kbeans-app/#summary","title":"Summary","text":"<p>Provides a way to install, update, or remove applications from the user PATH.</p> <p>Applications are installed from a Git repository and built by the client before installation.</p> <p>Runtime modes: - JVM: Runs on a Jeka-managed JDK, installed in ~/.jeka/apps - NATIVE: Compiled as a native executable - BUNDLE: Runs with a tailored JRE bundled with the app, installed where the user decides</p> <p>This KBean exposes the following fields:</p> Field Description repo [String] Git Remote repository URL of the app to install. name [String] Specifies the name of the app to update/uninstall. description [String] Short description of the app provided by the application author. url [String] Specifies the url to trust. runtime [enum:RuntimeMode] Runtime mode for app installation:- JVM (default): Runs on a Jeka-managed JDK, installed in ~/.jeka/apps (on your PATH)- NATIVE: Compiled as a native executable, installed in ~/.jeka/apps (on your PATH)- BUNDLE: Bundled with a tailored JRE, installed in a user-specified location. <p>This KBean exposes the following methods:</p> Method Description catalog List application catalogs. install Builds and installs the app to make it available in PATH.Use <code>repo=[Git URL]</code> to set the source repository.Use <code>runtime=JVM|NATIVE|BUNDLE</code> to specify the runtime mode. list Lists installed Jeka commands in the user's PATH. trustUrl Adds permanently the url to the trusted list.The urls starting with the specified prefix will be automatically trusted.Use 'url=my.host/my.path/' to specify the prefix. uninstall Uninstalls an app from the user's PATH.Use <code>name=[app-name]</code> to specify the app. update Updates an app from the given name.Use <code>name=[app-name]</code> to specify the app name."},{"location":"reference/kbeans-base/","title":"Base KBean","text":"<p>Manages the build and execution of code located in 'jeka-src' directory.</p> <p>The code stands for neither an application nor a library. For applications, code should contain a class including a main method to:</p> <ul> <li>Run application</li> <li>Create bootable jar</li> <li>Create bootable fat jar, and create Docker images</li> </ul> <p><code>BaseKBean</code> is similar to <code>ProjectKBean</code>, but it facilitates building JVM-based code hosted entirely in the jeka-src folder with a simpler classpath organization.</p> <ul> <li>Single Classpath: By default, there is a single classpath. However, if a <code>_dev</code> package exists in the code structure, its contents are excluded when creating JARs, native executables, or Docker images. Typically, build and test classes are placed in <code>_dev</code> for application builds.</li> <li>Dependency Declaration: Dependencies are declared by annotating any class with the <code>@JkDep</code> annotation. Dependencies within the <code>_dev</code> package are excluded from production artifacts.</li> </ul> <p>Key Features</p> <ul> <li>Resolves dependencies, compiles code, and runs tests.</li> <li>Creates various types of JAR files out-of-the-box: regular, fat, shaded, source, and Javadoc JARs.</li> <li>Infers project versions from Git metadata.</li> <li>Executes packaged JARs.</li> <li>Displays dependency trees and project setups.</li> <li>Scaffolds skeletons for new projects.</li> </ul> <p>Example</p> <ul> <li>Base Application: The <code>BaseKBean</code> is set as the default KBean in <code>jeka.properties</code>. The accompanying <code>README.md</code> file details the available <code>base:</code> methods that can be invoked.</li> </ul>"},{"location":"reference/kbeans-base/#summary","title":"Summary","text":"<p>Manages the build and execution of code located in 'jeka-src' directory.</p> <p>The code stands for neither an application nor a library. For applications, code should contain a class including a main method to:</p> <ul> <li>Run application</li> <li>Create bootable jar</li> <li>Create bootable fat jar, and create Docker images</li> </ul> <p>This KBean exposes the following fields:</p> Field Description jvmOptions [String] Space separated list of options to pass to the JVM that will run the program. programArgs [String] Space separated list of program arguments to pass to the command line running the program. moduleId [String] Group and name for publication, formatted as 'groupId:nameId'. jarType [enum:JkProjectPackaging$JarType] Type of jar to produce for the main artifact. gitVersioning.enable [boolean] If true, a version computed from the current Git branch/tag will be injected into the Maven KBean to determine the published version. gitVersioning.tagPrefix [String] Some prefer to prefix version tags like 'v1.3.1' instead of simply using '1.3.1'. In such cases, this value can be set to 'v' or any other chosen prefix. scaffold.kind [enum:JkBaseScaffold$Kind] Kind of Jeka base to generate. scaffold.jekaVersion [String] Set a specific jeka.version to include in jeka.properties. NO: no jeka.version specified, [EMPTY]: last version found in Maven Central. scaffold.jekaLocation [String] Set a specific jeka.distrib.location to include in jeka.properties. scaffold.jekaDistribRepo [String] Set a specific jeka.distrib.repo to include in jeka.properties. scaffold.extraJekaProps [String] Coma separated string representing properties to add to jeka.properties. scaffold.rawJekaPropsContentPath [Path] Set the path of a file containing the exact content of the jeka.properties file to generate.If this field is set, all others related to jeka.properties generation are ignored. <p>This KBean exposes the following methods:</p> Method Description build Runs tests then 'pack'. depTree Displays exported dependency tree on console. info Displays info about this base KBean. pack Creates runnable fat jar and optional artifacts. runJar Runs fat jar. runMain Launches application. scaffold Creates a skeleton in the current working directory. test Launches test suite."},{"location":"reference/kbeans-bundle/","title":"Bundle KBean","text":"<p>Bundle a self-contained Java app (containing JRE) using jpackage and jlink tools.</p> <p>This plugin creates a self-contained app and allows configuring the jpackage and jlink tools.</p> <p>This integrates with ProjectKBean for project-specific setups, handles file system operations to prepare input directories, and invokes jpackage and jlink tools.</p>"},{"location":"reference/kbeans-bundle/#creates-a-customized-self-contained-app","title":"Creates a customized self-contained app","text":"<p>Thanks to jpackage and jlink tools, this KBean creates self-contained Java applications or installers tailored  for the host system.</p> <p>To create such a bundle, execute: <code>jeka bundle: pack</code>.</p> <p>The application or installer will be created in [project dir]/jeka-output dir.</p> <p>If you want to create this bundle along other artifacts while executing <code>jeka project: pack</code>,  you need to specify the following property in <code>jeka.properties</code>. <pre><code>@bundle.projectPack=true\n</code></pre></p>"},{"location":"reference/kbeans-bundle/#summary","title":"Summary","text":"<p>Bundle a self-contained Java app (containing JRE) using jpackage and jlink tools.</p> <p>This plugin creates a self-contained app and allows configuring the jpackage and jlink tools.</p> <p>This integrates with ProjectKBean for project-specific setups, handles file system operations to prepare input directories, and invokes jpackage and jlink tools.</p> <p>This KBean post-initializes the following KBeans:</p> Post-initialised KBean Description ProjectKBean Adds the bundled application to 'project: pack' actions, if 'projectPack=true'. <p>This KBean exposes the following fields:</p> Field Description customJre [boolean] If true, a custom JRE is created including only Java modules used by the application. projectPack [boolean] If true, creates a bundled application along with the regular JAR when executing 'project: pack'. includeRuntimeLibs [boolean] It true, the runtimes libs will be added in the packaged application, which may be not necessary whe using FAT jars. jpackage.options.all.[key] [String] jpackage.options.windows.[key] [String] jpackage.options.linux.[key] [String] jpackage.options.mac.[key] [String] jlink.options.all.[key] [String] jlink.options.windows.[key] [String] jlink.options.linux.[key] [String] jlink.options.mac.[key] [String] <p>This KBean exposes the following methods:</p> Method Description jlinkHelp Prints jlink help on the console. jpackageHelp Prints jpackage help on the console. pack Packages the application into a bundle. showModuleDeps Prints JPMS module dependencies on the console."},{"location":"reference/kbeans-docker/","title":"Docker KBean","text":"<p>Builds and runs image based on project.</p> <p>This KBean can build JVM and Native (AOT) images from an existing project.</p> <p><code>DockerKBean</code> allows the creation of Docker images for both <code>project</code> and <code>base</code> KBeans. It supports generating JVM-based images as well as minimalist Docker images containing only the native executable.</p> <p>Key Features:</p> <ul> <li>Efficiently create layered and secure Docker images for JVM applications.</li> <li>Generate secure, optimized Docker images for native applications.</li> <li>Infer image name/version from the project.</li> <li>Optionally switch to a non-root user (configurable).</li> <li>Customize the generated image via Java API.</li> </ul> <p>Example Invocation:</p> <ul> <li><code>jeka docker: buildNative</code>: Builds a native Docker image of your application.</li> </ul> <p>Example Configuration:</p> <p>Specify base image: <pre><code>@docker.nativeBaseImage=gcr.io/distroless/static-debian12:nonroot\n</code></pre></p> <p>Add JVM agents: <pre><code>@docker.jvmAgents.0.coordinate=io.opentelemetry.javaagent:opentelemetry-javaagent:2.16.0\n@docker.jvmAgents.0.optionLine=-Dotel.traces.exporter=otlp,-Dotel.metrics.exporter=otlp\n</code></pre></p> <p>Example for programmatic customization:</p> <p><pre><code>@JkPostInit\nprivate void postInit(DockerKBean dockerKBean) {\n    dockerKBean.customizeJvmImage(dockerBuild -&gt; dockerBuild\n            .addAgent(\"io.opentelemetry.javaagent:opentelemetry-javaagent:2.16.0\", \"\")\n            .setBaseImage(\"eclipse-temurin:21.0.1_12-jre-jammy\")\n            .nonRootSteps()   // inserted after  USER nonroot\n            .addCopy(Paths.get(\"jeka-output/release-note.md\"), \"/release.md\")\n            .add(\"RUN chmod a+rw /release.md \")\n    );\n}\n</code></pre> This KBean allows customizing the Docker image programmatically using the JeKa libs for Docker.</p> <p>It\u2019s easy to see the customization result by executing <code>jeka docker: info</code>.  This will display details about the built image, including the generated Dockerfile.  You can also visit the generated Docker build directory,  which contains all the Docker context needed to build the image with a Docker client.</p>"},{"location":"reference/kbeans-docker/#summary","title":"Summary","text":"<p>Builds and runs image based on project.</p> <p>This KBean can build JVM and Native (AOT) images from an existing project.</p> <p>This KBean exposes the following fields:</p> Field Description jvmImageName [String] Explicit full name of the JVM image to build. It may includes placeholders such as '$version', '$groupId', and '$artifactId'.If not specified, the image name will be inferred form the project information. nativeImageName [String] Explicit full name of the native image to build. It may includes placeholders such as '$version', '$groupId', and '$artifactId'.If not specified, the image name will be inferred form the project information. jvmBaseImage [String] Base image to construct the Docker image. jvmOptions [String] Space-separated list of additional JVM options to use when running the container's Java process. nativeBaseImage [String] Base image for the native Docker image to build. It can be replaced by a distro-less image as 'gcr.io/distroless/static-debian12:nonroot'. nativeNonRootUser [enum:JkDockerBuild$NonRootMode] Specifies the policy for creating a non-root user in the native Docker image. jvmNonRootUser [enum:JkDockerBuild$NonRootMode] Specifies the policy for creating a non-root user in the JVM Docker image. jvmAgents.[key].coordinate [String] Coordinate of the JVM agent, e.g. 'io.opentelemetry.javaagent:opentelemetry-javaagent:1.32.0'. jvmAgents.[key].optionLine [String] Option line to pass to the agent, e.g. '-Dotel.traces.exporter=otlp,-Dotel.metrics.exporter=otlp. <p>This KBean exposes the following methods:</p> Method Description build Builds Docker image in local registry. buildNative Builds native Docker image in local registry. info Displays info about the Docker image. infoNative Displays info about the native Docker image."},{"location":"reference/kbeans-eclipse/","title":"Eclipse KBean","text":"<p>Manages Eclipse metadata files.</p> <p><code>EclipseKBean</code>  provides methods for generating metadata files for the Eclipse IDE, specifically the <code>.classpath</code> and <code>.project</code> files.</p> <p>To ensure it works correctly, define a <code>JEKA_USER_HOME</code> classpath variable in Eclipse with the value <code>~/.jeka</code>.</p>"},{"location":"reference/kbeans-eclipse/#summary","title":"Summary","text":"<p>Manages Eclipse metadata files.</p> <p>This KBean exposes the following fields:</p> Field Description javadoc [boolean] If true, .classpath will include javadoc reference for declared dependencies. jreContainer [String] If not null, this value will be used as the JRE container path in .classpath. useVarPath [boolean] If true, dependency paths will be expressed relatively to Eclipse path variables instead of absolute paths. <p>This KBean exposes the following methods:</p> Method Description all Generates Eclipse files (.project and .classpath) on all sub-folders of the current directory. Only sub-folders having a jeka-src directory are taken in account. See eclipse#files. files Deprecated: use 'sync' instead. sync Generates Eclipse files (.classpath and .project) in the current directory. The files reflect project dependencies and source layout."},{"location":"reference/kbeans-git/","title":"Git KBean","text":"<p>Provides convenient operations for Git.</p> <p><code>GitKBean</code> provides command combos such as:</p> <ul> <li>Displaying a list of commit messages since the last tag.</li> <li>Pushing remote tags with guards to ensure the local workspace is clean.</li> </ul>"},{"location":"reference/kbeans-git/#summary","title":"Summary","text":"<p>Provides convenient operations for Git.</p> <p>This KBean exposes the following methods:</p> Method Description lastCommitMessages Displays all commit messages since last tag. lastTag Displays last git tag in current branch. moveLatest Moves the 'latest' tag to the current commit and push it to origin. tagRemote Performs a dirty check first, put a tag at the HEAD and push it to the remote repo. The user will be prompted to enter the tag name."},{"location":"reference/kbeans-intellij/","title":"IntelliJ KBean","text":"<p>Manages Intellij metadata files.</p> <p><code>IntellijKBean</code> provides methods for generating metadata files for IntelliJ IDE.  The content of an <code>.iml</code> file is computed according to the <code>JkBuildable</code> object found in the base directory.</p> <p>This KBean provides methods to customize the generated <code>.iml</code> file.</p> Configuration in a Build.java class<pre><code>@JkPostInit\nprivate void postInit(IntellijKBean intellijKBean) {\n    intellijKBean\n            .replaceLibByModule(\"dev.jeka.jeka-core.jar\", \"core\")\n            .setModuleAttributes(\"core\", JkIml.Scope.COMPILE, null);\n}\n</code></pre>"},{"location":"reference/kbeans-intellij/#summary","title":"Summary","text":"<p>Manages Intellij metadata files.</p> <p>This KBean exposes the following fields:</p> Field Description useVarPath [boolean] If true, dependency paths will be expressed relatively to $JEKA_REPO$ and $JEKA_HOME$ path variable instead of absolute paths. failOnDepsResolutionError [boolean] If true, the iml generation fails when a dependency can not be resolved. If false, it will be ignored (only a warning will be notified). splitModule [boolean] Experimental: If true, 'jeka-src' will have its own IntelliJ module. focus [enum:IntellijKBean$SyncFocus] Experimental: If 'jeka-src' is in its own module, the 'sync' action can target it specifically. downloadSources [boolean] If true, sources will be downloaded will resolving dependencies. <p>This KBean exposes the following methods:</p> Method Description initProject Re-init the project by deleting workspace.xml and regenerating .idea/modules.xml. modulesXml Generates ./idea/modules.xml file by grabbing all .iml files presents in root or sub-directory of the project. sync Generates IntelliJ [my-module].iml file. syncAll Generates iml files on this folder and its descendant recursively."},{"location":"reference/kbeans-maven/","title":"Maven KBean","text":"<p>Manages Maven publication for project and 'jeka-src'.</p> <p><code>MavenKBean</code> provides the ability to publish artifacts to a  Maven repository. The artifacts are those produced by the <code>project</code> or <code>base</code> KBeans.  It also provides convenient means to migrate from Maven projects.</p> <p>Key Features:</p> <ul> <li>Publish artifacts produced by projects to local or remote repositories.</li> <li>Display information about publication, especially transitive dependencies published along with the artifacts.</li> <li>Property or programmatic configuration for published POM metadata and dependencies.</li> <li>Property or programmatic configuration for the publication repository.</li> </ul>"},{"location":"reference/kbeans-maven/#summary","title":"Summary","text":"<p>Manages Maven publication for project and 'jeka-src'.</p> <p>This KBean exposes the following fields:</p> Field Description codeIndent [int] Indentation size for 'showPomDeps' output. args [String] Arguments to pass to mvn command while building. Examples 'clean test', '-Pnative -X'. appModule [String] In multi-module projects, the module containing the application to build. Defaults to root module if not specified. pub.moduleId [String] Module id of the module to publish formatted as groupId:artifactId. pub.version [String] The version of the module to publish. pub.parentBom [boolean] If true, the publication will generate a BOM as its only artifact. The BOM will point to the version of each child base that contains a project KBean.Be caution to declare it with leading '' as  '@maven.pub.parentBom' in jeka.properties to not propagate it to children. pub.gitVersioning.enable [boolean] If true, a version computed from the current Git branch/tag will be injected into the Maven KBean to determine the published version. pub.gitVersioning.tagPrefix [String] Some prefer to prefix version tags like 'v1.3.1' instead of simply using '1.3.1'. In such cases, this value can be set to 'v' or any other chosen prefix. pub.metadata.projectName [String] Human-friendly name for the project to publish. pub.metadata.projectDescription [String] Description for the project to publish. pub.metadata.projectUrl [String] The page to visit to know more about the project. pub.metadata.projectScmUrl [String] The url to fetch source code, as the git repo url. pub.metadata.licenses [String] Comma separated list of license formated as =. pub.metadata.developers [String] Comma separated list of developers formatted as :. pub.predefinedRepo [enum:MavenKBean$PredefinedRepo] If not null, the publication will be published on this repo. pub.extraArtifacts [String] Coma separated string of artifact classifiers to publish, in format [classifier] or [classifier].[extension].This assumes the artifact file be present in jeka-output dir.Example: 'uber', 'doc.zip'. <p>This KBean exposes the following methods:</p> Method Description info Displays Maven publication information on the console. migrateDeps Displays Java code for declaring dependencies based on pom.xml. The pom.xml file is supposed to be in root directory. publish Publishes the Maven publication on the repositories specified inside this publication. publishLocal Publishes the Maven publication on the local JeKa repository. publishLocalM2 Publishes the Maven publication on the local M2 repository. This is the local repository of Maven. wrap Runs Maven from Jeka using arguments from 'args' field. wrapPackage Calls Maven 'package' from Jeka and copy produced artifacts to jeka-output."},{"location":"reference/kbeans-native/","title":"Native KBean","text":"<p>Creates native executables.</p> <p>A native image is an executable file created from Java bytecode. This KBean allows creating native images from executable jars generated from the project.</p> <p><code>NativeKBean</code> enables native compilation for the <code>project</code> and <code>base</code> KBeans.</p> <p>Key Features</p> <ul> <li>Compiles classes into native executables.</li> <li>Automatically applies AOT metadata.</li> <li>Simplifies resource inclusion.</li> <li>Handles static linkage with minimal configuration.</li> </ul>"},{"location":"reference/kbeans-native/#usage","title":"Usage","text":"<p>The <code>NativeKBean</code> works with either <code>project</code> or <code>base</code> KBeans to compile your Java application into a native executable using GraalVM native-image.</p>"},{"location":"reference/kbeans-native/#basic-invocation","title":"Basic Invocation","text":"<pre><code>jeka native: compile\n</code></pre> <p>This command: 1. Compiles your project if needed 2. Creates a native executable from the project's main artifact jar 3. Places the executable in the output directory (same location as the jar, but without <code>.jar</code> extension)</p>"},{"location":"reference/kbeans-native/#configuration","title":"Configuration","text":"<p>Configure the KBean through <code>jeka.properties</code> or programmatically in your KBean class.</p> <p>Example configuration in <code>jeka.properties</code>: <pre><code>@native.includeAllResources=true\n@native.staticLink=MUSL\n@native.metadataRepoVersion=0.10.3\n@native.args=--verbose --no-fallback\n</code></pre></p> <p>Available Configuration Options:</p> <ul> <li><code>args</code>: Extra arguments to pass to the native-image compiler (e.g., <code>--verbose --no-fallback</code>)</li> <li><code>staticLink</code>: Static linkage mode for native libraries<ul> <li><code>NONE</code> (default): No static linking</li> <li><code>MUSL</code>: Static linking with MUSL libc</li> <li><code>GLIBC</code>: Static linking with GLIBC</li> </ul> </li> <li><code>useMetadataRepo</code>: Uses predefined exploratory AOT metadata from the standard repository (default: <code>true</code>)</li> <li><code>metadataRepoVersion</code>: Version of the GraalVM reachability metadata repository to use</li> <li><code>includeMainClassArg</code>: Whether to specify the main class in command line arguments (default: <code>true</code>)</li> <li><code>includeAllResources</code>: Includes all resources in the native image (default: <code>false</code>)</li> </ul>"},{"location":"reference/kbeans-native/#programmatic-configuration","title":"Programmatic Configuration","text":"<p>You can also configure the <code>NativeKBean</code> programmatically:</p> <pre><code>@JkDefClasspath(\"com.example:my-lib:1.0\")\npublic class Build extends KBean {\n\n    final NativeKBean nativeKBean = load(NativeKBean.class);\n\n    Build() {\n        nativeKBean.includeAllResources = true;\n        nativeKBean.staticLink = JkNativeCompilation.StaticLink.MUSL;\n        nativeKBean.args = \"--verbose --no-fallback\";\n    }\n}\n</code></pre>"},{"location":"reference/kbeans-native/#aot-metadata","title":"AOT Metadata","text":"<p>The KBean automatically handles AOT (Ahead-Of-Time) metadata required for reflection, resources, and JNI access in native images:</p> <ul> <li>By default, it uses the GraalVM reachability metadata repository</li> <li>The metadata repository version can be specified via <code>metadataRepoVersion</code></li> <li>Disable with <code>@native.useMetadataRepo=false</code> if you provide your own metadata</li> </ul>"},{"location":"reference/kbeans-native/#requirements","title":"Requirements","text":"<ul> <li>GraalVM is automatically downloaded if not already available</li> <li>The <code>project</code> or <code>base</code> KBean must be present in your build</li> </ul> <p>See native API for low-level API details.</p>"},{"location":"reference/kbeans-native/#summary","title":"Summary","text":"<p>Creates native executables.</p> <p>A native image is an executable file created from Java bytecode. This KBean allows creating native images from executable jars generated from the project.</p> <p>This KBean exposes the following fields:</p> Field Description args [String] Extra arguments to pass to native-image compiler. staticLink [enum:JkNativeCompilation$StaticLink] Specifies whether the generated executable must be statically linked with native libs. useMetadataRepo [boolean] Uses predefined exploratory AOT metadata defined in the standard repository. metadataRepoVersion [String] Version of the predefined exploratory AOT metadata repository. includeMainClassArg [boolean] If false, the main class won't be specified in command line arguments. This means that it is expected to be mentioned in aot config files. includeAllResources [boolean] If true, all resources will be included in the native image. <p>This KBean exposes the following methods:</p> Method Description compile Creates a native image from the project's main artifact jar.Builds the artifact first if none exists."},{"location":"reference/kbeans-project/","title":"Project KBean - The Java Build Engine","text":"<p>Manages the build and execution of a JVM project.</p> <p>It contains all information and methods for resolving dependencies, compiling, testing and packaging as JARs.</p> <p><code>ProjectKBean</code>  is the core KBean for building JVM projects in JeKa. It acts as the equivalent of the Java Plugin in Maven or Gradle,  wrapping a <code>JkProject</code> instance to provide high-level build automation.</p>"},{"location":"reference/kbeans-project/#key-features","title":"Key Features","text":"<ul> <li>Standardized Build Lifecycle: Methods for <code>compile</code>, <code>test</code>, <code>pack</code>, and more out-of-the-box.</li> <li>Dependency Management: Automated resolution for compile, runtime, and test classpaths.</li> <li>Artifact Creation: Generates regular, fat (uber), shaded, source, and Javadoc JARs.</li> <li>Project Introspection: Displays detailed dependency trees and project configurations.</li> <li>Git Integration: Automatically infers project versions from Git tags/metadata.</li> <li>Extensibility: Foundation for other KBeans to extend the build process (e.g., Docker, Jacoco, Sonarqube).</li> </ul>"},{"location":"reference/kbeans-project/#core-methods","title":"Core Methods","text":"<p><code>ProjectKBean</code> exposes several methods to automate your build process from the command line:</p> Method Description <code>scaffold</code> Creates a new project structure and build script skeleton. <code>clean</code> Deletes the <code>jeka-output</code> directory. <code>compile</code> Compiles source code and processes resources. <code>test</code> Compiles and executes unit tests (e.g., JUnit 5). <code>pack</code> Creates the project's JAR artifacts. <code>build</code> Complete cycle: <code>clean</code> -&gt; <code>compile</code> -&gt; <code>test</code> -&gt; <code>pack</code> -&gt; <code>checkQuality</code> -&gt; <code>e2eTest</code>. <code>info</code> Displays project metadata (version, module ID, layout, etc.). <code>depTree</code> Prints the resolved dependency tree to the console. <code>runJar</code> Executes the generated JAR file."},{"location":"reference/kbeans-project/#common-options","title":"Common Options","text":"<p>These properties can be set via command line (e.g., <code>project: javaVersion=17</code>) or in <code>jeka.properties</code> (e.g., <code>@project.javaVersion=17</code>).</p> Property Description Default <code>javaVersion</code> Target JVM version (e.g., <code>21</code>, <code>25</code>). Same as JeKa runtime <code>test.skip</code> If <code>true</code>, tests are not executed. <code>false</code> <code>pack.jarType</code> Type of JAR to produce (<code>REGULAR</code>, <code>FAT</code>). <code>REGULAR</code> <code>version</code> Hardcode the project version. Inferred from Git <code>moduleId</code> Maven coordinates (<code>group:name</code>). <code>null</code>"},{"location":"reference/kbeans-project/#programmatic-customization","title":"Programmatic Customization","text":"<p>Access the underlying <code>JkProject</code> for deep customization, typically within <code>@JkPostInit</code>.</p> <pre><code>class MyBuild extends KBean {\n\n    @JkPostInit(required = true)\n    private void postInit(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n\n        // Example: Add a custom compiler option\n        project.compilation.addJavaCompilerOptions(\"-Xlint:unchecked\");\n\n        // Example: Customize the JAR manifest\n        project.pack.manifest.addMainAttribute(\"Author\", \"JeKa Team\");\n    }\n}\n</code></pre>"},{"location":"reference/kbeans-project/#annotation-processors","title":"Annotation Processors","text":"<p>Enable processors like Lombok by adding them as <code>compile-only</code> dependencies in <code>jeka.project.deps</code>:</p> <pre><code>[compile-only]\norg.mapstruct:mapstruct-processor:1.6.3\norg.projectlombok:lombok:1.18.38\n</code></pre> <p>Output directory: <code>jeka-output/generated-sources/annotation-processors</code>.</p>"},{"location":"reference/kbeans-project/#extending-with-plugins","title":"Extending with Plugins","text":"<p><code>ProjectKBean</code> is designed to be extensible. Many JeKa plugins interact with it to add specific capabilities:</p> <ul> <li>Jacoco: Collects code coverage during the <code>test</code> phase.</li> <li>Sonarqube: Exports project data for static analysis.</li> <li>Protobuf: Integrates Protocol Buffers compilation.</li> <li>Docker: Packages your project as a Docker image.</li> </ul>"},{"location":"reference/kbeans-project/#summary","title":"Summary","text":"<p>Manages the build and execution of a JVM project.</p> <p>It contains all information and methods for resolving dependencies, compiling, testing and packaging as JARs.</p> KBean Initialisation Applies the specified configuration to the underlying <code>JkProject</code> instance. <p>This KBean exposes the following fields:</p> Field Description version [String] Version of the project. Can be used by a CI/CD tool to inject version. moduleId [String] Module id of the project. Only needed if the project is published on a Maven repository. sourceEncoding [String] The encoding format used for handling source files within the project. javaVersion [String] Specifies the Java version used to compile and run the project. By default, this is the same as the version used to run Jeka. pack.jarType [enum:JkProjectPackaging$JarType] Type of jar to produce for the main artifact. pack.shadeJarClassifier [String] If not blank, the project will produce an extra shade jar having the specified classifier name.A shade Jar embeds classes coming from dependency jars. The dependency class packages are relocated to avoid potential collisions with other jar present in the classpath. pack.mainClass [String] Main class name to include in Manifest. pack.detectMainClass [boolean] If true and no mainClass specified, it will be detected and added to the Manifest. pack.javadocOptions [String] Options to pass to javadoc tool when invoked. e.g '--notimestamp -doctitle \"My Project API\"'. run.jvmOptions [String] JVM options to use when running generated jar. run.programArgs [String] Program arguments to use when running generated jar. run.useRuntimeDepsForClasspath [boolean] If true, the resolved runbase classpath will be used when running the generated jar. If the generated jar is a Uber jar or contains all the needed dependencies, leave it to 'false'. dependencies.compile [String] Comma separated compile dependencies to include at scaffold time. dependencies.runtime [String] Comma separated runtime dependencies to include at scaffold time. dependencies.test [String] Comma separated test dependencies to include at scaffold time. test.includePatterns [String] Space-separated string to filter the test class names to run. Use regex patterns like '.', '.Test', '.*IT', or 'ac.me.MyTest'. test.skip [boolean] If true, tests are not run. test.fork [boolean] If true, tests will be executed in a forked process. test.jvmOptions [String] Argument passed to the JVM if tests are executed in a forked process (example -Xms2G -Xmx2G). test.progress [enum:JkTestProcessor$JkProgressStyle] The style to use to show test execution progress. scaffold.generateLibsFolders [boolean] Generate libs sub-folders for hosting local libraries. scaffold.kind [enum:JkProjectScaffold$Kind] The template used for scaffolding the build class. scaffold.jekaVersion [String] Set a specific jeka.version to include in jeka.properties. NO: no jeka.version specified, [EMPTY]: last version found in Maven Central. scaffold.jekaLocation [String] Set a specific jeka.distrib.location to include in jeka.properties. scaffold.jekaDistribRepo [String] Set a specific jeka.distrib.repo to include in jeka.properties. scaffold.extraJekaProps [String] Coma separated string representing properties to add to jeka.properties. scaffold.rawJekaPropsContentPath [Path] Set the path of a file containing the exact content of the jeka.properties file to generate.If this field is set, all others related to jeka.properties generation are ignored. layout.style [enum:JkCompileLayout$Style] Style of directory source structure (src/main/java or just src). layout.mixSourcesAndResources [boolean] If true, Resource files are located in same folder than Java code. compilation.fork [boolean] Specify whether to fork the compilation process. compilation.javaVersion [String] The target JVM version for compiled files. compilation.compilerOptions [String] Extra arguments to be passed to the compiler (example -Xlint:unchecked). outputFile [Path] The output file for the xml dependency description. gitVersioning.enable [boolean] If true, a version computed from the current Git branch/tag will be injected into the Maven KBean to determine the published version. gitVersioning.tagPrefix [String] Some prefer to prefix version tags like 'v1.3.1' instead of simply using '1.3.1'. In such cases, this value can be set to 'v' or any other chosen prefix. <p>This KBean exposes the following methods:</p> Method Description build Runs a full build: cleans, compiles, tests, packs, checks quality and runs end-to-end tests. checkQuality Runs the quality checkers. clean Deletes the content of jeka-output directory and might execute extra clean actions. compile Performs compilation and resource processing. depTree Displays resolved dependency trees on console. depTreeAsXml Displays resolved dependency trees as xml, on console. e2eTest Runs the registered end-to-end tests. generateSources Generates sources. info Displays information about the Java project to build. pack Generates artifacts based on 'pack' options. Creates a single JAR by default. runJar Runs the generated jar. runMain Runs the compiled classes. scaffold Scaffolds a JeKa project skeleton in working directory. test Compiles and run tests defined within the project (typically Junit tests)."},{"location":"reference/kbeans-setup/","title":"Setup KBean","text":"<p>Provides convenient methods to perform global configuration tasks as editing global.properties file</p> <p>or updating embedded jeka boot scripts.</p> <p>Provides convenient methods to perform global configuration tasks such as editing the global.properties file or updating  embedded JeKa boot scripts.</p>"},{"location":"reference/kbeans-setup/#summary","title":"Summary","text":"<p>Provides convenient methods to perform global configuration tasks as editing global.properties file</p> <p>or updating embedded jeka boot scripts.</p> <p>This KBean exposes the following fields:</p> Field Description content [String] Argument for 'addGlobalProp' and 'installApp' methods. name [String] Argument for the 'removeApp' method. <p>This KBean exposes the following methods:</p> Method Description addShorthand Adds a shorthand to the global properties file.Provide it as 'content=[shorthand-name]=[shorthand content]E.g. 'jeka operations: addShorthand content=build=project: pack sonarqube: run'. editGlobalProps Edits the global.properties file. openHomeDir Opens a file explorer window in the JeKA user home directory. updateLocalScripts Creates or updates jeka.ps1 and jeka bash scripts in the current directory.Uses the running JeKa version to set the script version."},{"location":"reference/kbeans/","title":"KBeans","text":"<p>KBean is the central concept of the execution engine. KBeans are classes with declared executable methods. There is only one KBean instance per KBean class in any given Jeka base directory.</p> <p>KBean classes share the following characteristics:</p> <ul> <li>They extend the <code>KBean</code> class.</li> <li>They may declare <code>public void</code> methods without arguments. All these methods can be invoked from the command line.</li> <li>They may declare <code>public</code> fields (also known as KBean properties). These field values can be injected from the command line.   Additionally, they can have non-public fields annotated with <code>@JkDoc</code>.</li> <li>They must provide a no-argument constructor.</li> <li>They may override the <code>init()</code> method.</li> <li>They must be instantiated by the execution engine and not by user code.</li> </ul>"},{"location":"reference/kbeans/#simple-example","title":"Simple Example","text":"<p>The following KBean exposes the <code>hello</code> and <code>bye</code> methods. The rendering can be configured  through <code>name</code> and <code>uppercase</code> attributes.</p> <p><pre><code>@JkDoc(\"Displays greeting messages\")\npublic class Greeting extends KBean {\n\n    public String name = \"Bob\";\n\n    @JkDoc(\"If true, the message is shown in upper case.\")\n    public boolean uppercase;\n\n    @JkDoc(\"Prints a hello message.\")\n    public void hello() {\n        System.out.println(formatMessage(\"Hello \" + name + \"!\"));\n    }\n\n    public void bye() {\n        System.out.println(formatMessage(\"Goodbye \" + name + \"!\"));\n    }\n\n    private String formatMessage(String message) {\n        return uppercase ? message.toUpperCase() : message;\n    }\n}\n</code></pre> To execute a method from the command line, run the following example: <pre><code>jeka hello name=Alice uppercase=true\n</code></pre> To show help for this KBean, run: <pre><code>jeka greeting: --doc\n</code></pre> This will display: <pre><code>Displays greeting messages.\n\nFields\n      name=&lt;String&gt;   No description.\n                        Default: Bob\n      uppercase       If true, the message is shown in upper case.\n                        Default: false\nMethods\n  bye    No Description.\n  hello  Prints a hello message.\n</code></pre></p>"},{"location":"reference/kbeans/#location","title":"Location","text":"<p>KBeans can exist as source code in the local project jeka-src folder (at the root or in any package), or  as a class in the JeKa classpath.</p> <p>Multiple KBeans in jeka-src</p> <p>Many KBeans may coexist in a single jeka-src directory. In this case, use KBean names to specify  which bean to invoke, for example:</p> <p><pre><code>jeka greeting: hello bye other: foo\n</code></pre> In the above example, three methods from two distinct KBeans are invoked.</p> <p>Classpath KBeans</p> <p>JeKa bundles a collection of KBeans for building projects, creating Docker images, performing Git operations, and more.</p> <ul> <li>Project KBean: The standard KBean for building JVM-based projects.</li> <li>Base KBean: For building simpler JVM-based projects without a standard Maven/Gradle layout.</li> <li>Maven KBean: For publishing artifacts to Maven repositories.</li> <li>Docker KBean: For creating Docker images.</li> <li>Native KBean: For compiling code to native executables.</li> <li>App KBean: For installing/uninstalling applications locally. (Admin KBean)</li> <li>Git KBean: For performing Git operations.</li> <li>IntelliJ KBean: For generating IntelliJ IDEA project files.</li> <li>Eclipse KBean: For generating Eclipse project files.</li> <li>Setup KBean: For global JeKa configuration. (Admin KBean)</li> </ul> <p>For example, running: <pre><code>jeka project: compile\n</code></pre> will compile the source code located in the <code>src/main/java</code> directory, using dependencies specified in the <code>jeka.project.deps</code> file.</p> <p>To display the documentation for the <code>project</code> KBean, run: <pre><code>jeka project: --doc\n</code></pre></p> <p>To list all available KBeans in the classpath, execute: <pre><code>jeka --doc\n</code></pre></p> <p>Admin KBeans</p> <p>Admin KBeans are special KBeans designed to operate independently of the current project structure. They run in admin mode, which means:</p> <ul> <li>No compilation of the jeka-src directory is performed</li> <li>No dependency resolution is executed</li> <li>No child modules are traversed in multi-module projects</li> <li>They are agnostic to the current working directory</li> </ul> <p>JeKa automatically enters admin mode when only admin KBeans are specified on the command line.</p> <p>Currently, JeKa includes two admin KBeans:</p> <ul> <li>app: For installing, updating, and managing applications globally</li> <li>setup: For global JeKa configuration tasks</li> </ul> <p>Examples: <pre><code># Install an application (runs in admin mode)\njeka app: install repo=https://github.com/djeang/kill8 name=kill8\n\n# Configure global JeKa settings (runs in admin mode)\njeka setup: editGlobalProperties\n\n# Mixed usage is not allowed - this will fail\njeka app: list project: pack\n</code></pre></p> <p>Note</p> <p>Admin KBeans cannot be mixed with regular KBeans in a single command. If you need to run both, execute them in separate commands.</p> <p>KBeans can be added to the classpath like any third-party dependency. This can be done by setting the <code>jeka.inject.classpath</code> property in the <code>jeka.properties</code> file as follows: <pre><code>jeka.inject.classpath=dev.jeka:springboot-plugin   dev.jeka:openapi-plugin:0.11.8-1\n</code></pre></p> <p>KBeans can also be included directly in the source code using the <code>@JkDep</code> annotation: <pre><code>import dev.jeka.core.tool.JkDep;\n\n@JkDep(\"dev.jeka:springboot-plugin\")\n@JkDep(\"dev.jeka:openapi-plugin:0.11.8-1\")\nclass Custom extends KBean {\n}\n</code></pre></p> <p>Additionally, KBeans can be dynamically added from the command line like this: <pre><code>jeka --classpath=dev.jeka:openapi-plugin:0.11.8-1 openapi:--doc\n</code></pre></p> <p>Jeka discovers KBeans automatically by scanning the classpath.</p>"},{"location":"reference/kbeans/#kbean-methods","title":"KBean Methods","text":"<p>A KBean method is a specific method defined in a KBean class, designed to be executable from the command line interface. For successful recognition as a command, the method must adhere to the following criteria:</p> <ul> <li>It must be designated as <code>public</code>.</li> <li>It must be an instance method, not static or abstract.</li> <li>It must not require any arguments upon invocation.</li> <li>It must not return any value, as indicated by a <code>void</code> return type.</li> </ul>"},{"location":"reference/kbeans/#kbean-fields","title":"KBean Fields","text":"<p>A KBean field is a <code>public</code> instance field of a KBean class. Its value can be injected from the command line or from a property file. Additionally, it can be a non-public field annotated with <code>@JkDoc</code>.</p> <p>Fields can be annotated with <code>@JkInjectProperty(\"my.prop.name\")</code> to inject the value of a property into the field.</p> <p>We can also inject value using <code>jeka.properties</code> file.</p> <p>For more details on field accepted types, see the <code>dev.jeka.core.tool.FieldInjector#parse</code> method.</p> <p>KBean fields can also represent nested composite objects. See the example in the <code>ProjectKBean#pack</code> field.</p>"},{"location":"reference/kbeans/#naming-kbeans","title":"Naming KBeans","text":"<p>To be referenced conveniently, KBeans can be identified by specific names. For any given KBean class, the accepted names are:</p> <ol> <li>Fully qualified class name.</li> <li>Uncapitalized simple class name (e.g., <code>myBuild</code> matches <code>org.example.MyBuild</code>).</li> <li>Uncapitalized simple class name without the <code>KBean</code> suffix (e.g., <code>project</code> matches <code>dev.jeka.core.tool.builtin.project.ProjectKBean</code>).</li> </ol> <p>Tip</p> <p>Execute <code>jeka</code> at the root of a project to display the KBeans available on the Jeka classpath.</p>"},{"location":"reference/kbeans/#document-kbeans","title":"Document KBeans","text":"<p>KBean classes, methods, and attributes can include the <code>@JkDoc</code> annotation to provide self-documentation. The text from these annotations is displayed when running the command: <pre><code>jeka &lt;kbeanName&gt;: --doc\n</code></pre> To display documentation for the default KBean, simply run: <pre><code>jeka --doc\n</code></pre></p> <p>Use the <code>@JkDocUrl</code> annotation to indicate that a KBean has online documentation. This URL will be displayed in the output of the <code>--doc</code> command.</p> <p>To document your KBean, you can use the following command: <pre><code>jeka &lt;kbeanName&gt;: --doc-md\n</code></pre> This command generates a markdown-formatted document of the specified KBean. You can copy and paste the output directly into your online documentation.</p>"},{"location":"reference/kbeans/#invoke-kbeans","title":"Invoke KBeans","text":""},{"location":"reference/kbeans/#from-the-command-line","title":"From the Command Line","text":"<p>KBean methods can be executed directly from the command line using the syntax:</p> <pre><code>jeka &lt;kbeanName&gt;: [methodName...] [attributeName=xxx...]\n</code></pre> <p>Example: <pre><code>jeka project: info pack tests.fork=false pack.jarType=FAT sonarqube: run\n</code></pre></p> <p>You can call multiple methods and set multiple fields in a single command.</p>"},{"location":"reference/kbeans/#from-intellij-jeka-plugin","title":"From IntelliJ Jeka Plugin","text":"<p>The IntelliJ Jeka Plugin enables invoking KBean methods directly from the IDE,  either from the code editor or the project explorer tool window.</p>"},{"location":"reference/kbeans/#from-a-plain-ide-setup","title":"From a Plain IDE Setup","text":"<p>KBean methods can also be launched or debugged in an IDE by invoking the <code>dev.jeka.core.tool.Main</code> method and passing the corresponding command-line arguments.</p> <p>Example: Invoking the <code>dev.jeka.core.tool.Main</code> method with arguments <code>project:</code> and <code>compile</code> will instantiate the <code>ProjectKBean</code> class and invoke its <code>compile</code> method.</p> <p>Warning</p> <p>Ensure that the main method is launched with the module directory set as the working directory. In IntelliJ, the default working directory is the project directory, which may cause issues.</p> <p>To update IntelliJ defaults: - Navigate to Run | Edit Configurations... | Application | Working Directory - Set the value to <code>$MODULE_DIR$</code>.</p>"},{"location":"reference/kbeans/#default-kbean","title":"Default KBean","text":"<p>When invoking Kbean methods or fields, we generally specify to which KBean this applies:</p> <p>Examples: <pre><code>jeka project: pack\njeka myBean: foo bar=1\n</code></pre></p> <p>If the target KBean is the default KBean, then this we don't need to mention the KBean name.</p> <p>By default, the default KBean is the first KBean found in jeka-src dir.  For instance, if you have a single KBean  <code>MyBean</code> in jeka-src, then you can invoke directly the methods and fields as following: <pre><code>jeka foo bar=1\n</code></pre> If you need to invoke methods of other KBean, in between, you can use the <code>:</code> symbol as: <pre><code>jeka project: pack : foo bar=1\n</code></pre> The above example invokes the <code>ProjectKBean#pack</code> method, then the  <code>MyBean#foo</code> method.</p> <p>You can select a specific default KBean, by setting the following property in jeka-src or as command-line argument: <pre><code>jeka.kbean.default=project\n</code></pre></p> <p>You can also mention the default KBean using <code>--kbean=</code> option.</p> <p>The default KBean always participate in the runbase initialisation.</p> <p>This is quite frequent for project builds to use such setting as it shortens command line and prone usage of  <code>ProjectKBean</code> standard methods.</p>"},{"location":"reference/kbeans/#kbean-initialization","title":"KBean Initialization","text":"<p>During startup, JeKa initializes these KBeans:</p> <ul> <li>The default KBean</li> <li>KBeans specified with <code>@myKbean=on</code> in jeka.properties</li> </ul> <p>After identifying these initial KBeans, JeKa performs a discovery phase to find additional KBeans that need initialization:</p> <ul> <li>KBeans referenced as parameters in methods annotated with <code>@JkPostInit(required = true)</code></li> <li>KBeans returned by static methods annotated with <code>@JkRequire</code></li> </ul> <p>This discovery mechanism allows dynamic addition of KBeans to the initialization list.</p> <p>Example:</p> <p>If you have a <code>Custom</code> KBean located in the jeka-src directory, its class will be inspected under two conditions:</p> <ol> <li>It is set as the default KBean</li> <li>It is enabled with <code>@custom=on</code> in the jeka.properties file</li> </ol> <p>Then it will be inspected to discover other KBeans to initialize.</p> <pre><code>import dev.jeka.core.tool.JkPostInit;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\n\nclass Custom extends KBean {\n\n    @JkRequire\n    private static Class&lt;? extends KBean&gt; require(JkRunbase runbase) {\n        return runbase.getBuildableClass();\n    }\n\n    @JkPostInit(required = true)\n    private void postInit(MavenKBean mavenKBean) {\n    }\n}\n</code></pre> <p>In this example, the <code>MavenKBean</code> will be included in the initialized KBeans.</p> <p>The <code>require(JkRunbase)</code> method will be invoked to know which KBean should be initialized too (either <code>ProjectKBean</code> nor <code>BaseKBean</code>.)</p>"},{"location":"reference/kbeans/#invoke-kbean-from-another-kbean","title":"Invoke KBean from another KBean","text":""},{"location":"reference/kbeans/#using-jkinject","title":"Using @JkInject","text":"<p><pre><code>import dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\nimport dev.jeka.core.tool.JkInject;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\nclass Build extends KBean {\n\n    @JkInject\n    private ProjectKBean projectKBean;\n\n    @JkInject\n    private MavenKBean mavenKBean;\n\n    @JkDoc(\"Clean, compile, test, create jar files, and publish them.\")\n    public void packPublish() {\n        projectKBean.clean();\n        projectKBean.pack();\n        mavenKBean.publishLocal();\n    }\n\n}\n</code></pre> Both <code>ProjectKBean</code> and <code>MavenKBean</code> are created and injected into the <code>Build</code> KBean during initialization.</p>"},{"location":"reference/kbeans/#using-load-and-find-methods","title":"Using #load and #find methods","text":"<p>As we saw earlier, you can dynamically retrieve a <code>KBean</code> using the <code>KBean#load(Class)</code> method. This method forces the initialization of the <code>KBean</code> if it is not already present. It is useful when you need a specific <code>KBean</code> only within certain methods.</p> <pre><code>@JkDoc(\"Compiles application to native executable\")\npublic void createNativeExec() {\n    load(NativeKBean.class).compile();\n}\n</code></pre> <p>On the other hand, the <code>KBean#find(Class)</code> method returns an <code>Optional&lt;? extends KBean&gt;</code>, which is empty if the specified <code>KBean</code> is not initialized. This is helpful for performing conditional tasks based on the presence of a <code>KBean</code>.</p> <pre><code>import dev.jeka.core.tool.builtins.tooling.docker.DockerKBean;\n\npublic void cleanup() {\n    find(DockerKBean.class).ifPresent(dockerKBean -&gt; {\n        // Do something\n    });\n}\n</code></pre>"},{"location":"reference/kbeans/#configure-a-kbean-from-another-kbean","title":"Configure a Kbean from another KBean.","text":"<p>Whether you want to create a JeKa plugin or simply configure a build, the approach is the same:  create a <code>KBean</code> and configure an existing one.</p> <p>For example, to configure a build, you can create a <code>Build</code> class as follows:</p> <p><pre><code>class Build extends KBean {\n\n    public boolean skipIT;\n\n    @JkPreInit\n    private static void preInit(ProjectKBean projectKBean) {\n        projectKBean.tests.progress = JkTestProcessor.JkProgressStyle.PLAIN;\n    }\n\n    @JkPostInit(required = true)\n    private void postInit(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n        project.flatFacade.dependencies.compile\n                .add(\"com.google.guava:guava:33.3.1-jre\")\n                .add(\"org.openjfx:javafx-base:21\");\n        project.flatFacade.dependencies.test\n                .add(\"org.junit.jupiter:junit-jupiter:5.8.1\");\n        project.flatFacade\n                .addTestExcludeFilterSuffixedBy(\"IT\", skipIT);\n    }\n\n    @JkPostInit\n    private void postInit(MavenKBean mavenKBean) {\n\n        // Customize the published pom dependencies\n        mavenKBean.getMavenPublication().customizeDependencies(deps -&gt; deps\n                .withTransitivity(\"com.google.guava:guava\", JkTransitivity.RUNTIME)\n                .minus(\"org.openjfx:javafx\")\n        );\n    }\n\n}\n</code></pre> This KBean defines a <code>Build</code> class that customizes the <code>project</code> and <code>maven</code> KBeans. </p>"},{"location":"reference/kbeans/#pre-initialize-kbeans","title":"Pre-initialize KBeans","text":"<p>The <code>preInit</code> methods are invoked before the KBean is instantiated; therefore, they must be declared as <code>static</code>. These methods are applied to the target KBean immediately after it is instantiated but before it is initialized. This means they are executed prior to the injection of properties or command-line values.</p> <p>The sole purpose of <code>preInit</code> methods is to provide default values, which can later be overridden by properties or command-line arguments. They should not perform further configuration, as the target KBean has not yet been fully initialized when these methods are invoked.</p>"},{"location":"reference/kbeans/#post-initialize-kbeans","title":"Post-initialize KBeans","text":"<p>The <code>postInit</code> methods are invoked only if their respective <code>KBean</code> is fully initialized.  This occurs after its properties and command-line values have been injected, and its <code>init()</code> method has been executed.</p> <p>The <code>required = true</code> attribute, means that the KBean project must be instantiated by JeKa, if not already setup.</p> <p>For example, when executing <code>jeka project: pack</code>, the <code>ProjectKBean</code> will be initialized with the settings provided by  command-line arguments and <code>@project...=</code> properties defined in the jeka.properties file.  The instance will then be passed to the <code>postInit</code> method before invoking the <code>pack</code> method.</p> <p>When executing <code>jeka maven: publish</code>, the <code>project</code> KBean will be implicitly loaded and configured,  followed by the same process for the <code>maven</code> KBean, before invoking the <code>publish</code> method.</p>"},{"location":"reference/kbeans/#lifecycle","title":"Lifecycle","text":"<p>Before Kbean methods are executed, Kbeans are configured as described in the detailed sequence:</p> <pre><code>sequenceDiagram\n    participant RB as Run Base\n    participant IN as Init class resolver\n    participant IT as Instantiater\n    participant KB as KBean\n    participant PR as Pre-initializer\n    participant PO as Post-initializer\n    participant RK as Registered KBeans\n\n    RB-&gt;&gt;IN:  Discover classes to init\n    RB-&gt;&gt;PR:  Register pre-init methods\n    RB-&gt;&gt;IT:  Instantiate classes to init\n    IT-&gt;&gt;KB:  New\n    IT-&gt;&gt;RK:  Register Kbean instance\n    IT-&gt;&gt;PR:  Pre-initialise KBean\n    IT-&gt;&gt;KB:  Inject fields annotated with @JkInject\n    IT-&gt;&gt;KB:  Inject values from properties\n    IT-&gt;&gt;KB:  Inject values from Command-line\n    IT-&gt;&gt;KB:  Init()\n    IT-&gt;&gt;PO:  Register KBean post-init methods\n    RB-&gt;&gt;PO:  Post-initialize all initialized KBeans</code></pre>"},{"location":"reference/kbeans/#post-initialisation","title":"Post initialisation.","text":"<p>One all the KBean has been initialized, bean already initialized or extra one can be invoked from the KBean methods.</p> <pre><code>sequenceDiagram\n    participant AK as A KBean\n    participant RB as Run Base\n    participant IT as Instantiater\n    participant KB as KBean\n    participant PR as Pre-initializer\n    participant PO as Post-initializer\n    participant RK as Registered KBeans\n\n    AK-&gt;&gt;RB:  Load a KBean \n    RB-&gt;&gt;RK:  Find if KBean is already instantiated\n    RB--&gt;&gt;AK:  Returns Kbean instance if found\n    RB-&gt;&gt;IT:  Initialise KBean\n    IT-&gt;&gt;RK:  Register KBean\n    RB-&gt;&gt;PO:  Register KBean post-init methods\n    RB-&gt;&gt;PO:  Post-initialize all initialized KBeans\n    RB--&gt;&gt;AK: done</code></pre> <pre><code>classDiagram\n    class JkRunBase {\n        +Path baseDir\n        +KBean initKBean\n        +KBean defaultKBean\n        +JkProperties properties\n        +List dependencies\n\n        +KBean load()\n        +KBean find()\n        +List getKBeans()\n\n    }\n\n    class KBean {\n        +JkRunbase runbase\n    }\n\n    JkRunBase \"1\" &lt;--&gt; \"0..*\" KBean\n    JkRunBase --&gt; \"0..*\" BaseDir: Imported Base Dirs (multi-modules)\n\n    note for JkRunBase \"There is only one JkRunBase per base folder.&lt;br/&gt;The base folder is the project root.&lt;br/&gt;In multi-module projects, usually one JkRunBase exists per module.\"\n    note for BaseDir \"This class doesn\u2019t exist. It represents the base directory &lt;br/&gt;of another runbase in a multi-module project.\"\n</code></pre>"},{"location":"reference/kbeans/#multi-project-setup","title":"Multi-Project setup","text":"<p>In multi-project scenarios, it is common for a KBean in one project to access a KBean instance from another project. This can be achieved in a statically typed manner:</p> <ol> <li>In the master KBean, declare a field of type <code>KBean</code> (e.g., <code>KBean importedBuild;</code>). This field does not need to be public.</li> <li>Annotate the field, by specifying the relative path of the imported project (e.g., <code>@JkInjectRunbase(\"../anotherModule\")</code>).</li> <li>Run the command <code>jeka intellij: iml</code> or <code>jeka eclipse: files</code> to refresh project metadata.</li> <li>Change the declared field type from <code>KBean</code> to the concrete type of the imported KBean.</li> <li>The master KBean can now access the imported KBean in a type-safe manner.</li> <li>For an example, see this implementation.</li> </ol> <p>Tip</p> <p>Ensure that the imported KBean uses <code>KBean#getBaseDir</code> for handling file paths. This practice ensures safe execution from any working directory.</p> <p>For multi-module projects, use <code>JkInject</code> to access sub-module KBeans.</p> <p><pre><code>import dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\nimport dev.jeka.core.tool.JkInject;\n\nimport java.util.List;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\npublic class MasterBuild extends KBean {\n\n    @JkInject(\"./foo\")\n    ProjectKBean fooProject;\n\n    @JkInject(\"./bar\")\n    ProjectKBean barProject;\n\n    @JkDoc(\"For all sub-modules: clean, compile, test, create jar files, and publish them.\")\n    public void buildAll() {\n        List.of(fooProject, barProject).forEach(projectKbean -&gt; {\n            projectKbean.clean();\n            projectKbean.pack();\n            MavenKBean mavenKBean = projectKbean.load(MavenKBean.class);\n            mavenKBean.publishLocal();\n        });\n    }\n}\n</code></pre> In this example, JeKa initializes KBeans from the sub-modules ./foo and ./bar, then injects them into the <code>MasterBuild</code> KBean.</p> <p>We can create or load a KBean on the fly using the <code>KBean#load</code> method. This means we only need to declare one KBean per sub-module.</p> <p>Another option is to inject <code>JkRunbase</code> and make all calls through it:</p> <pre><code>import dev.jeka.core.tool.JkRunbase;\nimport dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\nimport dev.jeka.core.tool.JkInject;\n\nimport java.util.List;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\npublic class MasterBuild extends KBean {\n\n    @JkInject(\"./foo\")\n    JkRunbase foo;\n\n    @JkInject(\"./bar\")\n    JkRunbase bar;\n\n    @JkDoc(\"For all sun-modules: clean, compile, test, create jar files, and publish them.\")\n    public void buildAll() {\n        List.of(foo, bar).forEach(runbase -&gt; {\n            ProjectKBean projectKBean = runbase.load(ProjectKBean.class);\n            projectKbean.clean();\n            projectKbean.pack();\n            MavenKBean mavenKBean = runbase.load(MavenKBean.class);\n            mavenKBean.publishLocal();\n        });\n    }\n}\n</code></pre> <p>For larger sub-project structures, use <code>KBean#getImportedKBeans()</code> to list all sub-modules, either recursively or not.</p> <pre><code>@JkDoc(\"For all sub-modules: compile, test, create jar files, and publish them.\")\npublic void buildAll() {\n    this.getImportedKBeans().get(ProjectKBean.class, true).forEach(ProjectKBean::pack);\n    this.getImportedKBeans().get(MavenKBean.class, true).forEach(MavenKBean::publish);\n}\n</code></pre>"},{"location":"reference/multi-modules/","title":"Working with Multi-Module Projects in JeKa","text":"<p>Multi-module support in JeKa allows developers to manage and build complex projects with multiple modules in a clean   and effective manner.</p>"},{"location":"reference/multi-modules/#structure-of-a-multi-module-project","title":"Structure of a Multi-Module Project","text":"<p>A multi-module project in JeKa consists of:</p> <ul> <li>A parent directory that contains the configuration and dependencies shared across all modules, and declares the location of child modules.</li> <li>Multiple child modules, which are independent or interdependent within the project.</li> </ul> <p>Example: <pre><code>project-root\n\u251c\u2500\u2500 jeka.properties\n\u251c\u2500\u2500 jeka-src (optional)\n\u251c\u2500\u2500 module-1\n\u2502   \u251c\u2500\u2500 jeka.properties\n\u2502   \u251c\u2500\u2500 jeka.project.deps\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u2514\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 module-2\n\u2502   \u251c\u2500\u2500 jeka.properties\n\u2502   \u251c\u2500\u2500 jeka.project.deps\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u2514\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 module-Xxxx ...\n</code></pre> To be recognized as a parent project, the jeka.properties file must specify the <code>_jeka.child-bases</code> property  indicating where the child modules are located.</p> <p>You can set it as <code>_jeka.child-bases=module1, module2, ...</code> or <code>_jeka.child-bases=*</code>. If you use <code>*</code>, Jeka will scan child directories and include any with a Jeka structure.</p> <p>It's also possible to use hierarchical structures such as: <pre><code>parent-project\n\u251c\u2500\u2500 jeka.properties\n\u251c\u2500\u2500 jeka-src (optional)\n\u251c\u2500\u2500 core\n\u2502   \u251c\u2500\u2500 jeka.properties\n\u2502   \u251c\u2500\u2500 jeka.project.deps\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u2514\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500\u2500 plugins\n     \u251c\u2500\u2500 jeka.properties\n     \u251c\u2500\u2500 jeka.project.deps\n     \u251c\u2500\u2500 plugin-common\n     \u2502   \u251c\u2500\u2500 jeka.project.deps\n     \u2502   \u251c\u2500\u2500 jeka.properties\n     \u2502   \u2514\u2500\u2500 src\n     \u251c\u2500\u2500 plugin-1\n     \u2502   \u251c\u2500\u2500 jeka.project.deps\n     \u2502   \u251c\u2500\u2500 jeka.properties\n     \u2502   \u2514\u2500\u2500 src\n     \u251c\u2500\u2500 plugin-2\n     \u2502   \u251c\u2500\u2500 jeka.project.deps\n     \u2502   \u251c\u2500\u2500 jeka.properties\n     \u2502   \u2514\u2500\u2500 src\n     \u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"reference/multi-modules/#example-of-jekaproperties-for-parent-project","title":"Example of jeka.properties for parent project","text":"<p><pre><code># Define Java version for all modules\njeka.java.version=21\n\n# specify location of child modules\n_jeka.child-base=core, plugins/*\n\n# Parent module does not contain a JVM project\n_@project=off\n\n# Common settings for child modules containing a JVM project\n@project.compilation.compilerOptions=-g\n@project.pack.javadocOptions=-notimestamp\n\n# Enable Git-based versioning for Maven\n@maven.pub.gitVersioning.enable=true\n\n# Parent module Maven-specific settings\n_@maven.pub.moduleId=dev.jeka:bom\n_@maven.pub.parentBom=true\n</code></pre> Child modules inherit from the properties defined in their parent directory's jeka.properties files recursively.</p> <p>To make a property non-transmitted to the children, we need to prefix it with <code>_</code>.</p>"},{"location":"reference/multi-modules/#typical-jekaproperties-for-child-module","title":"Typical jeka.properties for child module","text":"<pre><code># The child module defines a JVM project with specific settings\n@project=on\n@project.pack.mainClass=dev.jeka.core.tool.Main\n+@project.compilation.compilerOptions=-Xlint:none\n\n# Specific Maven publish settings\n@maven.pub.moduleId=dev.jeka:jeka-core\n</code></pre> <p>The child modules inherit properties from the parent, except for properties prefixed with <code>_</code></p> <p>When a property declaration is prefixed with <code>+</code>, the specified value is happened to the parent value instead of overriding it. In this example, <code>-g -Xlint:none</code> will be passed to the compiler options.</p>"},{"location":"reference/multi-modules/#running-jeka-commands","title":"Running JeKa commands","text":"<p>When executing a JeKa command on a parent project, the specified actions are delegated to all child modules, then to the parent one.</p> <p>If a module is not concerned with a given KBean, it should declare it in its <code>jeka.properties</code> file, as <code>@project=off</code>.</p> <p>If we run the following command on the above example:</p> <p><pre><code>jeka project: pack maven: publish\n</code></pre> This will first run <code>project: test pack</code> method on all child modules. Parent module won't execute these actions  because it does not explicitly declare the project KBean (<code>@project=on</code> is absent).</p> <p>Then the <code>maven: publish</code> action is invoked on all child modules and the parent module as it declares it explicitly (<code>@maven=on</code>).</p> <p>If a child module is not concerned by a specific KBean, it should be explicitly disabled (e.g. <code>@maven=off</code>). This could be the case if plugin-common should not be published as a Maven artifact.</p>"},{"location":"reference/multi-modules/#running-child-module","title":"Running child module","text":"<p>If you need to run some Jeka command for a child module, you have 3 options:</p> <ol> <li> <p>Use <code>-cb</code> (alias <code>--child-base</code>) option    <pre><code>jeka -cb=plugins/plugin-1 project: test pack\n</code></pre></p> </li> <li> <p>Execute actions from child module directory:    <pre><code>cd plugins/plugin-1\njeka project: test pack\n</code></pre>    This approach works well, but code in <code>jeka-src</code> declared in parent module won't be taken into account.</p> </li> </ol>"},{"location":"reference/multi-modules/#managing-jekaprojectdeps","title":"Managing jeka.project.deps","text":"<p>In a multi-module project, we often need to define centrally the versions of the libraries we want to use across all the modules.</p> <p>Example: plugins/jeka.project.deps<pre><code>[version]\ncom.google.guava:guava:33.4.7-jre\norg.projectlombok:lombok:1.18.38\norg.junit:junit-bom:5.12.2@pom  # Use versions defined in this BOM\n</code></pre></p> <p>Child module <code>jeka.project.deps</code> files inherit the <code>version</code> section from the parent directory's <code>jeka.project.deps</code>, if present.</p> <p>Module interdependency can be defined using the module's relative path.</p> plugins/plugin-1/jeka.project.deps<pre><code>[compile]\n../plugin-common \ncom.google.guava:guava\n\n[compile-only]\norg.projectlombok:lombok\n\n[test]\norg.junit.jupiter:junit-jupiter\norg.junit.platform:junit-platform-launcher\n</code></pre>"},{"location":"reference/multi-modules/#programmatic-approach","title":"Programmatic Approach","text":"<p>By combining multi-module and programmatic approach, you can:</p> <ul> <li>Use <code>jeka-src</code> code from one module in another module that depends on it.</li> <li>Import a run base (or any <code>KBean</code>) from one module into another.</li> </ul>"},{"location":"reference/multi-modules/#using-jeka-src-code-from-another-module","title":"Using <code>jeka-src</code> Code from Another Module","text":"<p>You may need to share build code between multiple modules. This is easy to do using the <code>@JkDep</code> annotation, which lets you import code from another module.</p> <p>Example:</p> <p>Let\u2019s say there\u2019s a central set of dependencies in the <code>jeka-src</code> folder of the <code>plugin-common</code> module. These dependencies can be defined as constants in a class, like a <code>PluginCommon</code> class, so they can be reused in other modules.</p> plugins/plugin-common/jeka-src/PluginCommon.java<pre><code>class PluginCommon {\n\n    static final JkDependencySet LOG_LIBS = JkDependencySet.of()\n            .and(\"ch.qos.logback:logback:0.5\")\n            .and(\"org.slf4j:slf4j-api:2.0.17\");\n\n}\n</code></pre> <p>We can reuse the code in <code>jeka-src</code> of plugin-1 module, for instance, as below:</p> <p>plugins/plugin-1/jeka-src/Plugin1Custom.java<pre><code>import dev.jeka.core.api.depmanagement.JkDependencySet;\nimport dev.jeka.core.tool.JkDep;\n\n@JkDep(\"../plugin-common\")\nclass Plugin1Custom extends KBean {\n\n    private JkDependencySet logLibs = PluginCommon.LOG_LIBS;\n\n}\n</code></pre> The specified path is relative to the module declaring the annotation.</p>"},{"location":"reference/multi-modules/#import-kbeans-from-other-modules","title":"Import KBeans from other modules","text":"<p>You may use some KBeans from other modules. For example you want to run kbean action for a given list of child modules.</p> <pre><code>class Custom extends KBean {\n\n    @JkInject(\"../../core\")\n    private ProjectKBean coreProjectKBean;\n\n    @JkInject(\"../pluginCommon\")\n    private ProjectKBean pluginCommonProjectKBean;\n\n    public void doXxxx() {\n        coreProjectKBean.pack();\n        pluginCommonProjectKBean.pack();\n        Path coreClasses = coreProjectKBean.project.compilation.layout.resolveClassDir();\n    }\n\n    @JkPostInit\n    private void postInit(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n        project.flatFacade\n                .setMainArtifactJarType(JkProjectPackaging.JarType.FAT)\n                .dependencies.compile\n                .add(coreProjectKBean.project.toDependency());\n    }\n\n}\n</code></pre>"},{"location":"reference/multi-modules/#import-runbases-from-other-modules","title":"Import runbases from other modules","text":"<p>In similar way, we can import runbases from other modules.</p> <pre><code>class Custom extends KBean {\n\n    @JkInject(\"core\")\n    private JkRunbase coreRunbase;\n\n    public void delegate() {\n        JkProject coreProject = coreRunbase.load(ProjectKBean.class).project;\n        coreProject.test.run();\n        coreProject.pack.run();\n    }\n\n}\n</code></pre>"},{"location":"reference/multi-modules/#discover-child-modules","title":"Discover child modules","text":"<p>From a parent module we can programmatically access the child modules.</p> <pre><code>class MasterBuild extends KBean {\n\n    public boolean runIT = true;\n\n    public void doAll() {\n        this.getRunbase().getChildRunbases().stream()\n                .map(runbase -&gt; runbase.find(ProjectKBean.class))\n                .filter(Optional::isPresent)\n                .map(Optional::get)\n                .forEach(this::make);\n        this.getRunbase().getChildRunbases().stream()\n                .map(runbase -&gt; runbase.load(MavenKBean.class))\n                .forEach(MavenKBean::publish);\n    }\n\n    private void make(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n        project.test.selection.addExcludePatternsIf(!runIT, JkTestSelection.IT_PATTERN);\n        project.test.run();\n        project.pack.run();\n    }\n}\n</code></pre>"},{"location":"reference/properties/","title":"Properties","text":"<p>Properties are pairs of String key-values that are used across JeKa. They typically carry URLs, local paths, tool versions, or credentials. </p> <p>Properties can be defined at different levels, in order of precedence:</p> <ul> <li>System properties: Properties can be defined using system properties as <code>-DpropertyName=value</code>. System properties can   be injected from the JeKa command line.</li> <li>OS environment variables: Properties can also be defined as OS environment variables.</li> <li>Project: Defined in [Project Root]/jeka.properties. Typically used to store tool versions (e.g. <code>jeka.kotlin.version=1.5.21</code>).</li> <li>Global: Defined in the [User Home]/.jeka/global.properties file. Typically used to define URLs, local paths, and credentials.</li> </ul> <p>Properties inherit from project properties defined in project parent folders (if they exist). </p> <p>Here, project2 will inherit properties defined in project1/jeka.properties: <pre><code>project1\n   + jeka.properties\n   + project2   (sub-project)\n      + jeka.properties\n</code></pre></p> <p>Info</p> <p>Properties support interpolation via <code>${}</code> tokens. </p> <p>For example, if we define the following properties: <code>foo=fooValue</code> and <code>bar=bar ${foo}</code> then <code>JkProperties.get(\"bar\")</code> will return 'bar fooValue'.</p>"},{"location":"reference/properties/#standard-properties","title":"Standard properties","text":"<ul> <li><code>jeka.java.version</code>:  Target JVM version for compiled files.</li> <li><code>jeka.jdk.X=</code> location of the JDK version X (e.g., jeka.jdk.11=/my/java/jdk11). It is used to compile projects when    the project JVM target version differs from the Jeka running version.</li> <li><code>jeka.kotlin.version</code>: Version of Kotlin used to compile both def and Kotlin project sources.</li> <li><code>jeka.inject.classpath</code>: Additional dependencies that will be added to the JeKa classpath.     We can specify many dependencies separated by <code>&lt;space&gt;</code>.    It can be either Maven coordinates or file paths. If a file path is relative, it is resolved     upon project base dir (could be distinct from working dir).    Example: <code>jeka.inject.classpath=dev.jeka:springboot-plugin  com.google.guava:guava:31.1-jre ../other-project/jeka/output/other-project.jar</code></li> <li><code>jeka.kbean.default</code>: The KBean to use when omitting mentioning KBean prefix (or using <code>kb#</code> prefix) in command or field assignment.    Example: declaring <code>jeka.kbean.default=myBean</code>, makes the following expressions equivalent: <code>myBean#run</code>, <code>#run</code>, and <code>kb#run</code>.</li> </ul>"},{"location":"reference/properties/#command-shorthands","title":"Command shorthands","text":"<ul> <li><code>jeka.cmd.xxx=</code> define an alias that can be substituted for its value in the command line using the <code>:</code> symbol.     Example: <code>jeka.cmd.myBuild=${jeka.cmd.build} sonarqube#run jacoco#</code> allows you to simply execute <code>jeka :myBuild</code>.</li> <li><code>jeka.cmd._append=</code> will append the argument to every Jeka execution command.    Example: <code>jeka.cmd._append=@dev.jeka:springboot-plugin</code> will add springboot plugin to Jeka classpath for each execution.    This property can be split when the argument line becomes too long. In fact, every property starting with <code>jeka.cmd._append</code> will     be taken in account to assemble the extra command line arguments. For example, we can define <code>jeka.cmd._append.0=</code>, <code>jeka.cmd._append.1=</code>, and so on.</li> </ul> <p>Note</p> <p>Command shorthands are a really powerful mechanism for getting rid of build classes. Many projects can be built using properties only!</p>"},{"location":"reference/properties/#repositories","title":"Repositories","text":"<p>The repositories used to download and publish artifacts can be defined using properties. The download repositories are set using the <code>jeka.repos.download</code> property, while the publish repository is defined using <code>jeka.repos.publish</code>.</p> <p>Use the JkRepoFromProperties class to get the repositories defined by properties.</p> <p>Note</p> <p>By default, when no repository is configured, artifacts are downloaded from the Maven Central repo.</p> <p>Using a single repo <pre><code>jeka.repos.download=https://my.company/repo\n</code></pre></p> <p>Using multiple repos <pre><code>jeka.repos.download=https://my.company/repo1, file://path/to/a/local/repo \n</code></pre></p> <p>Using a single repo with credentials <pre><code>jeka.repos.download=https://my.company/repo\njeka.repos.download.username=myUsername\njeka.repos.download.password=myPassword\n</code></pre></p> <p>Specifying HTTP headers to include in each request towards the repo <pre><code>jeka.repos.download.headers.my-header-name=myHeaderValue\njeka.repos.download.headers.another-header-name=anotherHeaderValue\n</code></pre></p> <p>Same for the publish repo <pre><code>jeka.repos.publish=https://my.company/myrepo\njeka.repos.publish.username=myUsername\njeka.repos.publish.password=myPassword\njeka.repos.download.headers.Authorization=Bearer:: XHrU8hHKJHJ454==67g\n</code></pre></p> <p>For convenience, we can define multiple repositories and reference them using aliases: <pre><code>jeka.repos.myRepo1=https://my.company/repo\njeka.repos.myRepo1.username=myUsername\njeka.repos.myRepo1.password=myPassword\n\njeka.repos.myRepo2=https://my.company/repo2\njeka.repos.myRepo2.username=myUsername2\njeka.repos.myRepo2.password=myPassword2\n\njeka.repos.download=myRepo1, myRepo2\njeka.repos.publish=myRepo2\n</code></pre></p> <p>Aliases are predefined for Maven Central and JeKa GitHub Repos: <pre><code>jeka.repos.download=https://my.company/repo1, mavenCentral, jekaGithub\njeka.repos.jekaGithub.username=myGithubAccountName\njeka.repos.jekaGithub.password=myGithubPersonalAccessToken\n</code></pre></p>"},{"location":"reference/properties/#kbean-field-value-injection","title":"KBean field value injection","text":"<p>If a property is named as <code>xxx#yyyyy</code> then Jeka will try to inject its value  in public field <code>yyyyy</code> of KBean <code>xxx</code>. </p> <p>Examples: <pre><code>@springboot.springbootVersion=2.4.7\n@project.test.skip=true\n</code></pre></p> <p>Note</p> <p>There is a slight difference between using <code>-D@project.test.skip=true</code> and  <code>@project.test.skip=true</code> in the command line. For the former, the field is injected via system properties, this means that for multi-modules projects, the value will be injected on every Jeka module. For the latter, the value will be injected only on the root module.</p>"},{"location":"reference/properties/#multivalue-fields","title":"Multivalue fields","text":"<p>Multi-value fields allow using map-like structures in KBean objects.</p> <p>Example:</p> <p><pre><code>class MyBean extends KBean {\n\n      public final JkMultiValue&lt;String&gt; phones = JkMultiValue.of(String.class);\n      public final JkMultiValue&lt;Address&gt; addresses = JkMultiValue.of(Address.class);\n\n      public static class Address {\n\n          @JkDoc(\"The street name and number\")\n          public String street;\n          public int zip;\n      }\n }\n</code></pre> <code>JkMultiValue</code> is a map-like structure that allows access to values according to a given <code>key</code>.</p> <pre><code>Address mainAddress = myBean.addresses.get(\"main\");\nString gsmNum = myBean.phones.get(\"gsm\");\n</code></pre> <p>These values can be set using jeka.properties files or command-line arguments as: <pre><code>@myBean.phones.gsm=0978765432\n@myBean.phones.home=0111334455\n\n@myBean.addresses.main.street=Georges street 32\n@myBean.addresses.main.zip=50600\n</code></pre></p> <p>Note</p> <p><code>JkMultiValue</code> objects support nesting, allowing you to create hierarchical data structures with multiple levels of key-value pairs.</p>"},{"location":"tutorials/basics/","title":"JeKa Basics","text":"<p>Prerequisite: JeKa must be installed.</p> <p>JeKa is not just a build tool; it's a powerful companion for Java development that allows you to run Java code as scripts with zero ceremony. This tutorial will walk you through the core concepts of JeKa by creating and running simple scripts.</p>"},{"location":"tutorials/basics/#create-a-basic-script","title":"Create a basic script","text":"<p>To create a basic JeKa structure, execute: <pre><code>jeka base: scaffold\n</code></pre></p> <p>This generates a <code>jeka-src/Script.java</code> file, which is an example of Java code invokable from the command line.</p> <pre><code>class Script extends KBean {\n\n    @JkDoc(\"Person to whom the greeting is intended\")\n    public String name = \"World\";\n\n    @JkDoc(\"Print greeting on console\")\n    public void hello() {\n        String greetings = \"Hello \" + name + \" !\";\n        System.out.println(greetings);\n    }\n\n}\n</code></pre> <p>IntelliJ IDEA Users</p> <p>The JeKa IntelliJ Plugin is the recommended way to work with JeKa.  If you prefer using the CLI for synchronization, execute <code>jeka intellij: sync</code> to update IDE metadata. If IntelliJ does not reflect changes, you can re-initialize the project with <code>jeka intellij: initProject</code>.</p> <p>By default, <code>jeka-src</code> is declared as a test source folder. You can isolate it in its own module by executing <code>jeka intellij: sync splitModule=true</code>.</p> <p>Execute <code>jeka hello</code>. A Hello World message is printed on the console. <pre><code>Hello World !\n</code></pre></p> <p>Execute <code>jeka hello name=JeKa</code>. A Hello JeKa message is printed on the console. <pre><code>Hello JeKa !\n</code></pre></p> <p>Add a similar <code>hi</code> method in <code>Script.java</code>: <pre><code>public void hi() {\n    System.out.println(\"Hi \" + name + \" !\");\n}\n</code></pre> ... and execute <code>jeka hi</code>. You will notice that your change has been automatically taken into account  without any extra action on your part.</p> <p>You can add as many public void no-args methods or public fields in your scripts. The accepted public field types are mentioned here.</p> <p>Tip</p> <p>You can document your script by annotating the class, public fields, or public methods with the <code>@JkDoc</code> annotation. This will be visible when executing: <code>jeka script: --doc</code>. Note that only the part before the first line break of the doc content will be displayed as a summary.</p>"},{"location":"tutorials/basics/#define-jdk-version","title":"Define JDK version","text":"<p>JeKa can automatically manage the JDK used to run your scripts. This ensures reproducibility across different machines.</p> <p>Edit <code>jeka.properties</code>: <pre><code>jeka.java.version=23\n</code></pre> Executing <code>jeka hello</code> will now trigger a download of JDK 23 (if not already present) before executing the script. JeKa caches downloaded JDKs in <code>~/.jeka/cache/jdks</code>.</p> <p>You can also specify a distribution: <pre><code>jeka.java.version=21\njeka.java.distrib=corretto\n</code></pre></p> <p>If you prefer to use a local JDK, specify its path: <pre><code>jeka.java.version=22\njeka.sdk.22=/my/jdks/22-corretto\n</code></pre></p> <p>Note</p> <p>Properties can also be set via system properties or environment variables (e.g., <code>JEKA_SDK_22</code> or <code>-Djeka.sdk.22=...</code>).</p>"},{"location":"tutorials/basics/#define-jeka-version","title":"Define JeKa version","text":"<p>To ensure your script always runs with a compatible JeKa version, regardless of the version installed on the host, add this to <code>jeka.properties</code>: <pre><code>jeka.version=0.11.24\n</code></pre></p>"},{"location":"tutorials/basics/#add-dependencies","title":"Add dependencies","text":"<p>Your scripts can easily depend on external libraries from Maven repositories or local files.</p> <p>Annotate the <code>Script</code> class: <pre><code>import dev.jeka.core.tool.JkDep;\n\n@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")\nclass Script extends KBean {\n}\n</code></pre> ... and execute <code>jeka intellij: sync</code> to update your IDE classpath.</p> <p>Now use the library in a new method: <pre><code>public void ascii() throws Exception {\n    System.out.println(FigletFont.convertOneLine(\"Hello\"));\n}\n</code></pre> ... and execute <code>jeka ascii</code>. This library has no transitive dependency, but it could have. Try to import any library with transitive dependencies and execute <code>jeka --inspect</code>.  This displays runtime information about the JeKa run, including the resulting classpath.</p> <p>Note</p> <p>JeKa also supports JBang-style dependency declarations: <code>//DEPS com.github.lalyos:jfiglet:0.0.9</code></p>"},{"location":"tutorials/basics/#use-bom-dependencies","title":"Use BOM dependencies","text":"<p>For complex dependencies, you can import a Maven BOM:</p> <pre><code>@JkDep(\"com.google.cloud:libraries-bom:5.0.0@pom\")\n@JkDep(\"com.google.cloud:google-cloud-storage\")\n@JkDep(\"com.google.cloud:google-cloud-bigquery\")\n</code></pre>"},{"location":"tutorials/basics/#file-system-dependencies","title":"File system dependencies","text":"<p>You can add local JARs or class folders: - Place JARs in the <code>jeka-boot</code> directory (create it if not present). - Or use <code>@JkDep</code> with relative paths: <pre><code>@JkDep(\"../other-project/mylib.jar\")\n@JkDep(\"../other-project/my-classes\")\n</code></pre></p>"},{"location":"tutorials/basics/#dependencies-in-properties","title":"Dependencies in properties","text":"<p>Alternatively, define dependencies in <code>jeka.properties</code>: <pre><code>jeka.classpath=\\\n  com.google.cloud:libraries-bom:5.0.0@pom \\\n  com.google.cloud:google-cloud-storage \\\n  com.google.cloud:google-cloud-bigquery\n</code></pre></p>"},{"location":"tutorials/basics/#compilation-directives","title":"Compilation directives","text":"<p>JeKa compiles <code>jeka-src</code> classes on-the-fly. You can pass options to the Java compiler using <code>@JkCompileOption</code>:</p> <pre><code>@JkCompileOption(\"-Xlint:-options\")\n</code></pre>"},{"location":"tutorials/basics/#multi-file-scripts-kbeans","title":"Multi-file scripts &amp; KBeans","text":"<p><code>jeka-src</code> can host multiple scripts and utility classes. Understanding how JeKa finds and executes these classes (called KBeans) is essential.</p> <ol> <li> <p>Create a new class <code>Build.java</code> in <code>jeka-src</code>: <pre><code>import dev.jeka.core.tool.KBean;\n\npublic class Build extends KBean {\n    public void foo() {\n        System.out.println(\"Method 'foo()' is running.\");\n    }\n}\n</code></pre> Execute <code>jeka foo</code>. It works because <code>Build</code> is now the primary KBean found.</p> </li> <li> <p>Now try <code>jeka hello</code>. You will get an error:    <code>ERROR: Unmatched argument at index 0: 'hello'</code></p> </li> </ol> <p>This is because JeKa uses a discovery strategy to find a default KBean. When multiple KBeans exist, you may need to be explicit.</p> <ol> <li> <p>To execute a method from a specific KBean, use the format <code>jeka [kbean]: [method]</code>:    <code>jeka script: hello</code></p> </li> <li> <p>You can define the default KBean in <code>jeka.properties</code>:    <pre><code>jeka.kbean.default=script\n</code></pre>    Now <code>jeka hello</code> will work again.</p> </li> </ol> <p>KBean Naming</p> <p>A KBean named <code>MyCoolKBean</code> can be referenced as: - <code>org.example.MyCoolKBean</code> (Fully qualified) - <code>MyCoolKBean</code> (Short name) - <code>myCoolKBean</code> (Uncapitalized) - <code>myCool</code> (Omitting the 'KBean' suffix)</p>"},{"location":"tutorials/basics/#configure-default-values","title":"Configure default values","text":"<p>You can override KBean fields directly from <code>jeka.properties</code>: <pre><code>@script.name=Everybody\n</code></pre> Now <code>jeka hello</code> prints <code>Hello Everybody !</code>.</p>"},{"location":"tutorials/basics/#kbean-interaction","title":"KBean Interaction","text":"<p>KBeans can interact with each other. This is how JeKa plugins and complex build scripts are structured.</p> <ol> <li>Ensure <code>jeka.kbean.default=script</code> is set and remove the <code>@script.name</code> override.</li> <li>In <code>Build.java</code>, override the <code>init()</code> method: <pre><code>public class Build extends KBean {\n    @Override\n    protected void init() {\n        Script script = load(Script.class); // Get the singleton instance\n        script.name = \"Mates\";           \n    }\n}\n</code></pre></li> <li>Execute <code>jeka script: hello build:</code>.     <code>Hello Mates !</code></li> </ol> <p>The <code>build:</code> part in the command line forces the initialization of the <code>build</code> KBean, which then configures the <code>script</code> KBean.</p> <p>To make <code>build</code> always initialize, add this to <code>jeka.properties</code>:    <pre><code>@build=on\n</code></pre></p>"},{"location":"tutorials/basics/#classpath-kbeans","title":"Classpath KBeans","text":"<p>Local KBeans are in <code>jeka-src</code>. Classpath KBeans are pre-compiled and available in the JeKa classpath (like plugins).</p> <p>Run <code>jeka --doc</code> to see all available KBeans, including standard ones like <code>admin</code>. Example: <code>jeka admin: openHomeDir</code></p>"},{"location":"tutorials/basics/#adding-plugins","title":"Adding Plugins","text":"<p>Adding a plugin is as simple as adding its JAR to the classpath via <code>jeka.classpath</code> or <code>@JkDep</code>.</p> <pre><code>jeka.classpath=\\\n  dev.jeka:springboot-plugin  \\\n  dev.jeka:sonarqube-plugin \\\n  dev.jeka:openapi-plugin:0.11.0.1\n</code></pre> <p>Note</p> <p>If you omit the version for <code>dev.jeka</code> group dependencies, JeKa uses its own version.</p>"},{"location":"tutorials/basics/#example-running-nodejs-via-jeka","title":"Example: Running Node.js via JeKa","text":"<p>You can even add KBeans dynamically from the CLI: <pre><code>jeka -cp=dev.jeka:nodejs-plugin nodeJs: version=\"20.12.2\" cmdLine=\"npx cowsay Hello JeKa\" exec\n</code></pre></p> <p>This should display: <pre><code>       ___________\n      &lt; Hello JeKa &gt;\n       -----------\n              \\   ^__^\n               \\  (oo)\\_______\n                  (__)\\       )\\/\\\n                      ||----w |\n                      ||     ||\n</code></pre></p> <p>Next steps: Learn how to Build a Base Application or a Full Project.</p>"},{"location":"tutorials/build-base/","title":"Build Base-Mode","text":"<p>The <code>base</code> mode is a \"best of both worlds\" approach, sitting between single-file scripts like JBang and full-featured Maven or Gradle projects. </p> <p>In this tutorial, we'll use the <code>base</code> KBean to build a Java application or library with minimal configuration.</p> <p>Visit the demo-base-application repository to see a concrete example.</p> <p>Prerequisite: JeKa must be installed.</p> <p>Tip</p> <p>Run <code>jeka base: --doc</code> to see all available options and commands for the base KBean.</p>"},{"location":"tutorials/build-base/#scaffold-a-new-code-base","title":"Scaffold a New Code Base","text":"<p>To create a base structure ready for coding, run:</p> <pre><code>jeka base: scaffold.kind=APP base: scaffold\n</code></pre> <p>This generates the following project structure: <pre><code>. \n\u251c\u2500\u2500 jeka-src             &lt;- Source root directory\n\u2502   \u251c\u2500\u2500 _dev             &lt;- Optional package containing all non-prod (build and test)\n\u2502   \u2502   \u251c\u2500\u2500 test\n\u2502   \u2502   \u2514\u2500\u2500 Custom.java  \n\u2502   \u2514\u2500\u2500 app              &lt;- Suggested base package for production code/resources\n\u2502       \u2514\u2500\u2500 App.java     \n\u251c\u2500\u2500 jeka-output          &lt;- Generated dir where artifacts such as jars, classes, reports or doc are generated\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration (Java and JeKa version, KBean configurations, ...)\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands\n</code></pre></p> <p>All your Java code is supposed to be in the <code>jeka-src</code> folder.</p> <p><code>_dev</code> is a special package for source code and dependencies used only for development (e.g., tests, builds). If you're new to Java, you can ignore or delete it.</p> <p>The scaffolded example includes an <code>App</code> class in the <code>app</code> package. You can add or modify classes in any package you like.</p>"},{"location":"tutorials/build-base/#sync-with-intellij","title":"Sync with IntelliJ","text":"<p>The easiest way to work with JeKa in IntelliJ is by using the JeKa IntelliJ Plugin. It provides syntax highlighting, auto-completion, and direct execution of JeKa commands.</p> <p>To synchronize your project with IntelliJ and generate the necessary project files, run:</p> <pre><code>jeka intellij: sync\n</code></pre> <p>If changes don't appear or you need to re-initialize the project structure, use:</p> <pre><code>jeka intellij: initProject\n</code></pre>"},{"location":"tutorials/build-base/#add-dependencies","title":"Add Dependencies","text":"<p>In <code>base</code> mode, dependencies are declared directly in your Java source files using the <code>@JkDep</code> annotation. This keeps your build configuration close to the code that uses it.</p> <p>The scaffolded <code>App.java</code> includes examples:</p> jeka-src/app/App.java<pre><code>@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")\n@JkDep(\"com.fasterxml.jackson.core:jackson-core:2.18.2\")\npublic class App {\n    // ...\n}\n</code></pre> <p>For more details on how to specify dependencies, see the Dependency Management guide.</p>"},{"location":"tutorials/build-base/#file-based-dependencies","title":"File-based Dependencies","text":"<p>You can also include JAR files as dependencies by placing them in the <code>jeka-boot</code> directory. They will be automatically added to the production classpath:</p> <pre><code>\u251c\u2500\u2500 jeka-boot      &lt;- JARs included in the production classpath.\n</code></pre>"},{"location":"tutorials/build-base/#non-production-dependencies","title":"Non-production Dependencies","text":"<p>Dependencies used only for development (like testing or custom build logic) should be declared in classes under the <code>_dev</code> package. This ensures they are not included in the final application bundle.</p> jeka-src/_dev/Custom.java<pre><code>@JkDep(\"org.junit.jupiter:junit-jupiter:5.11.4\")\n@JkDep(\"org.mockito:mockito-junit-jupiter:5.15.2\")\nclass Custom extends KBean {\n    // ...\n}\n</code></pre> <p>Note</p> <p>Remember to run <code>jeka intellij: sync</code> after modifying dependencies to update your IDE's classpath.</p>"},{"location":"tutorials/build-base/#run-your-application","title":"Run your Application","text":"<p>You can execute your application directly from the command line:</p> <pre><code>jeka --program arg0 args1 ... # or `jeka -p` for short\n</code></pre> <p>Use the <code>--clean</code> (<code>-c</code>) option to force a clean compilation before running:</p> <pre><code>jeka -c -p\n</code></pre>"},{"location":"tutorials/build-base/#run-from-remote-git","title":"Run from Remote Git","text":"<p>JeKa can run applications directly from a remote Git repository without having to clone it manually:</p> <pre><code>jeka --remote https://github.com/jeka-dev/demo-base-application.git -p\n</code></pre>"},{"location":"tutorials/build-base/#native-compilation","title":"Native Compilation","text":"<p>JeKa makes it easy to compile your application into a standalone native executable using GraalVM.</p> <p>To compile to native, execute:</p> <pre><code>jeka native: compile\n</code></pre> <p>Once compiled, running <code>jeka --program ...</code> will automatically use the native executable instead of the JVM.</p> <p>Note</p> <p>If your application requires resources (like icons or config files) at runtime, you might need to set: jeka.properties<pre><code>@native.includeAllResources=true\n</code></pre></p> <p>To always trigger a native build when running the application, add this to your <code>jeka.properties</code>:</p> jeka.properties<pre><code>jeka.program.build=native: compile\n</code></pre>"},{"location":"tutorials/build-base/#dockerization","title":"Dockerization","text":"<p>You can package your application into a Docker image with a single command:</p> <pre><code>jeka docker: build\n</code></pre> <p>This builds the image and registers it with your local Docker daemon. The console output will provide the exact command to run your new image.</p> <p>To create an even smaller, faster-starting image using your native executable, run:</p> <pre><code>jeka docker: buildNative\n</code></pre>"},{"location":"tutorials/build-base/#pre-defined-build-commands","title":"Pre-defined Build Commands","text":"<p>The <code>base</code> KBean provides several built-in commands for common tasks:</p> Available Base Commands<pre><code>jeka base: test       # Run all tests in the _dev package\njeka base: pack       # Run tests and create application JARs\njeka base: runJar     # Execute the generated JAR\njeka base: info       # Display project configuration and dependencies\njeka base: depTree    # Display the full dependency tree \n</code></pre> <p>For more advanced commands, see the Project Build tutorial.</p>"},{"location":"tutorials/build-base/#create-a-library","title":"Create a Library","text":"<p>While <code>base</code> mode is often used for applications, it can also be used to build and publish libraries. To do so, you must define a <code>moduleId</code> and a <code>version</code>.</p> <p>Add these to your <code>jeka.properties</code>:</p> jeka.properties<pre><code>@base.moduleId=org.example:my-lib\n@base.version=1.0.0-SNAPSHOT\n</code></pre> <p>You can then publish your library to a Maven repository:</p> <pre><code>jeka maven: publish\n</code></pre>"},{"location":"tutorials/build-projects/","title":"Building Java Projects","text":"<p>In this tutorial, we'll use the <code>project</code> KBean to build a Java application or library.  This KBean provides build methods and a project layout similar to those of Maven and Gradle.</p> <p>If you prefer a lighter structure without the standard <code>src/main/java</code> layout, see the Build Base tutorial.</p> <p>Prerequisite: JeKa must be installed.</p> <p>Tip</p> <p>Run <code>jeka project: --doc</code> to see all available options and methods.</p>"},{"location":"tutorials/build-projects/#scaffold-a-new-project","title":"Scaffold a New Project","text":"<p>Run the following command to create a standard project structure, ready for coding:</p> <pre><code>jeka project: scaffold\n</code></pre> <p>You'll get the following project structure: <pre><code>.\n\u251c\u2500\u2500 src                  \n\u2502   \u251c\u2500\u2500 main             &lt;- Java code and resources\n\u2502   \u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2514\u2500\u2500 resources    \n\u2502   \u2514\u2500\u2500 test             &lt;- Unit tests and test resources\n\u2502       \u251c\u2500\u2500 java\n\u2502       \u2514\u2500\u2500 resources \n\u251c\u2500\u2500 jeka-src             &lt;- Java (or Kotlin) code for build customization\n\u2502   \u2514\u2500\u2500 Custom.java      \n\u251c\u2500\u2500 jeka-output          &lt;- Generated artifacts (JARs, classes, reports)\n\u251c\u2500\u2500 jeka.project.deps    &lt;- Project dependencies\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration and properties\n\u251c\u2500\u2500 jeka.ps              &lt;- PowerShell wrapper (optional)\n\u251c\u2500\u2500 jeka                 &lt;- Bash wrapper (optional)\n\u2514\u2500\u2500 README.md            &lt;- Project overview and build instructions\n</code></pre></p> <p>The <code>jeka</code> and <code>jeka.ps</code> scripts allow building the project on machines where JeKa is not globally installed. You can delete <code>jeka-src/Custom.java</code> if you don't need programmatic customization.</p>"},{"location":"tutorials/build-projects/#simple-layout","title":"Simple Layout","text":"<p>If you prefer a flatter structure, you can enable the <code>SIMPLE</code> style:</p> jeka.properties<pre><code>@project.layout.style=SIMPLE\n@project.layout.mixSourcesAndResources=true\n</code></pre> <p>This results in a simpler layout: <pre><code>.\n\u251c\u2500\u2500 src       &lt;- Java code and resources mixed\n\u251c\u2500\u2500 test      &lt;- Test code and resources mixed\n</code></pre></p>"},{"location":"tutorials/build-projects/#local-jar-dependencies","title":"Local JAR Dependencies","text":"<p>You can also include local JARs by placing them in the <code>libs</code> directory:</p> <pre><code>.\n\u251c\u2500\u2500 libs                  \n\u2502   \u251c\u2500\u2500 compile          &lt;- JARs for compile, runtime, and test classpaths\n\u2502   \u251c\u2500\u2500 compile-only     &lt;- JARs for compile and test classpaths only\n\u2502   \u251c\u2500\u2500 runtime          &lt;- JARs for runtime and test classpaths\n\u2502   \u2514\u2500\u2500 test             &lt;- JARs for test classpath only\n</code></pre>"},{"location":"tutorials/build-projects/#ide-integration","title":"IDE Integration","text":"<p>To synchronize your project with IntelliJ IDEA, run:</p> <pre><code>jeka intellij: iml --force\n</code></pre> <p>If the project is not yet recognized as a JeKa project, use: <pre><code>jeka intellij: initProject\n</code></pre></p>"},{"location":"tutorials/build-projects/#dependency-management","title":"Dependency Management","text":"<p>Dependencies are declared in <code>jeka.project.deps</code>. JeKa supports Maven coordinates and BOMs.</p> jeka.project.deps<pre><code>[version]    # Define versions or import BOMs\norg.junit:junit-bom:5.12.2@pom\n\n[compile]    # Main dependencies\ncom.google.guava:guava:33.4.0-jre\ncom.google.code.gson:gson:2.13.1\n\n[compile-only] # Only needed for compilation (e.g., Lombok)\norg.projectlombok:lombok:1.18.32\n\n[runtime]    # Only needed at runtime\norg.postgresql:postgresql:42.7.4\n\n[test]       # Only needed for testing\norg.junit.jupiter:junit-jupiter\norg.junit.platform:junit-platform-launcher\n</code></pre> Section Description <code>[version]</code> Versions and BOM imports (using <code>@pom</code>). <code>[compile]</code> Included in compile, runtime, and test classpaths. <code>[compile-only]</code> Included in compile and test, but NOT runtime. <code>[runtime]</code> Included in runtime and test, but NOT compile. <code>[test]</code> Included in the test classpath only. <p>You can also reference local files: <code>libs/my-local-lib.jar</code>.</p>"},{"location":"tutorials/build-projects/#java-version","title":"Java Version","text":"<p>By default, the project uses the same Java version as the JeKa runtime (see <code>jeka.java.version</code> in <code>~/.jeka/jeka.properties</code>).  To target a specific version, set:</p> jeka.properties<pre><code>@project.javaVersion=17\n</code></pre>"},{"location":"tutorials/build-projects/#jar-packaging","title":"JAR Packaging","text":"<p>JeKa creates a Regular JAR by default. You can change this to a Fat JAR (includes all dependencies) or a Shaded JAR (fat JAR with relocated packages).</p> jeka.properties<pre><code>@project.pack.jarType=FAT\n</code></pre>"},{"location":"tutorials/build-projects/#multiple-artifacts","title":"Multiple Artifacts","text":"<p>For libraries, you might want to produce both a regular JAR and an extra shaded JAR:</p> jeka.properties<pre><code># Produce an extra shaded jar suffixed with '-all'\n@project.pack.shadeJarClassifier=all\n\n# Ensure the extra artifact is published to Maven\n@maven.publication.extraArtifacts=all\n</code></pre>"},{"location":"tutorials/build-projects/#versioning-and-git","title":"Versioning and Git","text":"<p>You can hardcode the version in <code>jeka.properties</code>:</p> jeka.properties<pre><code>@project.moduleId=com.example:my-app\n@project.version=1.0.0-SNAPSHOT\n</code></pre>"},{"location":"tutorials/build-projects/#automatic-git-versioning","title":"Automatic Git Versioning","text":"<p>The recommended approach is to let JeKa infer the version from Git:</p> jeka.properties<pre><code>@project.gitVersioning.enable=true\n</code></pre> <ul> <li>If you are on a Tag: The version is the tag name (e.g., <code>1.2.3</code>).</li> <li>If you are on a Branch: The version is <code>[branch]-SNAPSHOT</code> (e.g., <code>master-SNAPSHOT</code>).</li> <li>Metadata: The JAR manifest will automatically include Git commit ID, branch, and \"dirty\" state.</li> </ul>"},{"location":"tutorials/build-projects/#essential-build-commands","title":"Essential Build Commands","text":""},{"location":"tutorials/build-projects/#common-flags","title":"Common Flags","text":"<ul> <li><code>-c</code> or <code>--clean</code>: Deletes <code>jeka-output</code> before running.</li> <li><code>-v</code> or <code>--verbose</code>: Shows detailed logs.</li> <li><code>-p</code> or <code>--program</code>: Runs the generated application.</li> </ul>"},{"location":"tutorials/build-projects/#project-lifecycle","title":"Project Lifecycle","text":"Command Description <code>jeka project: compile</code> Compiles source code. <code>jeka project: test</code> Runs unit tests (e.g., JUnit). <code>jeka project: pack</code> Packages the project into a JAR. <code>jeka project: build</code> Full cycle: clean, compile, test, pack, quality checks. <code>jeka project: runJar</code> Executes the generated JAR. <code>jeka project: info</code> Displays project setup and properties. <code>jeka project: depTree</code> Prints the full dependency tree."},{"location":"tutorials/build-projects/#extensions-optional","title":"Extensions (Optional)","text":"<ul> <li><code>jeka native: compile</code>: Compiles to a GraalVM native executable.</li> <li><code>jeka docker: build</code>: Creates a Docker image.</li> <li><code>jeka maven: publishLocal</code>: Publishes to the local Maven repository.</li> </ul>"},{"location":"tutorials/build-projects/#quality-coverage-plugins","title":"Quality &amp; Coverage (Plugins)","text":"<p>JeKa plugins like JaCoCo and SonarQube can be added via <code>jeka.properties</code>.</p> jeka.properties<pre><code># Inject plugins into the build classpath\njeka.inject.classpath=dev.jeka:sonarqube-plugin dev.jeka:jacoco-plugin\n\n# Activate JaCoCo for the project\n@jacoco=\n\n# Configure SonarQube\nsonar.host.url=http://localhost:9000\n\n# Create a shortcut command for full build + quality check\njeka.cmd.quality=project: pack sonarqube: run\n</code></pre> <p>Run with: <code>jeka quality</code>.</p>"},{"location":"tutorials/build-projects/#programmatic-customization","title":"Programmatic Customization","text":"<p>For complex logic, use <code>jeka-src/Custom.java</code>. This allows you to hook into the build lifecycle using <code>@JkPostInit</code>.</p> jeka-src/Custom.java<pre><code>import dev.jeka.core.tool.KBean;\nimport dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.JkPostInit;\n\npublic class Custom extends KBean {\n\n    @JkPostInit(required = true)\n    private void postInit(ProjectKBean projectKBean) {\n        // Customize compiler options\n        projectKBean.project.compilation.addJavaCompilerOptions(\"-Xlint:unchecked\");\n\n        // Add a custom resource to the JAR\n        projectKBean.project.pack.runtimeDependencies.add(\"org.postgresql:postgresql:42.7.4\");\n    }\n\n    @JkDoc(\"Custom action that can be called from CLI\")\n    public void myAction() {\n        System.out.println(\"Hello from Custom KBean!\");\n    }\n}\n</code></pre> <p>Run your custom action with: <code>jeka myAction</code>.</p> <p>Note</p> <p>The <code>JkProject</code> object is the heart of the <code>project</code> KBean. It provides a rich API for every aspect of the build. See API Reference.</p>"},{"location":"tutorials/source-runnable-apps/","title":"Source-Runnable Applications","text":"<p>With JeKa, you don't need to create and publish binaries to publish your application. JeKa acts as an application source manager, enabling you to run applications directly from their Git (remote) repository or to install them on a user's desktop by building them at installation time.</p>"},{"location":"tutorials/source-runnable-apps/#running-applications-from-remote-repositories","title":"Running Applications from Remote Repositories","text":""},{"location":"tutorials/source-runnable-apps/#basic-usage","title":"Basic Usage","text":"<p>To run an application directly from its Git repository, use the following command:</p> <p><pre><code>jeka --remote GIT_URL --program PROGRAM_ARGUMENTS\n</code></pre> or <pre><code>jeka -r GIT_URL -p PROGRAM_ARGUMENTS\n</code></pre></p> <p>Example: <pre><code>jeka -r https://github.com/djeang/demo-dir-checksum -p -a SHA256\n</code></pre> You can pass <code>-Dxxxxx=yyyy</code> as a program argument to set system properties.</p>"},{"location":"tutorials/source-runnable-apps/#browsing-the-catalog","title":"Browsing the Catalog","text":"<p>You can see a list of available applications by executing: <pre><code>jeka app: catalog\n</code></pre></p>"},{"location":"tutorials/source-runnable-apps/#running-specific-versions","title":"Running Specific Versions","text":"<p>You can run a specific version of an application by appending a tag name to the URL:</p> <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay#0.0.6 -p \"Hello JeKa!\"\n</code></pre>"},{"location":"tutorials/source-runnable-apps/#trust-and-security","title":"Trust and Security","text":"<p>When you run a remote application for the first time, JeKa will prompt you to confirm whether you trust the source URL. This prevents the accidental execution of malicious code.</p> <p>If you accept, JeKa clones the repository, builds the application, and runs it. On subsequent runs, it executes directly using the cached binaries.</p> <p>You can manage trusted URLs in your <code>[JEKA_HOME]/global.properties</code> file: <pre><code>jeka.app.url.trusted=github.com/djeang/\n</code></pre> In this example, any repository starting with <code>github.com/djeang/</code> will be trusted automatically.</p>"},{"location":"tutorials/source-runnable-apps/#performance-and-shortcuts","title":"Performance and Shortcuts","text":""},{"location":"tutorials/source-runnable-apps/#native-executables","title":"Native Executables","text":"<p>To improve startup performance, you can compile a remote application to a native executable. Once compiled, all subsequent runs will use the native version.</p> <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay#0.0.9 native: compile\n</code></pre>"},{"location":"tutorials/source-runnable-apps/#command-shorthands","title":"Command Shorthands","text":"<p>Typing and remembering full repository URLs can be tedious. You can simplify this by using shortcuts in your <code>~/.jeka/global.properties</code> file:</p> <p><pre><code>jeka.cmd.cowsay=-r https://github.com/jeka-dev/demo-cowsay#0.0.9 -p\n</code></pre> Now you can invoke the application using the <code>::</code> prefix: <pre><code>jeka ::cowsay \"Hello World!\"\n</code></pre></p>"},{"location":"tutorials/source-runnable-apps/#desktop-installation","title":"Desktop Installation","text":"<p>JeKa lets you install applications for direct execution from your terminal, without needing to call <code>jeka</code> explicitly.</p> <p><pre><code>jeka app: install repo=https://github.com/djeang/kill8\n</code></pre> Or use a shorthand for known repositories: <pre><code>jeka app: install repo=kill8@djeang\n</code></pre></p> <p>For faster startup, you can install the native version: <pre><code>jeka app: install repo=kill8@djeang runtime=NATIVE\n</code></pre></p> <p>Once installed, you can simply call the application by name: <pre><code>kill8 8081\n</code></pre></p> <p>For more details on application management, see the App KBean Reference.</p>"},{"location":"tutorials/source-runnable-apps/#creating-source-runnable-applications","title":"Creating Source-Runnable Applications","text":""},{"location":"tutorials/source-runnable-apps/#jeka-projects","title":"JeKa Projects","text":"<p>Applications built with JeKa are \"source-runnable\" by default. </p> <p>When running a remote application, JeKa clones the repository and builds it using <code>jeka base: pack</code> (or <code>jeka project: pack</code> if a project is detected). It then looks in the <code>jeka-output</code> directory to run the resulting JAR or native binary.</p>"},{"location":"tutorials/source-runnable-apps/#maven-projects","title":"Maven Projects","text":"<p>Maven projects can be installed from source using the <code>maven:</code> KBean.  Add a <code>jeka.properties</code> file to your Maven project root to configure the build delegation:</p> <pre><code>jeka.java.version=21\n\n# Delegate build to Maven wrapper\njeka.program.build=maven: wrapPackage\n\n# For native builds (requires GraalVM)\njeka.java.distrib=graalvm\njeka.program.build.native=maven: wrapPackage args=\"-Pnative\"\n</code></pre> <p>For multi-module projects, specify which module contains the application: <pre><code>jeka.program.build=maven: wrapPackage appModule=app\n</code></pre></p> <p>Requirements: 1. Maven wrapper: Include <code>mvnw</code> / <code>mvnw.cmd</code> in your repository (to make the build fully portable) 2. Fat JAR plugin: Configure <code>maven-shade-plugin</code> to create executable JARs. 3. Native support (optional): Add <code>native-maven-plugin</code> in a Maven profile.</p> <p>See a complete example at demo-maven-multimodule.</p>"},{"location":"tutorials/source-runnable-apps/#custom-build-commands","title":"Custom Build Commands","text":"<p>For other build tools or custom requirements, you can create a custom KBean to handle the build process:</p> <pre><code>jeka.program.build=custom: build\njeka.program.build.native=custom: buildNative\n</code></pre> <pre><code>class Custom extends KBean {\n\n    @JkDoc(\"Build application and copy result to jeka-output\")\n    public void build() {\n        gradle(\"clean assemble\");\n        copyToJekaOutput();\n    }\n\n    @JkDoc(\"Build native application\")\n    public void buildNative() {\n        gradle(\"clean nativeCompile\");\n        copyToJekaOutput();\n    }\n\n    private void gradle(String gradleArguments) {\n        JkLog.info(\"Executing gradlew \" + gradleArguments);\n        String distrib = getRunbase().getProperties().get(\"jeka.java.distrib\", \"graalvm\");\n        String javaVersion = getRunbase().getProperties().get(\"jeka.java.version\", \"21\");\n        String distribFolder = distrib + \"-\" + javaVersion;\n        Path graalvmHome = JkLocator.getCacheDir().resolve(\"jdks\").resolve(distribFolder);\n        String newPath = graalvmHome.resolve(\"bin\") + File.pathSeparator + System.getenv(\"PATH\");\n        JkProcess.ofWinOrUx(\"gradlew.bat\", \"./gradlew\")\n                .addParamsAsCmdLine(gradleArguments)\n                .setWorkingDir(getBaseDir())\n                .setEnv(\"JAVA_HOME\", graalvmHome.toString())\n                .setEnv(\"GRAALVM_HOME\", graalvmHome.toString())\n                .setEnv(\"PATH\", newPath)\n                .setInheritIO(true)\n                .exec();\n    }\n\n    private void copyToJekaOutput() {\n        JkPathTree.of(getBaseDir().resolve(\"build/libs\"))\n                .andMatching(\"*.jar\")\n                .copyTo(getBaseDir().resolve(JkConstants.OUTPUT_PATH),\n                        StandardCopyOption.REPLACE_EXISTING);\n        Path nativeDir = getBaseDir().resolve(\"build/native/nativeCompile\");\n        if (Files.exists(nativeDir)) {\n            JkPathTree.of(nativeDir).copyTo(getBaseDir().resolve(JkConstants.OUTPUT_PATH),\n                        StandardCopyOption.REPLACE_EXISTING);\n        }\n    }\n}\n</code></pre>"},{"location":"tutorials/source-runnable-apps/#docker-integration","title":"Docker Integration","text":"<p>JeKa can create Docker images directly from remote application sources.</p> <p>Create a JVM image: <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay docker: build\n</code></pre></p> <p>Create a native image: <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay docker: buildNative\n</code></pre></p>"},{"location":"tutorials/source-runnable-apps/#see-also","title":"See Also","text":"<ul> <li>App KBean Reference - Detailed documentation on application installation and management.</li> <li>Native KBean Reference - Learn more about native compilation features.</li> <li>Docker KBean Reference - Learn more about Docker integration.</li> </ul>"}]}