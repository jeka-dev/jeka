{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to JeKa","text":"<p>JeKa is a modern build tool for Java, designed to simplify and streamline your development experience. It reshapes Java application building for a generation of developers seeking lightweight, accessible, yet powerful solutions.</p>"},{"location":"#next-gen-java-build-tool","title":"Next-Gen Java Build Tool","text":"<p>Java is evolving to become more developer-friendly and cloud-native ready. Developers no longer want to deal with heavy tools,  verbose XML configurations, or external DSLs. JeKa aligns with this vision by offering:</p> <ul> <li>Simplicity at its Core: Configure with properties or pure Java\u2014no XML, no YAML, no DSL.</li> <li>No Setup Hassle: Start building regular or cloud-native applications immediately, with minimal configuration and requirements.</li> <li>Gradual Complexity: Handle advanced scenarios using intuitive mechanisms without unnecessary complexity.</li> <li>DevOps Bridge: Implement complex pipeline logic with robust Java and share it across your teams.</li> <li>Super-lightweight: JeKa consists of a single zero-dependency JAR under 2MB. Install and upgrade in a flash.</li> </ul>"},{"location":"#ready-to-explore","title":"Ready to explore?","text":"<p>The easiest way to get started is by using the IntelliJ Plugin.  You don't need to install JeKa for that.</p> <ol> <li> <p>Start a new project and play with the scaffolded example. You can have a brief look at the tutorial to get an idea of what you can do.</p> </li> <li> <p>You can create projects in the IDE using Project - Java App/Lib or Project - Springboot templates. They scaffold basic projects, providing code and build instructions in <code>README.md</code> files.</p> </li> <li> <p>Explore and experiment with  examples.</p> </li> </ol> <p>Have fun !</p>"},{"location":"cheat-sheet/","title":"Cheat Sheet","text":""},{"location":"cheat-sheet/#useful-commands","title":"Useful commands","text":"Command Description <code>--doc</code> Displays available methods, options and KBeans <code>intellij: sync -f</code> Generates iml file for Intellij. <code>intellij: initProject</code> Initializes Intellij Project <code>eclipse: sync</code> Same purpose as above to generate metadata files for Eclipse. <code>project: scaffold</code> Generates files to create a basic Jeka project from scratch. <code>project: pack</code> Build jars and others optional artifacts from a project <code>base: scaffold</code> Creates files a base workspace without project."},{"location":"cheat-sheet/#standard-properties","title":"Standard Properties","text":"Property Name Default Value Description jeka.version The Jeka version to use. It will be fetched from the repository specified in the <code>jeka.distrib.repo</code> property. Use <code>jeka.version=.</code> to force the use of the locally installed version. jeka.distrib.location The exact location (directory) to get the JeKa distribution. If set, both <code>jeka.version</code> and <code>jeka.distrib.repo</code> will be ignored. jeka.java.version The version of the JDK used to run Jeka, and compile code located in jeka-src jeka.java.distrib temurin The distribution of JDK to fetch when <code>jeka.java.version</code> is mentioned. Should be 21 or higher jeka.repos.download local, mavenCentral Comma separated string of repositories to fetch Maven dependencies. More details here jeka.repos.publish Comma separated string of repository to publish Maven artifacts. More details here jeka.program.build project: pack -Djeka.test.skip=true Cmd line to execute to build project when exec files are absents jeka.kbean.default Name or class name of the KBean to use as default (when none is specified) jeka.test.skip Skip tests when building projects or code bases. jeka.platform.os linux, windows or mac Provides the os of the running machine"},{"location":"cheat-sheet/#jdk-selection-rules","title":"JDK Selection Rules","text":"<ol> <li>If <code>JEKA_JDK_HOME</code> is set, use this JDK</li> <li>If <code>jeka.java.version</code> is specified:<ul> <li>Use JDK from <code>jeka.jdk.[version]</code> if available</li> <li>Otherwise fetch JDK from local cache or download it</li> </ul> </li> <li>If no version is specified:<ul> <li>Use JDK from <code>JAVA_HOME</code> if set</li> <li>Otherwise fetch JDK 21 from local cache or download it</li> </ul> </li> </ol>"},{"location":"cheat-sheet/#how-jeka-reads-properties","title":"How JeKa Reads Properties","text":"<p>JeKa reads properties in this order:</p> <ul> <li>Command-line arguments (as <code>-Dmy.prop=xxx</code>).</li> <li>Environment variables (<code>my.prop</code>or <code>MY_PROP</code>).</li> <li>The jeka.properties file in the base dir.</li> <li>The jeka.properties file in parent directories, until it's not found.</li> <li>The global.properties file in [JEKA_USER_HOME].</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>You can find some examples in below to learn more about Jeka:</p>"},{"location":"examples/#zero-configuration-build-and-run","title":"Zero-Configuration Build and Run","text":"<ul> <li>Java Project</li> <li>Java Projectless Codebase</li> </ul>"},{"location":"examples/#run-from-git","title":"Run from Git","text":"<ul> <li>Cow-Say Command-line App</li> <li>Calculator GUI App</li> <li>A collection of developer utilities in a single JavaFX application</li> </ul>"},{"location":"examples/#builds-and-pipelines","title":"Builds and Pipelines","text":"<ul> <li>Publish a Java Lib on Maven Central</li> <li>SpringBoot App</li> <li>SpringBoot App - Java configuration</li> <li>SpringBoot - Agular - Sonarqube - Docker - E2E testing</li> </ul>"},{"location":"examples/#multi-module-projects","title":"Multi-module Projects","text":"<ul> <li>Core and plugin modules in a single project</li> </ul>"},{"location":"examples/#reuse-build-conventions","title":"Reuse Build-Conventions","text":"<ul> <li>SpringBoot - ReactJs - built with only 3 lines of configuration</li> </ul>"},{"location":"examples/#combine-with-maven","title":"Combine with Maven","text":"<ul> <li>Jeka wrapping a Quarkus native app Maven build</li> <li>Jeka wrapping a Spring-Boot native Maven build</li> </ul>"},{"location":"examples/#native-and-docker-images","title":"Native and Docker Images","text":"<ul> <li>SpringBoot Docker Native Images</li> <li>Kotlin SpringBoot ReactJS Docker Native Image</li> </ul>"},{"location":"examples/#kotlin-and-reactjs","title":"Kotlin and ReactJS","text":"<ul> <li>Kotlin SpringBoot ReactJS App</li> </ul>"},{"location":"examples/#others","title":"Others","text":"<ul> <li> <p>Samples are used for testing Jeka</p> </li> <li> <p>Miscellaneous examples are more complex use case demos</p> </li> </ul>"},{"location":"external-resources/","title":"External Resources","text":"<p>You can find some resources in below to learn more about Jeka:</p> <ul> <li>Dev.to serie about \"Jeka: The simplest way to...\"</li> </ul>"},{"location":"faq/","title":"Frequented Asked Questions","text":""},{"location":"faq/#network-security","title":"Network - Security","text":""},{"location":"faq/#my-organization-prevents-access-to-maven-central-what-can-i-do","title":"My organization prevents access to Maven Central. What can I do?","text":"<p>You can configure Maven repositories in a central place by editing the [USER HOME]/.jeka/global.properties file.</p> <pre><code>jeka.repos.download=https://my.company/repo\n\n# You can specify username/password\njeka.repos.download.username=myName\njeka.repos.download.password=myPassw0rd!\n\n# ... or specify Authorization header to avoid password in clear\njeka.repos.download.headers.Authorization=Basic hKXhhtggjREfg4P=\n</code></pre> <p>To fetch JeKa distributions, specify the <code>jeka.distrib.location</code> property, pointing to a folder.  This property is better placed in the jeka.properties file, as it may vary from one project to another.</p>"},{"location":"faq/#my-organization-prevents-downloading-jdks-what-can-i-do","title":"My organization prevents downloading JDKs. What can I do?","text":"<p>You can specify a local location for each JDK version you are using as follows: <pre><code>jeka.jdk.11=/my/path/to/jdk11/home\njeka.jdk.17=/my/path/to/jdk17/home\n...\n</code></pre> This information can be stored in the project's jeka.properties file, in [USER HOME]/.jeka/global.properties, or passed as environment variables.</p>"},{"location":"faq/#im-behind-a-proxy-how-should-i-configure-jeka","title":"I'm behind a proxy, how should I configure Jeka ?","text":"<p>JeKa just leverages the standard Java mechanism to handle proxy. For example, You can :</p> <ul> <li>Set the <code>JAVA_TOOL_OPTIONS</code> environment variable as <code>-Dhttps.proxyHost=my.proxy.host -Dhttps.proxyPort=8888</code></li> <li>Or specify proxy properties to the jeka command line, as :  <code>-Dhttps.proxyHost=my.proxy.host -Dhttps.proxyPort=8888</code></li> </ul> <p>See here for more details on arguments.</p>"},{"location":"faq/#legacy-tools","title":"Legacy Tools","text":""},{"location":"faq/#how-can-i-use-mavengradle-in-conjunction-with-jeka","title":"How can I use Maven/Gradle in conjunction with JeKa?","text":"<p>Nothing prevents using JeKa alongside Maven or Gradle in the same project, except that in an IDE, synchronization may interfere between the two systems.</p> <p>To avoid this, the <code>jeka-src</code> folder should exist in its own IntelliJ module. JeKa provides a simple way to achieve this.</p> <p>From an existing Maven/Gradle project, execute: <pre><code>jeka base: scaffold\n</code></pre> Edit the <code>jeka.properties</code> file, and add: <pre><code>@intellij.splitModule=true\n</code></pre> Generate the iml file, by synchronize within the IDE, or by running: <pre><code>jeka intellij: sync\n</code></pre> In intellij, go to <code>project settings</code> -&gt; <code>import module</code> -&gt; chose [project dir]/.idea/xxxx-jeka.iml</p>"},{"location":"faq/#how-can-i-migrate-my-project-from-maven","title":"How can I migrate my project from Maven?","text":"<p>JeKa helps translate all dependencies declared in a Maven project into the equivalent Java code.</p> <p>Assuming Maven is already installed and there is a pom.xml file at the root of the project,  execute <code>jeka maven: migrateDeps</code> to display Java code/configuration to  copy-paste in a build class or dependencies.txt file.</p>"},{"location":"faq/#performancecaching","title":"Performance\u2014Caching","text":""},{"location":"faq/#how-to-cache-downloaded-dependencies-in-_devgithub-actions","title":"How to cache downloaded dependencies in _dev.Github-actions?","text":"<p>JeKa caches downloaded dependencies (JDKs, JeKa distros, Maven artifacts, NodeJs exe,...) in a single  directory at [USER HOME]/.jeka/cache.</p> <p>When running as _dev.Github Action this directory is empty at the start of the build. We need to save/restore it in  order to make it persist from one build to another.</p> <p>For this, we can use cache action as follow: <pre><code>    - name: Restore JeKa cache\n      uses: actions/cache/restore@v4\n      with:\n        path: ~/.jeka/cache\n        key: ${{ runner.os }}\n\n    - name: Run some JeKa commands\n      run: \"./jeka project: pack ...\"\n\n    - name: Save JeKa cache\n      uses: actions/cache/save@v4\n      with:\n        path: ~/.jeka/cache\n        key: ${{ runner.os }}\n</code></pre></p>"},{"location":"faq/#errors","title":"Errors","text":""},{"location":"faq/#junit-platform","title":"Junit platform","text":"<p>I see this error message when I launch tests. What can I do? <pre><code>OutputDirectoryProvider not available; probably due to unaligned versions of the junit-platform-engine and junit-platform-launcher jars on the classpath/module path.\n</code></pre> You can explicitly declare the JUNIT component versions in dependencies.txt as: <pre><code>[test]\norg.junit.platform:junit-platform-launcher:1.12.2\norg.junit.jupiter:junit-jupiter:5.12.2\n</code></pre></p>"},{"location":"faq/#misc","title":"Misc","text":""},{"location":"faq/#how-do-i-configure-projects-from-code","title":"How do I configure projects from code?","text":"<p>If you want to configure a project programmatically, either within the project itself or to create a plugin, you should access the <code>JkProject</code> instance directly instead of using the <code>ProjectKBean</code>.</p> <p>The <code>ProjectKBean</code> initializes the project and configures it with its own settings in its <code>init</code> method. After that, it should not be modified. If you change the <code>ProjectKBean</code> instance in your code, the underlying <code>JkProject</code> instance will already have been configured by the <code>ProjectKBean</code>, meaning your changes will have no effect.</p> <pre><code>public class Build extends KBean {\n\n    JkProject project = load(ProjectKBean.class).project;\n\n    void init() {\n        project.testing.testProcessor.engineBehavior.setProgressDisplayer(STEP);\n        ...\n    }\n}\n</code></pre>"},{"location":"faq/#how-can-i-use-eclipse-compiler-in-jeka","title":"How can I use Eclipse compiler in Jeka?","text":"<p>Jeka can use any JSR199 Java compiler to compile your Java code. Just set the compiler instance you need as :</p> <pre><code>import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler;\n\n@JkDep(\"org.eclipse.jdt.core.compiler:ecj:4.6.1\")\npublic class Build extends KBean {\n\n    JkProject project = load(ProjectKBean.class).project;\n    ...\n    project.compilerToolChain.setCompileTool(new EclipseCompiler());\n\n    // You may pass additional options to the compiler\n    project.compilation.addJavaCompilerOptions(...);\n}\n</code></pre>"},{"location":"faq/#how-can-i-sync-eclipseintellij-without-using-projectkbean","title":"How can I sync Eclipse/IntelliJ without using <code>ProjectKBean</code>?","text":"<p><code>ProjectKBean</code> and <code>BaseKBean</code> provide IDE synchronization out-of-the-box, but you may prefer not to use them.</p> <p>If you use a different structure to build your project, simply let your <code>KBean</code> implement <code>JkJavaIdeSupport</code> and implement the required method to provide the information necessary to generate IDE metadata files.</p> <p>For synchronization, just execute <code>jeka intellij:iml</code> as usual.</p>"},{"location":"installation/","title":"CLI Installation","text":""},{"location":"installation/#windows","title":"Windows","text":"<pre><code>iex \"&amp; { $(iwr -useb https://jeka.dev/install.ps1) } install check\"\n</code></pre>"},{"location":"installation/#sdkman","title":"SDKMAN!","text":"<pre><code>sdk install jeka\n</code></pre>"},{"location":"installation/#macos-and-linux","title":"MacOS and Linux","text":"<pre><code>curl -sL https://jeka.dev/install.sh | $(echo $0) -s - install check\n</code></pre> <p>Note</p> <p>JeKa requires bash, curl, and unzip, usually available on macOS and Linux. On Ubuntu, install tools with:  <pre><code>apt-get update &amp;&amp; apt-get install -y curl unzip git gcc zlib1g-dev\n</code></pre></p>"},{"location":"installation/#manual-installation","title":"Manual installation","text":"<p>The manual installation is straightforward and may help when script installation fails.</p> <ul> <li>Download latest JeKa distrib from maven central   and download file named jeka-core-xxx-distrib.zip.</li> <li>Unzip the content of the zip file and copy the content of the 'bin' in [USER HOME]/.jeka/bin dir. </li> <li>Add [USER HOME]/.jeka/bin and [USER HOME]/.jeka/apps to your <code>PATH</code> environment variable.</li> </ul>"},{"location":"installation/#post-install","title":"Post Install","text":"<p>Installation via scripts may include a sanity check that triggers a JDK download (cause of the 'check' argument passed to the install script)</p> <p>Once installed, you will rarely need to upgrade, as JeKa will execute the JeKa version specified in the application to run. However, you'll be able to upgrade your base install by executing: <pre><code>jeka-update\n</code></pre></p> <p>Open a new terminal session and execute the following command to access JeKa help: <pre><code>jeka --help\n</code></pre></p>"},{"location":"installation/#docker-image-zero-install","title":"Docker Image - Zero Install","text":"<p>JeKa can be executed using the Docker image jekadev/jeka.</p> <p>For this, execute : </p> <ul> <li>Linux/Macos        : <code>docker run -v $HOME/.jeka/cache4c:/cache -v .:/workdir jekadev/jeka [JEKA ARGUMENTS]</code></li> <li>Windows Powershell : <code>docker run -v ${HOME}\\.jeka\\cache4c:/cache -v ${PWD}:/workdir jekadev/jeka [JEKA ARGUMENTS]</code></li> <li>Windows cmd        : <code>docker run -v %USERPROFILE%\\.jeka\\cache4c:/cache -v %cd%:/workdir jekadev/jeka [JEKA ARGUMENTS]</code></li> </ul> <p>Notes</p> <p><code>-v $HOME/.jeka/cache4c:/cache</code> </p> <p>Tells jeka to use a specific cache when running with container, as JDK or other tools  cached by Jeka may differ from the ones used by the host system.</p> <p><code>-v .:/workdir jeka --version</code> </p> <p>Lets Jeka operate in the current directory of the host machine</p> <p><code>[JEKA ARGUMENTS]</code> </p> <p>Stands for regular jeka arguments you would pass to jeka command line as `project: pack' or '--help'.</p>"},{"location":"migration-guide/","title":"Migration Guide","text":"<p>This page helps to migrate from JeKa 0.10 to Jeka 0.11</p>"},{"location":"migration-guide/#command-line-and-wrapper","title":"Command line and wrapper","text":"<p>Command line has been unified : <code>jekaw</code> has been replaced by <code>jeka</code> only.</p> <p>The thing is that the wrapper is now entirely included in the shell scripts.</p> <p>The <code>jeka.version</code> is now located in jeka.properties file along other properties.</p>"},{"location":"migration-guide/#project-structure","title":"Project Structure","text":"<p>jeka dir nested level has been suppressed in favor of a flat structure.</p> <p>Also the entire wrapper is contained inside shell scripts so we don't need the jeka/wrapper dir anymore.</p> <ul> <li>jeka/def dir -&gt; jeka-src</li> <li>jeka/output -&gt; jeka-output</li> <li>jeka/.work -&gt; .jeka-work</li> <li>jeka/local.properties -&gt; jeka.properties</li> <li>jekaw.bat -&gt; jeka.ps1</li> <li>jekaw -&gt; jeka</li> <li>jeka/project-dependencies.txt -&gt; dependencies.txt</li> <li>jeka/project-libs dir -&gt; libs</li> </ul>"},{"location":"migration-guide/#major-api-change","title":"Major API Change","text":"<ul> <li>KBean classes now are suffixed with <code>KBean</code> instead of 'JkBean' (e.g. <code>ProjectKBean</code>)</li> <li><code>JkBean.getBean()</code>-&gt; <code>KBean.load()</code></li> </ul>"},{"location":"migration-guide/#properties","title":"Properties","text":"<ul> <li><code>jeka.classpath.inject</code>-&gt; <code>jeka.inject.classpath</code></li> <li>KBean reference has changed from <code>myKbean#xxx</code> to <code>@myKbean.xxx</code></li> </ul>"},{"location":"migration-guide/#command-line","title":"Command Line","text":"<ul> <li>KBean reference can be used for many invoke and notation has changed for <code>myKBean#</code> to <code>myKBean:</code></li> </ul> <p>Example: <code>project#pack project#tests.skip=true</code></p> <p>Is now :   <code>project: pack tests.skip=true</code> </p> <ul> <li>Use <code>jeka --help</code> for command line help starting point</li> </ul>"},{"location":"quick-start/","title":"Quick Start","text":""},{"location":"quick-start/#install-jeka","title":"Install JeKa","text":"<ul> <li>Install Jeka CLI. You can also use SDKMAN!: <code>sdk install jeka</code></li> <li>or Install IntelliJ Plugin for JeKa</li> </ul> <p>Note</p> <p>Using the IntelliJ Plugin is the fastest way to get started.  It provides a wizard for creating various types of projects, ranging from simple scripts to full-fledged Spring Boot applications.</p>"},{"location":"quick-start/#follow-the-guide","title":"Follow the Guide","text":"<p>This quick-start guide covers multiple use cases:</p> <ul> <li>Create scripts in Java and execute from command line.</li> <li>Create a Base Application or Library.</li> <li>Create a Java Project</li> <li>Create a workable Spring-Boot Project in seconds</li> </ul> <p>Notes</p> <p>If you are coding in IntelliJ IDEA, after scaffolding or modifying dependencies, execute the following command to synchronize: <pre><code>jeka intellij: sync\n</code></pre></p>"},{"location":"quick-start/#create-scripts","title":"Create Scripts","text":"<p>Create a directory to host the codebase. Navigate into it and execute: <pre><code>jeka base: scaffold\n</code></pre> This generates a structure as: <pre><code>.                        &lt;- Project root directory\n\u251c\u2500\u2500 jeka-src             &lt;- Source dir for Jeka scripts and configuration code\n\u2502   \u2514\u2500\u2500 Script.java     \n\u2514\u2500\u2500 jeka.properties      &lt;- Jeka configuration (Java and jeka version, default parameters...)\n</code></pre> Ths script class looks like: <pre><code>@JkDoc(\"Minimalist script for demo purpose.\")\nclass Script extends KBean {\n\n    @JkDoc(\"Person to whom the greeting is intended\")\n    public String name = \"World\";\n\n    @JkDoc(\"Print greeting on console\")\n    public void hello() {\n        String greetings = \"Hello \" + name + \" !\";\n        System.out.println(greetings);\n    }\n}\n</code></pre></p>"},{"location":"quick-start/#run-methods","title":"Run methods","text":"<p>You can run the method <code>hello()</code> and changing the parameter, by executing: <pre><code>jeka hello name=\"JeKa\"\n</code></pre> This displays the following text on the console: <pre><code>Hello JeKa !\n</code></pre></p>"},{"location":"quick-start/#write-extra-methods","title":"Write Extra Methods","text":"<p>You can add extra methods relying or not on third-party dependencies as: <pre><code>import com.github.lalyos.jfiglet.FigletFont;\nimport com.google.common.base.Strings;\nimport dev.jeka.core.tool.JkDep;\nimport dev.jeka.core.tool.KBean;\n\n@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")\n@JkDep(\"com.google.guava:guava:33.3.1-jre\")\nclass Script extends KBean {\n\n    ...\n\n    public void header() throws Exception {\n        System.out.println(Strings.repeat(\"-\", 80));\n        System.out.println(FigletFont.convertOneLine(\"Hello Ascii Art !\"));\n        System.out.println(Strings.repeat(\"-\", 80));\n    }\n}\n</code></pre> Execute: <pre><code>jeka header\n</code></pre> This will display the following text on the console: <pre><code>--------------------------------------------------------------------------------\n  _   _      _ _            _             _ _      _         _     _ \n | | | | ___| | | ___      / \\   ___  ___(_|_)    / \\   _ __| |_  | |\n | |_| |/ _ \\ | |/ _ \\    / _ \\ / __|/ __| | |   / _ \\ | '__| __| | |\n |  _  |  __/ | | (_) |  / ___ \\\\__ \\ (__| | |  / ___ \\| |  | |_  |_|\n |_| |_|\\___|_|_|\\___/  /_/   \\_\\___/\\___|_|_| /_/   \\_\\_|   \\__| (_)\n\n\n--------------------------------------------------------------------------------\n</code></pre></p> <p>Notes</p> <ul> <li>You can define multiple script methods in <code>Script.java</code>. These methods must be public, non-static, take no arguments, and return <code>void</code>.</li> <li>You can rename <code>Script.java</code> to any name and place it in any package.</li> <li>You can create multiple script classes. To run a specific script, use the class name, e.g., <code>jeka script2: hi</code>.</li> <li>You can also use classes provided by JeKa without explicitly declaring them.</li> </ul>"},{"location":"quick-start/#kbeans","title":"KBeans","text":"<p>Every script should inherit from the <code>KBean</code> class. </p> <p>KBeans can either be provided as source code (located in the jeka-src directory) or as compiled classes available in the classpath.</p> <p>Jeka includes several standard KBeans, which you can list by running: <pre><code>jeka --doc\n</code></pre></p>"},{"location":"quick-start/#change-java-version","title":"Change Java Version","text":"<p>To change version of Java, edit jeka.properties: <pre><code>jeka.java.version=23\n</code></pre> This will automatically download Java 23 (if not already installed) on the next method run.</p>"},{"location":"quick-start/#run-remotely","title":"Run remotely","text":"<p>Run <code>hello</code>from another directory: <pre><code>jeka -r /path/to/scrcipt/root-dir hello\n</code></pre></p> <p>Run <code>hello</code>from remote git repo: <pre><code>jeka -r https://my.githost/my-repo.git hello\n</code></pre></p>"},{"location":"quick-start/#common-optionscommands","title":"Common Options/Commands:","text":"<pre><code>jeka --help          &lt;- Displays help message\n--doc                &lt;- Displays documentation on availbale scripts\n--inspect            &lt;- Displays details about Jeka setup\njeka base: depTree   &lt;- Show dependency tree\n</code></pre>"},{"location":"quick-start/#resources","title":"Resources","text":"<ul> <li>Basics Tutorial</li> <li>Write Scripts in Java Video</li> </ul>"},{"location":"quick-start/#create-a-base-app-or-library","title":"Create a Base App or Library","text":"<p>Jeka provides a base mode, which simplifies the creation of pure Java applications or libraries by avoiding the complexity of a traditional project structure.  </p> <p>Despite its simplicity, this structure supports full build configuration, automated testing, native compilation, Maven publication, and Docker image creation.</p> <p>To create a new code structure, run the following command: <pre><code>jeka base: scaffold scaffold.kind=APP\n</code></pre> This creates a structure like this: <pre><code>. \n\u251c\u2500\u2500 jeka-src             &lt;- Source root directory\n\u2502   \u251c\u2500\u2500 _dev             &lt;- Optional package containing all non-prod (build and test)\n\u2502   \u2502   \u251c\u2500\u2500 test\n\u2502   \u2502   \u2514\u2500\u2500 Build.java  \n\u2502   \u2514\u2500\u2500 app              &lt;- Sugested base package for production code/resources\n\u2502       \u2514\u2500\u2500 App.java     \n\u251c\u2500\u2500 jeka-output          &lt;- Generated dir where artifacts as jars, classes, reports or doc are generated\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration  (Java and jeka version, kben configurations, ...)\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands\n</code></pre></p> <p>Follow the tutorial for more details.</p>"},{"location":"quick-start/#create-a-java-project","title":"Create a Java Project","text":"<p>In this mode, you can create a fully-fledged project similar to Maven or Gradle.</p> <p>To create a new project structure, execute: <pre><code>jeka project: scaffold\n</code></pre> This generates a project structure as: <pre><code>.\n\u251c\u2500\u2500 src                  \n\u2502   \u251c\u2500\u2500 main             &lt;- Java code and reources\n\u2502   \u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2514\u2500\u2500 resources    \n\u2502   \u2514\u2500\u2500 test             &lt;- Java code and reources for tests\n\u2502       \u251c\u2500\u2500 java\n\u2502       \u2514\u2500\u2500 resources \n\u251c\u2500\u2500 jeka-src             &lt;- Optional Java (or Kotlin) code for building the project\n\u2502   \u2514\u2500\u2500 Build.java      \n\u251c\u2500\u2500 jeka-output          &lt;- Generated dir where artifacts as jars, classes, reports or doc are generated\n\u251c\u2500\u2500 dependencies.txt     &lt;- Dependency lists for compile, runtime and testing\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration  (Java and jeka version, kben configurations, ...)\n\u251c\u2500\u2500 jeka.ps              &lt;- Optional Powershell script to boot Jeka on Windows\n\u251c\u2500\u2500 jeka                 &lt;- Optional bash script to boot Jeka on Linuw/MacOS\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands for building the project\n</code></pre></p> <p>Follow the tutorial for more details.</p>"},{"location":"quick-start/#create-a-spring-boot-project","title":"Create a Spring-Boot Project","text":"<p>To create a new project Spring-Boot, execute: <pre><code>jeka -cp=dev.jeka:springboot-plugin project: scaffold springboot:\n</code></pre></p> <p>This generates the following project structure: <pre><code>.\n\u251c\u2500\u2500 src                  \n\u2502   \u251c\u2500\u2500 main             \n\u2502   \u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2502   \u2514\u2500\u2500 app\n\u2502   \u2502   \u2502       \u251c\u2500\u2500 Application.java.     &lt;- Spring-Boot app class\n\u2502   \u2502   \u2502       \u2514\u2500\u2500 Controller.java.      &lt;- REST controller\n\u2502   \u2502   \u2514\u2500\u2500 resources    \n\u2502   \u2514\u2500\u2500 test             \n\u2502       \u251c\u2500\u2500 java\n\u2502       \u2502   \u2514\u2500\u2500 app\n\u2502       \u2502       \u2514\u2500\u2500 ControllerIt.java     &lt;- Integration Test for REST controller \n\u2502       \u2514\u2500\u2500 resources \n\u251c\u2500\u2500 jeka-src             \n\u2502   \u2514\u2500\u2500 Build.java       &lt;- Empty build class -in case of.\n\u251c\u2500\u2500 jeka-output         \n\u251c\u2500\u2500 dependencies.txt     &lt;- Springboot and extra dependencies\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration \n\u251c\u2500\u2500 jeka.ps              \n\u251c\u2500\u2500 jeka                 \n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands for building the project\n</code></pre> This contains a minimal workable project with production and test code. </p>"},{"location":"quick-start/#modify-layout","title":"Modify Layout","text":"<p>You can choose a simpler code layout structure by setting the following properties: jeka.properties<pre><code>@project.layout.style=SIMPLE\n@project.layout.mixSourcesAndResources=true\n</code></pre> You'll end up with the following code layout: <pre><code>.\n\u251c\u2500\u2500 src       &lt;- Contains both Java code and resooources    \n\u251c\u2500\u2500 test      &lt;- Contains both Java code and resooources for testing\n</code></pre></p>"},{"location":"quick-start/#modify-dependencies","title":"Modify Dependencies","text":"<p>The dependencies are generated with the latest Spring-Boot version: dependencies.txt<pre><code>[version]\norg.springframework.boot:spring-boot-dependencies:3.4.1@pom\n\n[compile]\norg.springframework.boot:spring-boot-starter-web\n\n[test]\norg.springframework.boot:spring-boot-starter-test\n</code></pre> You can start from here for modifying, adding code, tests and dependencies.</p>"},{"location":"quick-start/#execute-commands","title":"Execute Commands","text":"<p>These are the most useful commands for developping Spring-Boot applications.</p> Common Commands<pre><code>jeka project: test       &lt;- Compiles and run tests\njeka project: pack       &lt;- Compiles and creates Bootable Jar\njeka project: runJar     &lt;- Run bootable jar\njeka project: build      &lt;- All-in-one to compile, test, pack, run analysis and end-to-end test\njeka project: depTree    &lt;- Displays dependency tree\n\njeka docker: build       &lt;- Creates Docker image containing the Spring-Boot application\njeka docker: buildNative &lt;- Creates Docker image containing the Spring-Boot application compiled to native.\n</code></pre>"},{"location":"quick-start/#customize-docker-file","title":"Customize Docker File","text":"<p>To reduce a Docker native image size, use a distroless base image. The native executable must be statically linked as libc is unavailable in such distributions. Configure it as follows: jeka.properties<pre><code>@native.staticLink=MUSL\n@docker.nativeBaseImage=gcr.io/distroless/static-debian12:nonroot\n</code></pre></p>"},{"location":"quick-start/#what-next","title":"What Next?","text":"<p>Now that you're here, you can explore the following resources to enhance your project. Learn how to include SonarQube analysis, add a ReactJS web client, perform end-to-end testing, or implement a delivery pipeline in Java:</p> <ul> <li>Example using SpringBoot + Angular + Sonarqube + Jacoco + Docker + end-to-end testing</li> <li>Exemple using Kotlin + StringBoot + ReactJS + Sonarqube/Jacoco</li> <li>Video on Jeka + Springboot + Docker + GraalVM</li> <li>Documentation</li> </ul>"},{"location":"under-the-hood/","title":"Under The Hood","text":"<p>Jeka consists of a single zero-dependency JAR file, along with two shell scripts (one Powershell script for Windows and one Bash script for Linux/macOS).</p>"},{"location":"under-the-hood/#inside-the-jeka-jar","title":"Inside the Jeka JAR","text":"<p>The Jeka JAR is structured as follows:</p> <ul> <li> <p><code>dev.jeka.core.tool</code> package:</p> <p>Contains classes for running Java externally, including the <code>dev.jeka.core.tool.Main</code> class and the component model.</p> </li> <li> <p><code>dev.jeka.core.tool.builtin</code> package: </p> <p>Contains KBeans bundled with JeKa, as <code>ProjectKBean</code>, <code>DockerKBean</code> or <code>NativeKBean</code>.</p> </li> <li> <p><code>dev.jeka.core.api</code> package:</p> </li> </ul> <p>Includes libraries for building projects. These classes can be easily used outside Jeka and embedded in your product.    </p> <pre><code>graph TD\n    subgraph dev.jeka.core\n        subgraph tool \n            engine[dev.jeka.core.tool]\n            builtin[dev.jeka.core.tool.builtin]\n        end\n\n        subgraph api\n            project[dev.jeka.core.api.project]\n            java[dev.jeka.core.api.java]\n            system[dev.jeka.core.api.system]\n            dep[dev.jeka.core.api.depmanagement]\n            file[dev.jeka.core.api.file]\n            utils[def.jeka.core.api.utils]\n            misc[...]\n        end\n\n\n    end\n\n    engine --&gt; java\n    engine --&gt; system\n    engine --&gt; dep\n    builtin --&gt; engine\n    builtin --&gt; api\n    java --&gt; utils\n    dep --&gt; utils\n    file --&gt; utils\n    system --&gt; utils</code></pre>"},{"location":"adrs/01-cmdline-kbean-maker/","title":"Title","text":"<p>Command line KBean notation</p>"},{"location":"adrs/01-cmdline-kbean-maker/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/01-cmdline-kbean-maker/#context","title":"Context","text":"<p>We need to differentiate KBean, methods, and properties when parsing command lines. </p> <p>KBean names can be all lowercase, causing confusion with method names.  Using <code>@KBeanName method1 method2 ...</code> might face conflict with @file-arguments  and may require using shift key on some keyboards. </p> <p>However, a colon as <code>KBeanName: method1 method2 ...</code> doesn't require to use <code>shift</code> key, despite being less noticeable.</p>"},{"location":"adrs/01-cmdline-kbean-maker/#decision","title":"Decision","text":"<p>Jeka adopts the colon notation for KBean.</p>"},{"location":"adrs/01-cmdline-kbean-maker/#consequences","title":"Consequences","text":"<p>To mention default KBean, we'll simply use <code>:</code> as in <code>jeka project: pack : e2e</code></p>"},{"location":"adrs/02-name-for-skip-test-property/","title":"Title","text":"<p>Property Name for Skipping Tests</p>"},{"location":"adrs/02-name-for-skip-test-property/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/02-name-for-skip-test-property/#context","title":"Context","text":"<p>A unique property is required for skipping tests in both projects and bases. This ensures the same property can be applied when running commands like <code>jeka base:pack</code> or <code>jeka project:pack</code>.  It also simplifies invoking builds directly from OS scripts.</p>"},{"location":"adrs/02-name-for-skip-test-property/#decision","title":"Decision","text":"<p>The property will be named <code>jeka.test.skip</code>, aligning with the <code>$Maven$</code> equivalent <code>maven.skip.test</code>.</p>"},{"location":"adrs/02-name-for-skip-test-property/#consequences","title":"Consequences","text":"<p>To build without running tests, use the following commands: - <code>jeka project:pack -Djeka.test.skip</code> - <code>jeka base:pack -Djeka.test.skip</code></p>"},{"location":"adrs/03-default-include-test-pattern/","title":"Title","text":"<p>Default include patterns for running tests. </p>"},{"location":"adrs/03-default-include-test-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/03-default-include-test-pattern/#context","title":"Context","text":"<p>By default, Maven runs only test classes suffixed with <code>Test</code>. In the opposite, IDEs and Gradle runs all tests.</p>"},{"location":"adrs/03-default-include-test-pattern/#decision","title":"Decision","text":"<p>Jeka will runs all the tests by default as it is consistent with IDE and not an isolated behavior  in the java build tool landscape.</p>"},{"location":"adrs/03-default-include-test-pattern/#consequences","title":"Consequences","text":"<p>When running <code>jeka project: test</code>, all tests are executed unless explicitly specified.</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/","title":"Title","text":"<p>Run All Tests When the Include Pattern Is Empty</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#status","title":"Status","text":"<p>Accepted</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#context","title":"Context","text":"<p>Test selection allows filtering tests based on class names or tag presence. How should we interpret the behavior when no include pattern is specified? Should it mean \"include all\" or \"exclude all\"?</p> <p>At first glance, \"exclude all\" might seem more logical. However, the JUnit platform considers an empty include pattern to mean \"include all.\"</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#decision","title":"Decision","text":"<p>We decided to follow the JUnit platform behavior, both for class names and tags.</p>"},{"location":"adrs/04-run-all-tests-on-empty-include-pattern/#consequences","title":"Consequences","text":"<p>Include all tests when the include pattern is empty.</p>"},{"location":"legacy/faq/","title":"Faq","text":""},{"location":"legacy/faq/#general","title":"General","text":""},{"location":"legacy/faq/#im-behind-a-firewall-that-prevent-me-to-access-to-maven-central-what-should-i-do","title":"I'm behind a firewall that prevent me to access to Maven central, what should I do ?","text":"<p>Define the <code>jeka.repos.download</code> property in your USER_HOME/.jeka/global.properties file Alternatively, you can define the JEKA_REPOS_DOWNLOAD environment variable.</p> <p>See here for more details.</p>"},{"location":"legacy/faq/#im-behind-a-proxy-how-should-i-configure-jeka","title":"I'm behind a proxy, how should I configure Jeka ?","text":"<p>JeKa just leverages the standard Java mechanism to handle proxy. For example, You can :</p> <ul> <li>Set the <code>JAVA_TOOL_OPTIONS</code> environment variable as <code>-Dhttps.proxyHost=my.proxy.host -Dhttps.proxyPort=8888</code></li> <li>Or specify proxy properties to the jeka command line, as :  <code>-Dhttps.proxyHost=my.proxy.host -Dhttps.proxyPort=8888</code></li> </ul> <p>See here for more details on arguments.</p>"},{"location":"legacy/faq/#can-def-classes-be-hosted-in-a-separate-project-than-the-build-code","title":"Can def classes be hosted in a separate project than the build code ?","text":"<p>Yes. If you prefer for your Jeka code to lie in a distinct project, create a Jeka project in a sibling  folder and mention where is located to the build project.</p> <pre><code>Path projectPath = this.baseDir().resolve(\"../myProject\");   \nproject.setBaseDir(projectPath);\n      ...\n</code></pre>"},{"location":"legacy/faq/#how-can-i-use-maven-or-gradle-in-conjunction-with-jeka-in-intellij","title":"How can I use Maven or Gradle in conjunction with JeKa in Intellij ?","text":"<p>Maven, Gradle and other build tools manage the intellij dependencies integration by their own. This means that JeKa can interfere with this tool by generating .iml files in the module supposed by this tool.</p> <p>The solution consist in creating an intellij module at [myproject]/jeka location. For this :</p> <ul> <li>Add <code>intellij#dedicatedJekaModule=true</code> in file [myproject]/jeka/local.properties.</li> <li>Run <code>jeka intellij#iml</code> in working dir [myproject] : this will generate a [myproject]/jeka/myproject-jeka.iml file</li> <li>Go to menu **Project structure...\"</li> <li>Edit [myproject] module to remove jeka/def from Test Source Folders</li> <li>Import new module by selecting [myproject]/jeka/myproject-jeka.iml</li> </ul> <p>That's it. You can now work with Jeka as usual, still using [myproject] as working dir.</p>"},{"location":"legacy/faq/#my-jkclass-does-not-compile-so-i-cant-invoke-any-jeka-method-as-scaffoldrun-what-can-i-do","title":"My JkClass does not compile, so I can't invoke any Jeka method as 'scaffold#run'. What can I do ?","text":"<p>Use <code>-dci</code> option in command line.</p>"},{"location":"legacy/faq/#how-can-i-migrate-from-maven","title":"How can I migrate from Maven ?","text":"<p>Jeka helps translate all dependencies declared in a Maven project into the equivalent Java code.</p> <p>Assuming Maven is already installed and there is a pom.xml file at the root of the project,  execute <code>jeka maven#migrateToCode</code> or <code>jeka maven#migrateToDependencies.txt</code> to display Java code/configuration to  copy-paste in a build class or dependencies.txt file..</p>"},{"location":"legacy/faq/#compilation","title":"Compilation","text":""},{"location":"legacy/faq/#how-can-i-choose-the-jdk-used-to-compile","title":"How can I choose the JDK used to compile ?","text":"<p>Jeka uses the JDK it is running on to compile production or test code.  If code must be compiled on a another JDK version, you can specify JDK path for different version. Simply mention it as option, for example in your [JEKA HOME]/options.properties file.</p> <pre><code>jeka.jdk.19=/software/jdk19\n</code></pre> <p>This way, if one of your project source code is declared to be in a specific Java version, the relevant JDK version will be picked up automatically.</p>"},{"location":"legacy/faq/#how-can-i-use-eclipse-compiler-in-jeka","title":"How can I use Eclipse compiler in Jeka ?","text":"<p>Jeka can use any JSR199 Java compiler to compile your Java code. Just set the compiler instance you need as :</p> <pre><code>import org.eclipse.jdt.internal.compiler.tool.EclipseCompiler;\n\n@JkDep(\"org.eclipse.jdt.core.compiler:ecj:4.6.1\")\npublic class Build extends JkBean {\n\n    ...\n    project.compilation.compiler.setCompilerTool(new EclipseCompiler());\n}\n</code></pre>"},{"location":"legacy/faq/#how-can-i-generate-eclipseintellij-without-using-projectjkbean","title":"How can I generate Eclipse/Intellij without using ProjectJkBean ?","text":"<p>Just make your KBean class implement <code>JkJavaIdeSupport</code>.</p>"},{"location":"legacy/reference-guide/build-library-3rd-party-tool-integration/","title":"Build library 3rd party tool integration","text":"<p>The <code>dev.jeka.core.api.tooling</code> package provides integration with tools that developers generally deal with.</p>"},{"location":"legacy/reference-guide/build-library-3rd-party-tool-integration/#eclipse","title":"Eclipse","text":"<p><code>JkEclipseClasspathGenerator</code> and <code>JkEclipseProjectGenerator</code> provides a method for generating a proper .classpath and .project file respectively.</p> <p><code>JkEclipseClasspathApplier</code> reads information from a .classpath file.</p>"},{"location":"legacy/reference-guide/build-library-3rd-party-tool-integration/#intellij","title":"Intellij","text":"<p><code>JkIntellijImlGenerator</code> generates proper .iml files.</p>"},{"location":"legacy/reference-guide/build-library-3rd-party-tool-integration/#git","title":"Git","text":"<p><code>JkGitWrapper</code> wraps common Git commands in a lean API.</p>"},{"location":"legacy/reference-guide/build-library-3rd-party-tool-integration/#maven","title":"Maven","text":"<p><code>JkMvn</code> wraps Maven command line in a lean API</p> <p><code>JkPom</code> reads POM/BOM to extract information like : declared dependencies, dependency management, repos, properties, version, and artifactId.</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/","title":"Build library dependency management","text":"<p>For Jeka, a dependency is something that can be resolved to a set of files by a <code>JkDependencyResolver</code>. Generally a dependency resolves to 1 file (or folder) but it can also be 0 or many.</p> <p>Compared to mainstream build tools, Jeka offers a simpler and more flexible model to deal with multiple dependency configurations required to build a project. See project dependencies</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#types-of-dependency","title":"Types of Dependency","text":"<p>A dependency is always an instance of <code>JkDependency</code>.</p> <p>Jeka distinguishes between 3 main types of dependency :</p> <ul> <li>Arbitrary files located on the file system (represented by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system while the build is running.</li> <li>Files produced by a computation (represented by <code>JkComputedDependency</code> class). These files may be present on file system, or not. If they are not present, the computation is run in order to produce the missing files. Usually the computation stands for the build of an external project.</li> <li>Coordinate pointing to a remote artifact (represented by <code>JkCoordinateDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and transitively resolve any artifact located in a repository as you would do with Maven, Ivy, or Gradle.</li> </ul> <p>Lastly, Jeka uses Ivy 2.5.0 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code.</p> <p></p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#coordinate-dependency","title":"Coordinate dependency","text":"<p>This type of dependency is represented by a <code>JkCoordinateDependency</code> class. It stands for a Maven/Ivy dependency expressed with coordinates (e.g. _group:module:version).</p> <p>This is for declaring a dependency on a module hosted in the Maven or Ivy repositories.  Basically you instantiate a <code>JkCoordinateDependency</code> from its group, name, and version.</p> <pre><code>JkDependencySet.of()\n    .and(JkPopularModule.GUAVA, \"18.0\")\n    .and(\"com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[\")\n    .and(\"mygroup:mymodule:myclassifier:0.2-SNAPSHOT\");\n</code></pre> <p>Many string formats are accepted to specify a module coordinate :</p> <ul> <li>group:name</li> <li>group:name:version</li> <li>group:name:classifier:version</li> <li>group:name:classifier:extension:version</li> </ul> <p>Classifier can be either :</p> <ul> <li>an empty string to specify the default classifier</li> <li>a simple string as 'linux' to specify and retrieve a single classifier variant</li> </ul> <p>Note</p> <p>By default, dependencies specifying a classifier or an extension are not considered to be transitive.  Although, transitivity can be explicitly configured.</p> <p>Version can be either :</p> <ul> <li>a static version number, as 1.0.2</li> <li>a snapshot version, as 1.0.2-SNAPSHOT </li> <li>a version range, as [2.0.8, 2.1.0[</li> </ul> <p>Examples :</p> <ul> <li>com.sun.jersey:jersey-server : specifies artifact without version</li> <li>com.sun.jersey:jersey-server:1.19.4 : specifies artifact with version</li> <li>org.lwjgl:lwjgl:natives_linux:3.1.0 : specifies artifact having natives_linux classifier and 3.1.0 version</li> <li>org.springframework.boot:spring-boot-dependencies::pom:2.5.6 specifies artifact having .pom extension (to retrieve a BOM)</li> </ul> <p>Note</p> <ul> <li>A version ending by <code>-SNAPSHOT</code> has a special meaning : Jeka will consider it \"changing\". This means that it won't cache it locally and will download the latest version from repository.</li> <li>As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned here.</li> <li>Dependency files are downloaded in [USER HOME]/.jeka/cache/repo</li> </ul> <p>Additionally, it's possible to define the transitivity of the dependency using :  </p> <p><code>JkModuleDependency.of(\"group:name:sources:zip:version\").withTransitivity(JkTransitivity.NONE);</code></p> <p>By default, Jeka uses the most relevant transitivity according to the declaration context, so users don't need to specify it  unless they want a specific one.</p> <p>See later for more details about transitivity.</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#file-system-dependencies","title":"File System Dependencies","text":"<p>This type of dependency is represented by the <code>JkFileSystemDependency</code> class.</p> <p>Just mention the path of one or several files. If one of the files does not exist at the time of resolution (when the dependency is actually retrieved), build fails.</p> <pre><code>JkDependencySet.of().andFiles(\"libs/my.jar\", \"libs/my.testingtool.jar\");\n</code></pre>"},{"location":"legacy/reference-guide/build-library-dependency-management/#computed-dependencies","title":"Computed Dependencies","text":"<p>This type of dependency is represented by the <code>JkComputedDependency</code> class.</p> <p>It is typically used for multi-modules or multi-techno projects.</p> <p>The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails.</p> <p>This mechanism is quite simple yet powerful as it addresses the following use cases :</p> <ul> <li>Dependencies on files produced by an artifact producer (<code>JkArtifactProducer</code>). A <code>JkProject</code> is an artifact producer.</li> <li>Dependencies on files produced by external build tools (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...).</li> <li>... In other words, files produced by any means.</li> </ul> <p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p> <p>The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka. <pre><code>Path mavenProject = Paths.get(\"../a-maven-project\");\nJkProcess mavenBuild = JkProcess.of(\"mvn\", \"clean\", \"install\")\n        .withWorkingDir(mavenProject);\nPath mavenProjectJar = mavenProject.resolve(\"target/maven-project.jar\");\nJkJavaProject externalProject = \n        JkJavaProject.ofSimple(Paths.get(\"../a-jeka-project\")); \nJkDependencySet deps = JkDependencySet.of()\n    .and(JkComputedDependency.of(mavenBuild, mavenProjectJar))\n    .and(externalProject);\n</code></pre></p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#dependency-set","title":"Dependency Set","text":"<p>A dependency set (<code>JkDependencySet</code>) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of <code>JkDependency</code>. See here</p> <p>dependencySet also defines :</p> <ul> <li>A version provider to define which version of a module should be used in case it is not explicitly mentioned. </li> <li>A set of transitive dependency exclusion rules.</li> </ul> <p>It is designed as an immutable object where we can apply set theory operations for adding, removing, or merging with other dependencies and dependencySet.</p> <p>Example</p> <pre><code>JkDependencySet deps = JkDependencySet.of()\n    .and(\"com.google.guava\") \n    .and(\"org.slf4j:slf4j-simple\")\n    .and(\"com.orientechnologies:orientdb-client:2.0.8\")\n    .andFile(\"../libs.myjar\")\n    .withVersionProvider(myVersionProvider);\n</code></pre> <p>Note</p> <ul> <li>Module versions and scopes can be omitted when declaring dependencies. Versions can be provided by a <code>JkVersionProvider</code>.</li> <li>Instances of <code>JkDependencySet</code> can be combined in order to construct a large dependencySet from smaller ones.</li> </ul>"},{"location":"legacy/reference-guide/build-library-dependency-management/#transitivity","title":"Transitivity","text":"<p>For each dependency, mainstream build tools use a single concept (scope or configuration) to determine :</p> <ol> <li>which part of the build needs the dependency</li> <li>which transitive dependencies to fetch along the dependency</li> <li>with which transitivity the dependency must be published</li> </ol> <p>This confusion leads to dependency management systems that are bloated, difficult to reason with, and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a smaller number, but with limitations and not-so-clear transitivity/publish rules.</p> <p>In the opposite, Jeka distinguishes clearly the following three purposes :</p> <ol> <li>Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be    defined relatively to another using set theory operations.</li> <li>For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency.</li> <li>For publishing, we can optionally re-define a specific dependencySet, exposing exactly what we want.</li> </ol> <p>Jeka defines by default, three levels of transitivity :</p> <ul> <li>NONE : Not transitive</li> <li>COMPILE : Also fetches transitive dependencies declared with scope 'compile' in the dependency published pom.</li> <li>RUNTIME : Also fetches transitive dependencies declared with any scope in the dependency published pom.</li> </ul> <p>Notes</p> <p>On Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'.</p> <p>For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'.</p> <p>The below example shows a JkJavaProject declaration using explicit transitivity.</p> <p><pre><code>JkJavaProject.of().simpleFacade()\n    .configureCompileDeps(deps -&gt; deps\n            .and(\"com.google.guava:guava:23.0\", JkTransitivity.NONE)\n            .and(\"javax.servlet:javax.servlet-api:4.0.1\"))\n    .configureRuntimeDeps(deps -&gt; deps\n            .and(\"org.postgresql:postgresql:42.2.19\")\n            .withTransitivity(\"com.google.guava:guava\", JkTransitivity.RUNTIME)\n            .minus(\"javax.servlet:javax.servlet-api\"))\n    .configureTestDeps(deps -&gt; deps\n            .and(Hint.first(), \"org.mockito:mockito-core:2.10.0\")\n    )\n</code></pre> It results in : <pre><code>Declared Compile Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:NONE\n  javax.servlet:javax.servlet-api:4.0.1\n\nDeclared Runtime Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n\nDeclared Test Dependencies : 4 elements.\n  org.mockito:mockito-core:2.10.0\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n  javax.servlet:javax.servlet-api:4.0.1\n</code></pre> Dependencies without any transitivity specified will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies.</p> <p>The API allows you to redefine the transitivity declared in a upper dependency set.</p> <p>Note that transitivity can only apply to <code>JkModuleDependency</code> (like com.google.guava:guava:23.0) and <code>JkLocalProjectDependency</code>.</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#resolve-dependencies","title":"Resolve Dependencies","text":"<p>The <code>JkDependencyResolver</code> class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning <code>JkResolveResult</code> from a <code>JkdependencySet</code>.</p> <pre><code>JkDependencySet deps = JkDependencySet.of()\n                            .and(\"org.apache.httpcomponents:httpclient:4.5.3\")\n                            .andFile(\"libs/my.jar\");\n\n// Here, module dependencies are fetched from Maven central repo\nJkDependencyResolver resolver = \n        JkDependencyResolver.of(JkRepo.ofMavenCentral());  \nJkResolveResult result = resolver().resolve(deps);\n</code></pre> <p>From the result you can :</p> <ul> <li>Navigate in the resolved dependency tree as :</li> </ul> <pre><code>JkDependencyNode slfjApiNodeDep = result.getDependencyTree()\n        .getFirst(JkModuleId.of(\"org.slf4j:slf4j-api\"));\nSystem.out.println(slfjApiNode.getModuleInfo().getResolvedVersion());\n</code></pre> <ul> <li>Get the direct list of artifact files</li> </ul> <pre><code>JkPathSequence sequence = result.getFiles();  \nsequence.forEach(System.out::println); // print each files part of the result\n</code></pre>"},{"location":"legacy/reference-guide/build-library-dependency-management/#publication","title":"Publication","text":"<p>Jeka is able to publish on both the Maven and Ivy repositories. This includes repositories such as Sonatype Nexus.</p> <p>Maven and Ivy have different publication models, so Jeka proposes specific APIs according to whether you want to publish on a Maven or Ivy repository.</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#publish-on-a-maven-repository","title":"Publish on a Maven repository","text":"<p>Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according to provided elements.</p> <p>Find an example here</p> <p>Notice that Jeka allows you to :</p> <ul> <li>Publish more than one artifact.</li> <li>Produce &amp; publish checksum files for each published artifact.</li> <li>Mention using unique snapshots (What is it ?).</li> <li>Feed generated pom with data necessary to publish on central repository.</li> <li>Sign published artifacts with PGP</li> <li>Publish to multiple repositories by creating the publisher using a <code>JkRepoSet</code> instead of a <code>JkRepo</code>.</li> </ul> <p>To sign with PGP, there is no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts.</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#publish-to-a-ivy-repository","title":"Publish to a Ivy repository","text":"<p>Publishing on Ivy repo is pretty similar to publishing on Maven, though there are options specific to Ivy.</p> <p>See also here</p>"},{"location":"legacy/reference-guide/build-library-dependency-management/#common-classes","title":"Common Classes","text":"<ul> <li> <p><code>JkRepo</code> and <code>JkRepoSet</code> represent both download and upload repositories. </p> </li> <li> <p><code>JkRepoFromProperties</code>provides configured repositories according to global or project scopes properties.</p> </li> <li> <p><code>JkDependencySet</code> represents a set of dependencies.</p> </li> <li> <p><code>JkDependencyResolver</code> resolves dependencies to classpaths and resolution results that allow resolution exploration.</p> </li> <li> <p><code>JkModuleFileProxy</code> provides an smart way to get a file from its coordinates.</p> </li> </ul>"},{"location":"legacy/reference-guide/build-library-files/","title":"Build library files","text":""},{"location":"legacy/reference-guide/build-library-files/#files","title":"Files","text":"<p>File manipulation is a central part of building software. Jeka embraces JDK7 java.nio.file API by adding some concepts around it, to provide a powerful and fluent style of API performing recurrent tasks with minimal effort.</p> <p>The following classes lie in the <code>dev.jeka.core.api.file</code> package:</p> <ul> <li> <p><code>JkPathFile</code> A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods.</p> </li> <li> <p><code>JkPathSequence</code> An Immutable sequence of <code>java.nio.file.Path</code> providing methods for filtering or appending.</p> </li> <li> <p><code>JkPathMatcher</code> An immutable <code>java.nio.file.PathMatcher</code> based on <code>java.nio.file</code> glob pattern or regerxp.   Used by <code>JkPathTree</code> to filter in/out files according name patterns.</p> </li> <li> <p><code>JkPathTree</code> An Immutable root folder along a <code>PathMatcher</code> providing operations to copy, navigate, zip, iterate, or watch.   This is a central class in Jeka API.</p> </li> <li> <p><code>JkZipTree</code> Same as <code>JkPathTree</code> but using a zip file instead of a directory. It allows you to manipulate a zip file   as a regular folder. </p> </li> <li> <p><code>JkPathTreeSet</code> An Immutable set of <code>JkPathTree</code>. Helpful to define a set of sources/resources and create jar/zip files.</p> </li> <li> <p><code>JkResourceProcessor</code> A mutable processor for copying a set of files, preserving the structure and   replacing some texts with others. Typically used for replacing the token <code>${server.ip}</code> with an actual value.</p> </li> </ul> <p>Examples</p> <pre><code>// creates a file and writes the content of the specified url.\nJkPathFile.of(\"config/my-config.xml\").createIfNotExist().replaceContentBy(\"http://myserver/conf/central.xml\");\n\n// copies all non java source files to another directory preserving structure\nJkPathTree.of(\"src\").andMatching(false, \"**/*.java\").copyTo(\"build/classes\");\n\n// One liner to zip an entire directory\nJkPathTree.of(\"build/classes\").zipTo(Paths.get(\"mylib.jar\"));\n</code></pre>"},{"location":"legacy/reference-guide/build-library-intro/","title":"Build library intro","text":"<p>Jeka contains a library for all regular things required to build/test/publish projects. The library does not depend on the execution engine and has zero dependency. </p>"},{"location":"legacy/reference-guide/build-library-intro/#api-style","title":"API Style","text":"<p>Jeka tries to stick with a consistent API design style.</p> <ul> <li>All Jeka public classes/interfaces start with <code>Jk</code>. The reason for this is to ease distinction, in IDE, between classes supposed be used   in productions or tests and the ones used for building. It also helps to explore Jeka API.</li> <li>As a rule of thumb, Jeka favors immutable objects for shallow structures and mutable ojects for deeper structures. Both provide a fluent interface when possible.</li> <li>In deep structures, final fields are declared <code>public</code> and have no getter counterpart.</li> <li>All objects are instantiated using static factory methods. Every factory method name starts with <code>of</code>.</li> <li>All accessor method names (methods returning a result without requiring IO, meaning computation only) start with <code>get</code>.</li> <li>To create a subtly different object from an immutable one, Jeka provides :<ul> <li>Methods starting with <code>with</code> when a property is to be replaced by another.</li> <li>Methods starting with <code>and</code> when a collection property is to be replaced by the same one plus an extra element.</li> <li>Methods starting with <code>minus</code> when a collection property is to be replaced by the same one minus a specified element.</li> </ul> </li> <li>To modify a mutable object, Jeka provides :<ul> <li>Methods starting with <code>set</code> to replace a single property value with another.</li> <li>Methods starting with <code>add</code> to add a value to a collection property.</li> <li>Those methods return the object itself for chaining.</li> </ul> </li> </ul>"},{"location":"legacy/reference-guide/build-library-intro/#domains-covered-by-the-api","title":"Domains Covered by the API","text":"<p>The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API relies on other lower level ones provided by Jeka. At a glance, these are the domains covered by the Jeka APIs :</p> <ul> <li>Files : File trees, filters, zip, path sequence</li> <li>System : Launching external process, Logging, Meta-info</li> <li>Cryptography : PGP signer</li> <li>Dependency management : Dependency management, publishing on repositories</li> <li>Java : Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching</li> <li>Testing : Launching tests and get reports</li> <li>Project : Project structure to be built</li> <li>Tooling : Eclipse integration, intellij integration, Maven interaction, Git</li> <li>Support : Set of utility class with static methods to handle low-level concerns</li> </ul>"},{"location":"legacy/reference-guide/build-library-project-build/","title":"Build library project build","text":"<p>Jeka features high-level and low-level classes to deal with Java builds and JVM concepts.</p>"},{"location":"legacy/reference-guide/build-library-project-build/#package-devjekacoreapijava","title":"Package <code>dev.jeka.core.api.java</code>","text":"<p>Base classes are used as a foundation for implementing Jeka high-level build API but they can be used directly in a low level build description. These classes belong to <code>dev.jeka.core.api.java</code> package.</p> <ul> <li><code>JkClassLoader</code> and <code>JkUrlClassloader</code> wrap a <code>java.lang.ClassLoader</code> adding convenient methods and classpath scanning capability.</li> <li><code>JkJarPacker</code> A simple utility to create a Jar or fat Jar file from compiled classes.</li> <li><code>JkJavaCompiler</code> Wraps either a Java Compiler tool, or a javac process.</li> <li><code>JkJavadocProcessor</code> A Java source processor producing standard Javadoc</li> <li><code>JkJavaProcess</code> A utility to launch Java process (from class dirs or jars)</li> <li><code>JkManifest</code> Stands for the manifest file to be included in jar files.</li> </ul>"},{"location":"legacy/reference-guide/build-library-project-build/#package-devjekacoreapij2e","title":"Package <code>dev.jeka.core.api.j2e</code>","text":"<ul> <li><code>JkJ2eWarArchiver</code> : Provides methods to generate war files, including dependency jars.</li> <li><code>JkJ2eWarProjectAdapter</code> : Helps to adapt an existing <code>JkProject</code> to make it generate war artefacts_.</li> </ul>"},{"location":"legacy/reference-guide/build-library-project-build/#package-devjekacoreapikotlin","title":"Package <code>dev.jeka.core.api.kotlin</code>","text":"<ul> <li> <p><code>JkKotlinCompiler</code> : Provides a means to get a suitable compiler according a given Kotlin version. This class also provides methods to    compile Kotlin sources in a fluent way.</p> </li> <li> <p><code>JkKotlinModules</code> : Holds the constants for common Kotlin library coordinates.</p> </li> </ul>"},{"location":"legacy/reference-guide/build-library-project-build/#package-devjekacoreapitesting","title":"Package <code>dev.jeka.core.api.testing</code>","text":"<p>Jeka features a simple yet powerful API to launch tests. It relies entirely on JUnit5. This means that any test framework is supported by Junit5 platform.</p> <p>Jeka testing API mostly hides Junit Platform. For most of the cases, you won't need to code against Junit-Platform API to launch tests with Jeka. Nevertheless, Jeka allows users to code against Junit-Platform for fine-tuning.</p> <p>The API classes all belong to <code>dev.jeka.core.api.testing</code> package.</p>"},{"location":"legacy/reference-guide/build-library-project-build/#jktestprocessor","title":"<code>JkTestProcessor</code>","text":"<p>This is the entry point to launch tests. Tests are executed using the current classloader classpath  + extra class path mentioned in <code>#launch</code> method arguments.</p> <p>We can access <code>JkEngineBehavior</code> by <code>JkTestProcessor#getEngineBehavior()</code>. From there we can </p> <ul> <li>Select the output dir of the test report</li> <li>Change how the test progress is displayed</li> <li>Modify how JUnitPlatform will behave by directly accessing the JunitPlatform API </li> </ul>"},{"location":"legacy/reference-guide/build-library-project-build/#jktestselection","title":"<code>JkTestSelection</code>","text":"<p>This is the object passed as an argument of <code>JkTestProcessor#launch</code> to determine which test to launch. </p> <p>It can be set using file or tag filters. It is also possible to code against  JunitPlatform API (example here).</p>"},{"location":"legacy/reference-guide/build-library-project-build/#jktestresult","title":"<code>JkTestResult</code>","text":"<p>The result of a test launch. It provides count for tests found, failure, skip, success ...</p>"},{"location":"legacy/reference-guide/build-library-project-build/#package-devjekacoreapiproject","title":"Package <code>dev.jeka.core.api.project</code>","text":"<p>This is the Jeka high-level API to build Java/JVM projects. API classes belong to  <code>dev.jeka.core.api.project</code> package.</p> <p>It introduces the concept of <code>JkProject</code> from where it performs compilation, testing, resources processing, packaging, publication, and more. <code>JkProject</code> is the root of a deep structure embracing the parent-chaining pattern for readability.</p> <p>The API contains a lot of extension points to add specific behaviors.</p>"},{"location":"legacy/reference-guide/build-library-project-build/#project-structure","title":"Project Structure","text":"JkProject structure<pre><code>project\n+- baseDir\n+- outputDir\n+- artifactLocator (define where artifact files are supposed to be created)\n+- duplicateDependencyConflictStrategy\n+- jvmTargetVersion\n+- sourceEncoding\n+- javaCompileToolChain\n+- dependencyResolver\n+- compilation  (produce individual binary files from production sources. This includes resource processing, code generation, processing on .class files, ...)\n|  +- layout (where are located source and resource files)\n|  +- source generators (plugin mechanism for generating source files)\n|  +- dependencies   (stands for compile dependencies)\n|  +- preCompileActions (including resources processing)\n|  +- compileActions (including java sources compilation. Compilation for other languages can be added here)\n|  +- postCompileActions\n|  +- methods : resolveDependencies(), run()\n+- testing\n|  +- testCompilation (same as above 'prodcCompilation' but for test sources)\n|  |  +- layout\n|  |  +- dependencies (stands for test dependencies)\n|  |  + ...\n|  +- breakOnFailure (true/false)\n|  +- skipped (true/false)\n|  +- testProcessor\n|  |  +- forkedProcess (configured the forked process who will run tests)\n|  |  +- preActions\n|  |  +- postActions\n|  |  +- engineBehavior\n|  |  |  +- testReportDir\n|  |  |  +- progressDisplayer\n|  |  |  +- launcherConfiguration (based on junit5 platform API)\n|  |  +- testSelection\n|  |  |  +- includePatterns\n|  |  |  +- includeTags\n|  +- method : run()\n+- packaging (produces javadoc and source jar and bin jars)\n|  +- javadocConfiguration\n|  +- runtimeDependencies\n|  +- manifest\n|  +- fatJar (customize produced fat/uber jar if any)\n|  +- methods : createJavadocJar(), createSourceJar(), createBinJar(), createFatJar(), resolveRuntimeDependencies()\n+- mavenPublication (define what to be published on Maven repositoty)\n|  +- moduleId (group:name)\n|  +- version\n|  +- artifacts ( which artifact to publish)\n|  +- dependencyCustomizer (customize the transitive dependencies to be published)\n|  +- mavenSpecificInfo\n|  +- methods : publish(), getVersion(), getModuleId()\n+ methods :  toDependency(transitivity), getIdeSupport(), pack(), getDependenciesAsXml(), includeLocalAndTextDependencies()           \n</code></pre> <p>For convenience, <code>JkProject</code> provides a facade in order to make common settings friendly, without navigating deep into the structure. From facade, you can setup dependencies, java version, project layout, test behavior, test selection and publication.</p> <pre><code>JkProject.of().flatFacade()\n   .configureCompileDependencies(deps -&gt; deps\n           .and(\"com.google.guava:guava:21.0\")\n           .and(\"com.sun.jersey:jersey-server:1.19.4\")\n           .and(\"org.junit.jupiter:junit-jupiter-engine:5.6.0\"))\n   .configureRuntimeDependencies(deps -&gt; deps\n           .minus(\"org.junit.jupiter:junit-jupiter-engine\")\n           .and(\"com.github.djeang:vincer-dom:1.2.0\"))\n   .configureTestDependencies(deps -&gt; deps\n           .and(\"org.junit.vintage:junit-vintage-engine:5.6.0\"))\n   .addTestExcludeFilterSuffixedBy(\"IT\", false)\n   .setJavaVersion(JkJavaVersion.V8)\n   .setPublishedModuleId(\"dev.jeka:sample-javaplugin\")\n   .setPublishedVersion(\"1.0-SNAPSHOT\");\n</code></pre> <p>If the fa\u00e7ade is not sufficient to set up the project build, you can use the main API. <code>JkProject</code> instances are highly configurable.</p> <p>Here is a pretty complete example inspired from the Jeka Build Class .</p>"},{"location":"legacy/reference-guide/build-library-project-build/#dependencies","title":"Dependencies","text":"<p>Project dependencies are managed differently than in Maven/Gradle. Instead of defining  a single collection of dependencies, each bounded for a specific scope/configuration,  Jeka projects define 3 distinct classpaths : compile, runtime and test.</p> <p>Each classpath defines its own set of dependencies independently, though they are defined relatively to each other.</p> <p>Compile classpath : is defined using <code>project.getCompilation().configureDependencies()</code>.</p> <p>Runtime classpath : is defined from Compile Classpath. This base can be modified using <code>project.packaging.configureDependencies()</code>.</p> <p>Test classpath : is defined from a merge of Compile Classpath and Runtime Classpath. This base can be modified  using <code>project.getTesing().getCompilation().configureDependencies()</code></p>"},{"location":"legacy/reference-guide/build-library-project-build/#full-text-description","title":"Full Text Description","text":"<p>An entire project dependency set can be declared with full text description.</p> <p>By default, if a file named <code>project-dependencies.txt</code> is present in [PROJECT_DIR]/jeka, this content is taken  in account to specify project dependencies.</p> <p>Dependencies have to be declared with the format <code>group:module:[classifier]:[type]:[version]</code> where classifier, type and version' are optional. See `JkCoordinate.of(String description) for details.</p> <p>To import bill-of-materials (aka BOM) just declare a dependency as 'group:module::pom:version'</p> <p>Symbols <code>@</code> and <code>@@</code> can be used to mention dependency exclusions.</p> <p>Example</p> <pre><code>== COMPILE ==\norg.lwjgl:lwjgl-bom::pom:3.3.1   # Use lwjgl BOM so we don't need to specify lwjgl versions afterward\norg.lwjgl:lwjgl:natives-linux::  # specify the 'natives-linux' classifier for lwjgl\norg.projectlombok:lombok:1.16.16  \n\n== RUNTIME ==\norg.postgresql:postgresql:42.5.0\n- org.projectlombok:lombok       # remove lombok from runtime dependencies \n\n== TEST ==\norg.seleniumhq.selenium:selenium-chrome-driver:3.4.0\norg.fluentlenium:fluentlenium-junit:3.2.0\n@ org.apache.httpcomponents:httpclient  # exclude http-client from fluentlenium-junit transitive dependencies\norg.fluentlenium:fluentlenium-assertj:3.2.0\n@@ net.sourceforge.htmlunit:htmlunit    # exclude htmlunit from all transitive dependencies\n</code></pre> <p><code>== COMPILE ==</code> Defines dependencies that will constitute the compile classpath.</p> <p><code>== RUNTIME ==</code> Defines dependencies that will constitute the runtime classpath. The dependencies will be the ones declared in the == COMPILE == section plus the ones declared in the == RUNTIME == section. If dependencies declared in the == compile == section should not be included for the runtime classpath, they should  be explicitly removed using the '-' symbol.</p> <p><code>== TEST ==</code> Defines dependencies that will constitute the test classpath. The dependencies will be the ones declared in the == COMPILE == or == RUNTIME == sections (merge) plus the ones declared in the == TEST == section.  </p> <p>Tip</p> <p>If you are using Jeka plugin for Intellij, hit <code>ctrl+&lt;space&gt;</code> for displaying suggestions.</p>"},{"location":"legacy/reference-guide/build-library-project-build/#publication","title":"Publication","text":"<p>Projects can be published on binary repositories (as Maven or Ivy) using <code>project.getPubliication().publish()</code>. When this method is invoked, all artifacts defined in the projects are published.  Artifacts can be binary, sources, javadoc, or any kind of file.</p> <p>When published on a repository, a metadata file is generated mentioning moduleId, version and transitive  dependencies. </p> <p>Transitive dependencies are inferred from compile and runtime dependencies declared for the project, though they  can be modified programmatically using <code>project.getPublication().getMaven().configureDependencies()</code> and <code>project.getPublication().getIvy().configureDependencies()</code> respectively.</p>"},{"location":"legacy/reference-guide/build-library-system/","title":"Build library system","text":"<p>The <code>dev.jeka.core.api.system</code> package provides system level functions :</p> <ul> <li> <p><code>JkInfo</code> Provides meta information as the running version of Jeka.</p> </li> <li> <p><code>JkLocator</code> Provides information about where the repository cache or Jeka user home are located.</p> </li> <li> <p><code>JkLog</code> Provides API to log Jeka event. It supports hierarchical logs through the <code>#startTask</code>   and <code>#endtask</code> methods.</p> </li> <li> <p><code>JkProcess</code> Launcher for external process.</p> </li> <li> <p><code>JkPrompt</code> One-liner to ask for user input.</p> </li> </ul>"},{"location":"legacy/reference-guide/build-library/","title":"The Build Library","text":"<p>Jeka contains a library for all regular things you need to build/test/publish projects.. The library does not depend on the execution engine and has zero dependency. </p>"},{"location":"legacy/reference-guide/build-library/#api-style","title":"API Style","text":"<p>Jeka tries to stick with a consistent API design style.</p> <ul> <li>All Jeka public classes/interfaces start with <code>Jk</code>. The reason is for easing distinction, in IDE, between classes supposed be used   in production or test and the ones used for building. It also helps to explore Jeka API.</li> <li>As a rule of thumb Jeka favors immutable objects for shallow structures and parent-chaining trees for deeper ones. Both provide a fluent interface when possible.</li> <li>All objects are instantiated using static factory methods. Every factory method names start with <code>of</code>.</li> <li>All accessor method names (methods returning a result without requiring IO, only computation) starts with <code>get</code>.</li> <li>To create a subtly different object from another immutable one, Jeka provides :</li> <li>Methods starting with <code>with</code> when a property is to be replaced by another.</li> <li>Methods starting with <code>and</code> when a collection property is to be replaced by the same one plus an extra element.</li> <li>Methods starting with <code>minus</code> when a collection property is to be replaced by the same one minus a specified element.</li> <li>To modify a mutable object, Jeka provides :</li> <li>Methods starting with <code>set</code> to replace a single property value by another.</li> <li>Methods starting with <code>add</code> to add a value to a collection property.   Those methods return the object itself for chaining.</li> </ul>"},{"location":"legacy/reference-guide/build-library/#domains-covered-by-the-api","title":"Domains Covered by the API","text":"<p>The previous example demonstrates how the Java/project API can be used to build and publish Java projects. This API relies on other lower level ones provided by Jeka. In a glance these are the domains covered by the Jeka APIs :</p> <ul> <li>Files : File trees, filters, zip, path sequence</li> <li>System : Launching external process, Logging, Meta-info</li> <li>Cryptography : PGP signer</li> <li>Dependency management : Dependency management, publishing on repositories</li> <li>Java : Compilation, javadoc, resource processor, manifest, packager, classloader, classpath, launching</li> <li>Testing : Launching tests and get reports</li> <li>Project : Project structure to build</li> <li>Tooling : Eclipse integration, intellij integration, Maven interaction, Git</li> <li>Support : Set of utility class with static methods to handle low-level concerns</li> </ul>"},{"location":"legacy/reference-guide/build-library/#files","title":"Files","text":"<p>File manipulation is a central part for building software. Jeka embraces JDK7 java.nio.file API by adding some concepts around, to provide a powerful fluent style API performing recurrent tasks with minimal effort.</p> <p>The following classes lie in <code>dev.jeka.core.api.file</code> package:</p> <ul> <li> <p><code>JkPathFile</code> A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods.</p> </li> <li> <p><code>JkPathSequence</code> An Immutable sequence of <code>java.nio.file.Path</code> providing methods for filtering or appending.</p> </li> <li> <p><code>JkPathMatcher</code> An immutable <code>java.nio.file.PathMatcher</code> based on <code>java.nio.file</code> glob pattern or regerxp.   Used by <code>JkPathTree</code> to filter in/out files according name patterns.</p> </li> <li> <p><code>JkPathTree</code> An Immutable root folder (or a zip file) along a <code>PathMatcher</code> providing operations to copy, navigate, zip or iterate.   This is a central class in Jeka API.</p> </li> <li> <p><code>JkPathTreeSet</code> An Immutable set of <code>JkPathTree</code>. Helpful to define set of sources/resources and create jar/zip files.</p> </li> <li> <p><code>JkResourceProcessor</code> A mutable processor for copying a set of files, preserving the structure and   replacing some text by other text. Typically, used for replacing token as <code>${server.ip}</code> by an actual value.</p> </li> </ul> <p>Examples</p> <pre><code>// creates a file and writes the content of the specified url.\nJkPathFile.of(\"config/my-config.xml\").createIfNotExist().replaceContentBy(\"http://myserver/conf/central.xml\");\n\n// copies all non java source files to another directory preserving structure\nJkPathTree.of(\"src\").andMatching(false, \"**/*.java\").copyTo(\"build/classes\");\n\n// One liner to zip an entire directory\nJkPathTree.of(\"build/classes\").zipTo(Paths.get(\"mylib.jar\"));\n</code></pre>"},{"location":"legacy/reference-guide/build-library/#system","title":"System","text":"<p>The <code>dev.jeka.core.api.system</code> package provides system level functions :</p> <ul> <li> <p><code>JkInfo</code> Provides meta information as the running version of Jeka.</p> </li> <li> <p><code>JkLocator</code> Provides information about where is located repository cache or Jeka user home.</p> </li> <li> <p><code>JkLog</code> Provides API to log Jeka event. It supports hierarchical logs through <code>#startTask</code>   and <code>#endtask</code> methods.</p> </li> <li> <p><code>JkProcess</code> Launcher for external process.</p> </li> <li> <p><code>JkPrompt</code> One-liner to ask user input.</p> </li> </ul>"},{"location":"legacy/reference-guide/build-library/#dependency-management","title":"Dependency Management","text":"<p>Dependency management API let define, fetch and publish dependencies. Api classes belong to <code>dev.jeka.core.api.depmanagement</code> package</p>"},{"location":"legacy/reference-guide/build-library/#concepts","title":"Concepts","text":""},{"location":"legacy/reference-guide/build-library/#dependency","title":"Dependency","text":"<p>For Jeka, a dependency is something that can be resolved to a set of files by a <code>JkDependencyResolver</code>. Generally a dependency resolves to 1 file (or folder) but it can be 0 or many.</p> <p>A dependency is always an instance of <code>JkDependency</code>.</p> <p>Jeka distinguishes mainly 3 types of dependency :</p> <ul> <li>Arbitrary files located on the file system (represented by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system when the build is running.</li> <li>Files produced by a computation (represented by <code>JkComputedDependency</code> class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project.</li> <li>Reference to module (represented by <code>JkModuleDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and resolve transitively any artifact located in a repository as you would do with Maven, Ivy or Gradle.</li> </ul> <p>For the last, Jeka is using Ivy 2.5.0 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code.</p> <p></p> <p>JkModuleDependencies (dependency on module through coordinates)</p> <p>This is for declaring a dependency on module hosted in Maven or Ivy repository. Basically you instantiate a <code>JkModuleDepency</code> from it's group, name and version.</p> <p><pre><code>    JkDependencySet.of()\n        .and(JkPopularModule.GUAVA, \"18.0\")\n        .and(\"com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[\")\n        .and(\"mygroup:mymodule:myclassifier:0.2-SNAPSHOT\");\n</code></pre> There is many way to indicate a module dependency, see Javadoc for browsing possibilities.</p> <p>Note that :</p> <ul> <li>A version ending by <code>-SNAPSHOT</code> has a special meaning : Jeka will consider it \"changing\". This means that it won't cache it locally and will download the latest version from repository.</li> <li>As Jeka relies on Ivy under the hood, it accepts dynamic versions as mentioned here.</li> <li>Dependency files are downloaded in [USER HOME]/.jeka/cache/repo</li> </ul> <p>JkFileSystemSependency (dependency on local files)</p> <p>Just mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails.</p> <pre><code>    JkDependencySet.of().andFiles(\"libs/my.jar\", \"libs/my.testingtool.jar\");\n</code></pre> <p>JkComputedDependenciy (dependency on files produced by computation)</p> <p>It is typically used for multi-modules or multi-techno projects.</p> <p>The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails.</p> <p>This mechanism is quite simple yet powerful as it addresses following use cases :</p> <ul> <li>Dependencies on files produced by an artifact producer (<code>JkArtifactProducer</code>). A <code>JkProject</code> is an artifact producer.</li> <li>Dependencies on files produced by external build tool (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...).</li> <li>... In other words, files produced by any means.</li> </ul> <p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p> <p>The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka. <pre><code>Path mavenProject = Paths.get(\"../a-maven-project\");\nJkProcess mavenBuild = JkProcess.of(\"mvn\", \"clean\", \"install\").withWorkingDir(mavenProject);\nPath mavenProjectJar = mavenProject.resolve(\"target/maven-project.jar\");\nJkJavaProject externalProject = JkJavaProject.ofSimple(Paths.get(\"../a-jeka-project\")); \nJkDependencySet deps = JkDependencySet.of()\n    .and(JkComputedDependency.of(mavenBuild, mavenProjectJar))\n    .and(externalProject);\n</code></pre></p>"},{"location":"legacy/reference-guide/build-library/#dependencyset","title":"DependencySet","text":"<p>A dependencySet (<code>JkDependencySet</code>) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of <code>JkDependency</code>. See here</p> <p>dependencySet also defines :</p> <ul> <li>A version provider to define which version of a module we should use in case it is not explicitly mentioned. It is possible to populate a version provider by passing a BOM coordinate.</li> <li>A set of transitive dependency exclusion rules.</li> </ul> <p>It is designed as an immutable object where we can apply set theory operations for adding, removing or merging with other dependencies and dependencySet.</p> Example of dependency set <pre><code>JkDependencySet deps = JkDependencySet.of()\n    .and(\"com.google.guava\") \n    .and(\"org.slf4j:slf4j-simple\")\n    .and(\"com.orientechnologies:orientdb-client:2.0.8\")\n    .andFile(\"../libs.myjar\")\n    .withVersionProvider(myVersionProvider);\n</code></pre> <p>Note that :</p> <ul> <li>Module version and scopes can be omitted when declaring dependencies. Versions can be provided by a <code>JkVersionProvider</code>.</li> <li>Instances of <code>JkDependencySet</code> can be combined together in order to construct large dependencySet from smaller ones.</li> <li><code>JkDependencySet#ofTextDescription</code> provides a mean to instantiate a dependency set from a simple text.</li> </ul> Example of text describing dependencies <pre><code>- COMPILE+RUNTIME\norg.springframework.boot:spring-boot-starter-thymeleaf\norg.springframework.boot:spring-boot-starter-data-jpa\n\n- RUNTIME\ncom.h2database:h2\norg.liquibase:liquibase-core\ncom.oracle:ojdbc6:12.1.0\n\n- TEST\norg.springframework.boot:spring-boot-starter-test\norg.seleniumhq.selenium:selenium-chrome-driver:3.4.0\norg.fluentlenium:fluentlenium-assertj:3.2.0\norg.fluentlenium:fluentlenium-junit:3.2.0\n\n- COMPILE\norg.projectlombok:lombok:1.16.16\n</code></pre>"},{"location":"legacy/reference-guide/build-library/#transiitivity","title":"Transiitivity","text":"<p>Mainstream build tools use a single concept ('scope' or 'configuration') to determine both :</p> <ol> <li>Which part of the build needs the dependency</li> <li>Which transitive dependencies to fetch along the dependency. </li> <li>If the dependency must be part of the transitive dependencies according a configuration. </li> </ol> <p>This confusion leads in dependency management systems that are bloated, difficult to reason about and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a fewer but with limitations and not-so-clear transitivity/publish rules.</p> <p>In the opposite, Jeka distinguishes clearly the three purposes :</p> <ol> <li>Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be    defined relatively to another using set theory operations.</li> <li>For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency.</li> <li>For publishing, we can optionally re-define a specific dependencySet, exposing exactly what we want.</li> </ol> <p>Jeka defines by default, 3 levels of transitivity :</p> <ul> <li>NONE : Not transitive</li> <li>COMPILE : Also fetch transitive dependencies declared with scope 'compile' in the dependency published pom.</li> <li>RUNTIME : Also fetch transitive dependencies declared with any scope in the dependency published pom.</li> </ul> <p>Reminder : on Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'.</p> <p>For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'.</p> <p>The below example shows a JkJavaProject declaration using explicit transitivity.</p> <p><pre><code>JkJavaProject.of().simpleFacade()\n    .configureCompileDeps(deps -&gt; deps\n            .and(\"com.google.guava:guava:23.0\", JkTransitivity.NONE)\n            .and(\"javax.servlet:javax.servlet-api:4.0.1\"))\n    .configureRuntimeDeps(deps -&gt; deps\n            .and(\"org.postgresql:postgresql:42.2.19\")\n            .withTransitivity(\"com.google.guava:guava\", JkTransitivity.RUNTIME)\n            .minus(\"javax.servlet:javax.servlet-api\"))\n    .configureTestDeps(deps -&gt; deps\n            .and(Hint.first(), \"org.mockito:mockito-core:2.10.0\")\n    )\n</code></pre> It results in : <pre><code>Declared Compile Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:NONE\n  javax.servlet:javax.servlet-api:4.0.1\n\nDeclared Runtime Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n\nDeclared Test Dependencies : 4 elements.\n  org.mockito:mockito-core:2.10.0\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n  javax.servlet:javax.servlet-api:4.0.1\n</code></pre> Dependencies without any transitivity specified on, will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies.</p> <p>The API allows to redefine the transitivity declared in a upper dependency set.</p> <p>Note that transitivity can only apply to <code>JkModuleDependency</code> (like com.google.guava:guava:23.0) and <code>JkLocalProjectDependency</code>.</p>"},{"location":"legacy/reference-guide/build-library/#resolve-dependencies","title":"Resolve Dependencies","text":"<p>The <code>JkDependencyResolver</code> class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning <code>JkResolveResult</code> from a <code>JkdependencySet</code>.</p> <pre><code>JkDependencySet deps = JkDependencySet\n                            .of(\"org.apache.httpcomponents:httpclient:4.5.3\")\n                            .andFile(\"libs/my.jar\");\n\n// Here, module dependencies are fetched from Maven central repo\nJkDependencyResolver resolver = JkDependencyResolver.of(JkRepo.ofMavenCentral());  \nJkResolveResult result = resolver().resolve(deps);\n</code></pre> <p>From the result you can :</p> <ul> <li>Navigate in the resolved dependency tree as :</li> </ul> <pre><code>JkDependencyNode slfjApiNodeDep = result.getDependencyTree().getFirst(JkModuleId.of(\"org.slf4j:slf4j-api\"));\nSystem.out.println(slfjApiNode.getModuleInfo().getResolvedVersion());\n</code></pre> <ul> <li>Get the direct list of artifact files</li> </ul> <pre><code>JkPathSequence sequence = result.getFiles();  \nsequence.forEach(System.out::println); // print each files part of the dependency resolution\n</code></pre>"},{"location":"legacy/reference-guide/build-library/#publication","title":"Publication","text":"<p>Jeka is able to publish on both Maven and Ivy repository. This includes repositories as Sonatype Nexus.</p> <p>Maven and Ivy have different publication model, so Jeka proposes specific APIs according you want to publish on a Maven or Ivy repository.</p>"},{"location":"legacy/reference-guide/build-library/#publish-to-a-maven-repository","title":"Publish to a Maven repository","text":"<p>Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according provided elements.</p> <p>The following snippet demonstrate a pretty sophisticated publishing on Maven :</p> <pre><code>    JkVersionedModule versionedModule = JkVersionedModule.of(\"org.myorg:mylib:1.2.6\");\n    JkDependencySet deps = JkDependencySet.of()\n            .and(\"org.slf4j:slf4j-simple\", COMPILE_AND_RUNTIME)\n            .and(\"junit:junit:4.11\", TEST);\n    JkMavenPublication mavenPublication = JkMavenPublication.of(Paths.get(\"org.myorg.mylib.jar\"))\n\n            // the following are optional but required to publish on public repositories.\n            .and(Paths.get(\"org.myorg.mylib-sources.jar\"), \"sources\")\n            .and(Paths.get(\"org.myorg.mylib-javadoc.jar\"), \"javadoc\")\n            .withChecksums(\"sha-2\", \"md5\")\n            .withSigner(JkPgp.of(Paths.get(\"myPubring\"), Paths.get(\"mySecretRing\"), \"mypassword\"))\n            .with(JkMavenPublicationInfo.of(\"My sample project\",\n                    \"A project to demonstrate publishing on Jeka\",\n                    \"http://project.jeka.org\")\n                    .andApache2License()\n                    .andDeveloper(\"djeang\", \"myemail@gmail.com\", \"jeka.org\", \"http://project.jeka.org/\"));\n\n    // A complex case for repo (credential + signature + filtering) \n    JkRepo repo = JkRepo.of(\"http://myserver/myrepo\")\n            .withOptionalCredentials(\"myUserName\", \"myPassword\")\n            .with(JkRepo.JkPublishConfig.of()\n                        .withUniqueSnapshot(false)\n                        .withNeedSignature(true)\n                        .withFilter(mod -&gt; // only accept SNAPSHOT and MILESTONE\n                            mod.getVersion().isSnapshot() || mod.getVersion().getValue().endsWith(\"MILESTONE\")\n                        ));\n\n    // Actually publish the artifacts\n    JkPublisher publisher = JkPublisher.of(repo);\n    publisher.publishMaven(versionedModule, mavenPublication, deps);\n</code></pre> <p>Notice that Jeka allows to :</p> <ul> <li>Publish more than one artifact.</li> <li>Produce &amp; publish checksum files for each published artifact.</li> <li>Mention to use unique snapshot (What is it ?).</li> <li>Feed generated pom with data necessary to publish on central repository.</li> <li>Sign published artifact with PGP</li> <li>Publish to multiple repository by creating the publisher using a <code>JkRepoSet</code> instead of a <code>JkRepo</code>.</li> </ul> <p>To sign with PGP, no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts.</p>"},{"location":"legacy/reference-guide/build-library/#publish-to-a-ivy-repository","title":"Publish to a Ivy repository","text":"<p>Publishing on Ivy repo is pretty similar than on Maven though there is specific options to Ivy.</p> <pre><code>    JkVersionedModule versionedModule = JkVersionedModule.of(\"org.myorg:mylib:1.2.6-SNAPSHOT\");\n    JkDependencySet deps = JkDependencySet.of()\n            .and(\"org.slf4j:slf4j-simple\", COMPILE_AND_RUNTIME)\n            .and(\"junit:junit:4.11\", TEST);\n\n    JkIvyPublication publication = JkIvyPublication.of(Paths.get(\"org.myorg.mylib.jar\"), \"master\")\n            .and(Paths.get(\"org.myorg.mylib-sources.jar\"));\n\n    JkRepo repo = JkRepo.ofIvy(Paths.get(\"ivyrepo\"));\n\n    JkPublisher publisher = JkPublisher.of(repo);\n    publisher.publishIvy(versionedModule, publication, deps, JkJavaDepScopes.DEFAULT_SCOPE_MAPPING,\n            Instant.now(), JkVersionProvider.of());\n</code></pre>"},{"location":"legacy/reference-guide/build-library/#project-building","title":"Project Building","text":"<p>Jeka features high-level and low-level classes to deal with Java builds and JVM concepts.</p>"},{"location":"legacy/reference-guide/build-library/#java-tool-base-api","title":"Java Tool Base API","text":"<p>Base classes are used as foundation for implementing Jeka high-level build API but they can be used directly in a low level build description. These classes belong to <code>dev.jeka.core.api.java</code> package.</p> <ul> <li> <p><code>JkClassLoader</code> and <code>JkUrlClassloader</code> Wrap a <code>java.lang.ClassLoader</code> adding convenient methods and classpath scanning capability.</p> </li> <li> <p><code>JkJarPacker</code> A simple utility tyo create Jar or fat Jar file from compiled classes.</p> </li> <li> <p><code>JkJavaCompiler</code> Wraps either a Java Compiler tool, nor a javac process.</p> </li> <li> <p><code>JkJavadocProcessor</code> A Java source processor producing standard Javadoc</p> </li> <li> <p><code>JkJavaProcess</code> A utility to launch Java process (from class dirs or jars)</p> </li> <li> <p><code>JkManifest</code> Stands for the manifest file to include in jar files.</p> </li> </ul>"},{"location":"legacy/reference-guide/build-library/#testing-api","title":"Testing API","text":"<p>Jeka features a simple yet powerful API to launch tests. It relies entirely on JUnit5. This means that any test framework supported by Junit5 platform.</p> <p>Jeka testing API mostly hides Junit Platform. For most of the cases, you won't need to code against Junit-Platform API to launch tests with Jeka. Nevertheless, Jeka allows users to code against Junit-Platform for fine-tuning.</p> <p>The API classes all belongs to <code>dev.jeka.core.api.java.testing</code> package.</p> <ul> <li><code>JkTestProcessor</code> This is the entry point to launch tests. Tests are executed using the   current classloader classpath + extra class path mentioned in <code>#launch</code> method arguments.</li> <li><code>JkTestResult</code> The result of a test launch : count for found, failure, skip, success ...</li> <li><code>JkTestSelection</code> A mean to determine which test to launch. It can be set using file or tag filter. It is   also possible to code against JUnit Platform</li> </ul>"},{"location":"legacy/reference-guide/build-library/#project-api","title":"Project API","text":"<p>This is the Jeka high-level API to build Java/JVM projects. API classes belong to  <code>dev.jeka.core.api.project</code> package.</p> <p>It introduces the concept of <code>JkProject</code> from where is performed compilation, testing, resources processing, packaging, publication and more. <code>JkProject</code> is the root of a deep structure embracing the parent-chaining pattern for readability.</p> <p>The API contains a lot of extension points to add specific behaviors.</p> Project API structure <pre><code>project\n+- baseDir\n+- outputDir\n+- artifactProducer (define artifacts to be produce by the build as map of artifactName -&gt; Consumer&lt;Path&gt; producing the artifact)\n+- duplicateDependencyConflictStrategy\n+- construction  (Produce packaged binaries from sources. This includes test checking)\n|  +- jvmTargetVersion\n|  +- sourceEncoding\n|  +- javaCompiler\n|  +- dependencyResolver\n|  +- runtimeDependencies\n|  +- manifest\n|  +- fatJar (customize produced fat/uber jar if any)\n|  +- compilation  (produce individual binary files from production sources. This includes resource processing, code generation, transpiling, post binary processing, ...)\n|  |  +- layout (where are located source and resource files)\n|  |  +- dependencies   (stands for compile dependencies)\n|  |  +- preCompileActions (including resources processing)\n|  |  +- compileActions (including java sources compilation. Compilation for other languages can be added here)\n|  |  +- postCompileActions\n|  |  +- methods : resolveDependencies(), run()\n|  +- testing\n|  |  +- compilation (same as above 'compilation' but for test sources/resources)\n|  |  |  +- layout\n|  |  |  +- dependencies (stands for test dependencies)\n|  |  |  + ...\n|  |  +- breakOnFailure (true/false)\n|  |  +- skipped (true/false)\n|  |  +- testProcessor\n|  |  |  +- forkedProcess (configured the forked process who will run tests)\n|  |  |  +- preActions\n|  |  |  +- postActions\n|  |  |  +- engineBehavior\n|  |  |  |  +- progressDisplayer\n|  |  |  |  +- launcherConfiguration (based on junit5 platform API)\n|  |  |  +- testSelection\n|  |  |  |  +- includePatterns\n|  |  |  |  +- includeTags\n|  |  +- method : run()\n|  +- methods : createBinJar(), createFatJar(), resolveRuntimeDependencies(), getDependenciesAsXml()\n|  +            includeLocalDependencies(), includeTextDependencies()            \n+- documentation (mainly procude javadoc and source jar)\n|  +- javadocConfiguration\n|  +- methods : createJavadocJar(), createSourceJar(), run()\n+- publication (define information about module and artifacts to be published)\n|  +- moduleId (group:name)\n|  +- version\n|  +- maven (maven specific information to be published in a Maven Repositoty)\n|  |  +- dependencyCustomizer (customize the dependencies to be published)\n|  |  +- mavenSpecificInfo\n|  |  +- methods : publish\n|  +- ivy (Ivy specific information to be published in a Ivy Repositoty)\n|  |  +- dependencyCustomizer (customize the dependencies to be published)\n|  |  +- ivySpecifictInfo\n|  |  +- method : publish()\n|  +- methods : publish(), getVersion(), getModuleId()\n+ methods : getArtifacctPath(artifactName), toDependency(transitivity), getIdeSupport(), pack()\n</code></pre> <p>For simplicity\u2019s sake, <code>JkProject</code> provides a facade in order to setup common settings friendly, without navigating deep into the structure. From facade, you can setup dependencies, java version, project layout, test behavior, test selection and publication.</p> <pre><code>JkProject.of().simpleFacade()\n   .configureCompileDeps(deps -&gt; deps\n           .and(\"com.google.guava:guava:21.0\")\n           .and(\"com.sun.jersey:jersey-server:1.19.4\")\n           .and(\"org.junit.jupiter:junit-jupiter-engine:5.6.0\"))\n   .configureRuntimeDeps(deps -&gt; deps\n           .minus(\"org.junit.jupiter:junit-jupiter-engine\")\n           .and(\"com.github.djeang:vincer-dom:1.2.0\"))\n   .configureTestDeps(deps -&gt; deps\n           .and(\"org.junit.vintage:junit-vintage-engine:5.6.0\"))\n   .addTestExcludeFilterSuffixedBy(\"IT\", false)\n   .setJavaVersion(JkJavaVersion.V8)\n   .setPublishedModuleId(\"dev.jeka:sample-javaplugin\")\n   .setPublishedVersion(\"1.0-SNAPSHOT\");\n</code></pre> <p>If facade is not sufficient for setting up project build, it's still possible to complete through the main API. <code>JkProject</code> instances are highly configurable.</p> <p>Here is a pretty complete example inspired from the Jeka Build Class .</p>"},{"location":"legacy/reference-guide/build-library/#third-party-tool-integration","title":"Third Party Tool Integration","text":"<p>The <code>dev.jeka.core.api.tooling</code> package provides integration with tools developers generally deal with.</p>"},{"location":"legacy/reference-guide/build-library/#eclipse","title":"Eclipse","text":"<p><code>JkEclipseClasspathGenerator</code> and <code>JkEclipseProjectGenerator</code> provides method to generate a proper .classpath and .project file respectively.</p> <p><code>JkEclipseClasspathApplier</code> reads information from a .classpath file.</p>"},{"location":"legacy/reference-guide/build-library/#intellij","title":"Intellij","text":"<p><code>JkIntellijImlGenerator</code> generates proper .iml files.</p>"},{"location":"legacy/reference-guide/build-library/#git","title":"Git","text":"<p><code>JkGitWrapper</code> wraps common Git commands in a lean API.</p>"},{"location":"legacy/reference-guide/build-library/#maven","title":"Maven","text":"<p><code>JkMvn</code> wraps Maven command line in a lean API</p> <p><code>JkPom</code> reads POM/BOM to extract information like : declared dependencies, dependency management, repos, properties, version and artifactId.</p>"},{"location":"legacy/reference-guide/execution-engine-defclasspath/","title":"Execution engine defclasspath","text":""},{"location":"legacy/reference-guide/execution-engine-defclasspath/#def-classes","title":"Def classes","text":"<p>Def classes are the compilation results of Java/Kotlin source files located in jeka/def.  The execution engine compiles these files on the fly prior adding them to the Jeka classpath.</p> <p>It is possible to specify compilation options by annotating a def class as :</p> <pre><code>@JkCompileOption(\"-deprecation\")\n@JkCompileOption({\"-processorPath\", \"/foo/bar\"})\nclass MyBuild extends JkBean {\n  ...\n}\n</code></pre> <p>Note</p> <ul> <li>jeka/def can also contain classpath resources.</li> <li>Classes with names starting with <code>_</code> are skipped from compilation.</li> </ul> <p>Java source files definded in def dir are compiled using the running JDK.</p> <p>Kotlin sources are compiled using Kotlin versions specified by <code>jeka.kotlin.version</code> property if present or  using Kotlin compilers specified by KOTLIN_HOME environment variable. </p>"},{"location":"legacy/reference-guide/execution-engine-defclasspath/#jeka-classpath","title":"Jeka Classpath","text":"<p>Under the hood, Jeka simply executes Java byte code within a flat classloader. This classloader classpath is constructed from :</p> <ul> <li>jar files present in jeka/boot dir</li> <li>dependencies injected via the command line and annotations</li> <li>compiled def classes</li> <li>Jeka classpaths from imported projects</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-defclasspath/#injected-dependencies","title":"Injected Dependencies","text":"<p>It's possible to transitively inject dependencies into classpaths by either annotating def classes or by mentionning it in command line.</p> <p>Note</p> <p>By default, jeka fetches dependencies from maven central (https://repo.maven.apache.org/maven2).</p> <p>You can select another default repository by setting the <code>jeka.repos.download.url</code> property.  We recommend storing this value in your [USER DIR]/.jeka/global.properties file to be reused across projects.</p> <p>For more details, see <code>JkRepoFromOptions</code> javadoc.</p>"},{"location":"legacy/reference-guide/execution-engine-defclasspath/#inject-from-def-classes","title":"Inject from Def Classes","text":"<p>Annotate a def class with <code>@JkDep</code> mentioning either a module coordinate or a path on the local file system.</p> <pre><code>@JkDep(\"org.seleniumhq.selenium:selenium-remote-driver:4.0.0\")\n@JkDep(\"../libs/myutils.jar\")\nclass MyBuild {\n  ...\n}\n</code></pre> <p>Note</p> <p>Update your IDE dependencies right after adding this annotation in order for it to be  used inside your def classes. <code>jeka intellij#iml</code> or <code>jeka eclipse#files</code></p> <p>Warning</p> <p>Dependencies imported via <code>@JkDep</code> are imported for all def classes and not only for the annotated class.</p>"},{"location":"legacy/reference-guide/execution-engine-defclasspath/#inject-from-command-line","title":"Inject from Command Line","text":"<p>Specify path or module coordinates in the command line using '@' as <code>@my.org:a-jeka-plugin:1.0.0</code> or <code>@../libs/myutils.jar</code>.</p> <p>This feature is meant to dynamically invoke KBeans.</p>"},{"location":"legacy/reference-guide/execution-engine-defclasspath/#imported-projects","title":"Imported Projects","text":"<p>Jeka supports multi-module projects. Jeka classpath of a given project can include Jeka classpath of another one.</p> <p><pre><code>@JkInjectProject(\"../core\")\nclass MyBuild extends JkBean {\n  ...\n}\n</code></pre> Now, classes from project '../core' can be reused in this build class.</p>"},{"location":"legacy/reference-guide/execution-engine-files/","title":"Execution engine files","text":"<p>The execution engine allows the execution of an arbitrary Java/Kotlin method from the command line or from an IDE. Methods are declared in regular Java/Kotlin classes. </p> <p>Build classes (called kbeans) can either be defined as source files or provided as binaries by external libs.</p>"},{"location":"legacy/reference-guide/execution-engine-files/#project-structure","title":"Project Structure","text":"<p>Every Jeka execution takes place in the context of a project. A Jeka project is a folder  structure containing a 'jeka' directory at its root. Executions must be launched from the project root directory.</p> <p>All the following files or directories are optional except the jeka directory.</p> <pre><code>Project Base Directory\n+- jekaw\n+- jekaw.bat\n+- jeka\n|  +- local.properties\n|  +- boot\n|  |  +- somelibs.jar\n|  +- def\n|  |  +- SomeBuild.java\n|  |  +- SomeUtils.java\n|  |  +- ...\n|  +- wrapper\n|  |  +- dev.jeka.core-wrapper.jar\n|  |  +- wrapper.properties\n|  +- output\n|  |  +- ...        \n|  +- .work\n|  |  +- ...\n+- ... (project specific files like src/main/java, src/test/java, ...)\n</code></pre>"},{"location":"legacy/reference-guide/execution-engine-files/#jeka-directory-content","title":"Jeka Directory Content","text":"<p>By convention, every project automated or built by Jeka contains a jeka directory at its root ([Project Root]/jeka).  This directory contains everything that Jeka needs to automate or build the project.</p> <p>In this directory, you may find :</p> <ul> <li>def (directory - optional) : User Java and/or Kotlin sources that will be executed by the execution engine.</li> <li>output (directory - generated) : Files produced by the tasks (jar files, classes, test reports, doc, ...)</li> <li>boot (directory - optional) : Third-party jar files that users may add to be used by code located in def.</li> <li>wrapper (directory - optional) : Wrapper jar file for bootstrapping a specified version of Jeka.</li> <li>.work (directory - generated): Temp files generated by the Jeka execution engine as compiled classes from def. These files are used as a local cache to speed-up Jeka bootstraping and can be deleted safely.</li> <li>local.properties (file - optional) : Contains properties defined at project level, such as java version.</li> </ul> <p>Project root may also contain jekaw and jekaw.bat shell scripts to invoke Jeka wrapper conveniently.</p> <p>For the following, when we refer to the command <code>jeka</code>, you can use <code>./jekaw</code> indifferently. All command lines must be launched from the root of the project (and not from [Project Root]/jeka).</p> <p>Note</p> <p>When generating a project using a scaffold mechanism, these files are created with explanations in their bodies.</p>"},{"location":"legacy/reference-guide/execution-engine-files/#jeka-wrapper","title":"Jeka Wrapper","text":"<p>Jeka wrapper consists of shell scripts, a thin booting jar, and a configuration file in order for Jeka to be executed on a specified  version without being installed on the host machine. This is the recommended way of using Jeka as it makes builds portable from one machine to another.</p> <ul> <li>jekaw and jekaw.bat use Unix like and Windows scripts respectively, to launch the bootstrapping jar.</li> <li>jeka/wrapper/dev.jeka.core-wrapper.jar is the bootable jar in charge of downloading and installing the specified Jeka    version on the host machine prior to launch Jeka</li> <li>jeka/wrapper/wrapper.properties specifies the Jeka version to be used.</li> </ul> <p>When Jeka wrapper is installed on a project, execute <code>jekaw</code> instead of <code>jeka</code>. </p>"},{"location":"legacy/reference-guide/execution-engine-files/#jeka-user-directory","title":"Jeka User Directory","text":"<p>Jeka automatically creates a directory  [User Home]/.jeka when running for the first time. This directory may contain :</p> <ul> <li>global.properties (file - optional) : Properties defined at the global level (see later section).</li> <li>cache (directory - generated) : Various files cached by Jeka as downloaded files, specifically dependency artifacts. This directory can be safely deleted.</li> <li>maven_publish_dir (directory - generated) : Contains artifacts that your projects have published locally respecting Maven repository standards</li> <li>ivy_publish_dir (directory - generated) : Contains artifacts that your projects have published locally respecting Ivy repository standards</li> </ul> <p>In the contrary of Maven, Jeka does not publish locally on the same repository where there are downloaded dependency artifacts.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/","title":"Execution engine kbeans","text":""},{"location":"legacy/reference-guide/execution-engine-kbeans/#kbeans","title":"KBeans","text":"<p>KBean is the central concept of the execution engine. KBeans are classes with declared executable methods.  There is only one KBean instance by KBean class in any given Jeka project (JkRuntime).</p> <p>KBean classes share the following characteristics :</p> <ul> <li>They extend <code>KBean</code> class.</li> <li>They may declare <code>public void</code> methods without taking any arguments. All these methods can be invoked from the command line.</li> <li>They may declare <code>public</code> fields (aka KBean properties). These field values can be injected from the command line.   These can also be non-public fields annotated with <code>@JkDoc</code>.</li> <li>They must provide a no-arg constructor</li> <li>They may override <code>init()</code> method</li> <li>They must be instantiated by the execution engine and not from the user code. </li> </ul>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#simple-example","title":"Simple Example","text":"<p>The following KBeans expose the <code>cleanPublish</code> method which delegates the creation of jar files to the 'project' KBean. <code>ProjectKBean</code> is available on the Jeka classpath as it is part of the standard KBeans bundled in the JeKa distribution.</p> <pre><code>import dev.jeka.core.api.project.JkProject;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\npublic class SimpleJkBean extends KBean {\n\n    final ProjectKBean projectKBean = load(ProjectKBean.class);  // Instantiate KBean or return singleton instance.\n\n    @Override  \n    protected void init() {  // When init() is invoked, projectKBean field instances has already been injected.\n        projectKBean.project.simpleFacade()\n                .addCompileDeps(\n                        \"com.google.guava:guava:30.0-jre\",\n                        \"com.sun.jersey:jersey-server:1.19.4\"\n                )\n                .addTestDeps(\n                        \"org.junit.jupiter:junit-jupiter:5.8.1\"\n                );\n    }\n\n    @JkDoc(\"Clean, compile, test, create jar files, and publish them.\")\n    public void cleanPublish() {\n        projectKBean.cleanPack();\n        projectKBean.publishLocal();\n    }\n\n}\n</code></pre>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#kbean-commands","title":"KBean Commands","text":"<p>A KBean command is an instance method of a KBean class that can be invoked from the command line. In order to be considered as a command, a method must :</p> <ul> <li>be <code>public</code></li> <li>be an instance method</li> <li>take no argument</li> <li>return <code>void</code></li> </ul>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#kbean-attributes","title":"KBean Attributes","text":"<p>A KBean attribute is a <code>public</code> instance field of a KBean class. Its value can be injected from the command line,  or from property file.  It can be also non-public fields annotated with <code>@JkDoc</code>.</p> <p>Attributes can be annotated with <code>@JkInjectProperty(\"my.prop.name\")</code> to inject the value of a property within.</p> <p>For more details on field accepted types, see <code>dev.jeka.core.tool.FieldInjector#parse</code> method.</p> <p>KBean properties can also be nested composite objects, see example in <code>ProjectKBean#pack</code> field.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#naming-kbeans","title":"Naming KBeans","text":"<p>In order to be referenced conveniently, KBeans can be called by names. For any given JkBean class, accepted names are :</p> <ol> <li>Full qualified class name</li> <li>Uncapitalized simple class name (e.g. 'myBuild' matches 'org.example.MyBuild')</li> <li>Uncapitalized simple class Name without 'JkBean' suffix (.g. 'project' matches 'dev.jeka.core.tool.builtin.project.ProjectKBean')</li> </ol> <p>Tip</p> <p>Execute <code>jeka</code>, at the root of a project to display KBeans present in Jeka classpath.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#document-kbeans","title":"Document KBeans","text":"<p>KBean classes, methods, and properties can be annotated with <code>@JkDoc</code> annotation in order to provide self documentation.</p> <p>Text within these annotations is displayed when invoking <code>help</code> method on the console.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#invoke-kbeans","title":"Invoke KBeans","text":""},{"location":"legacy/reference-guide/execution-engine-kbeans/#from-command-line","title":"From Command Line","text":"<p>KBean methods can be invoked from the command line using </p> <p><code>jeka [kbeanName]#methoName [kbeanName]#[propertyName]=xxx</code> </p> <p>Many methods/properties can be invoked in a single command line.</p> <p>Info</p> <p>[kbeanName] prefix can be omitted. By default, it will be resolved on the bean mentioned by the -kb= option,  or the first KBean found in def dir, if the option is not present.  Search is executed by alphabetical order of fully qualified class names.  Example : <code>jeka #toSomething #aProperty=xxxx</code> It is also possible to refer to the default KBean by using kb# prefix in place of #. Example : <code>jeka kb#toSomething kb#aProperty=xxxx</code></p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#from-intellij-jeka-plugin","title":"From IntelliJ Jeka Plugin","text":"<p>[IntelliJ Jeka Plugin] allows the invocation of methods directly from the editor or the explorer tool window.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#from-naked-ide","title":"From naked IDE","text":"<p>KBean methods can also be launched/debugged from IDE using classic <code>main</code> methods.</p> <p>In KBean class, declare one or several main methods as :</p> <p><pre><code> public static void main(String[] args) {\n        JkInit.instanceOf(MyBuild.class, args).cleanPack();\n    }\n\n  public static class Release {\n      public static void main(String[] args) {\n          JkInit.instanceOf(MyBuild.class, args, \"-runIT\").release();\n      }\n  }\n</code></pre> KBean must be instantiated using <code>JkInit#instanceOf</code> in order for it to be set up properly. </p> <p>The arguments passed in the <code>main</code> method are interpreted as command line arguments.</p> <p>Launching or debugging this way is performant as all build classes and their dependencies are already on classpath. Therefore, no compilation or dependency resolution is needed.</p> <p>Warning</p> <p>Be careful to launch the main method using module dir as working dir. On IntelliJ, this is not the default (it uses project dir).</p> <p>To change intelliJ defaults, follow : Edit Configurations | Edit configuration templates... |  Application | Working Directory : $MODULE_DIR$.</p> <p>Sometimes, you may need to mimic the command line behavior more closely, for debugging purposes or to pass '@' arguments.</p> <ul> <li>Create an IDE launcher for a Java Application</li> <li>Set <code>dev.jeka.tool.Main</code> as Java main class.</li> <li>Set the same command line arguments as you would do for invoking from command line (Do not include jeka command).</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#let-kbeans-cooperate","title":"Let KBeans cooperate","text":"<p>Generally KBeans interact with each other by declaring KBeans using <code>KBean#load(MyBean.class)</code> method as shown in this example.</p> <p>When a KBean depends on another one, it's good to declare it as an instance field of the first bean, as this  dependency will be mentioned in the auto-generated documentation and showed explicitly in IDE tool.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#kbeans-in-multi-projects","title":"KBeans in Multi-Projects","text":"<p>In a multi-project, it's quite common that a KBean accesses a KBean instance from another project.  You can achieve this in a statically typed way.</p> <ul> <li>In master KBean, declare a field of type <code>KBean</code> (e.g. \u00b4JkBean importedBuild;`). It doesn't have to be public.</li> <li>Annotate it with <code>@JkInjectProject</code> mentioning the relative path of the imported project (e.g. `@JkInjectProject(\"../anotherModule\")).</li> <li>Execute <code>jeka intellij#iml</code> or <code>jeka eclipse#files</code>.</li> <li>Redefine the declared type from <code>KBean</code> to the concrete type of imported KBean</li> <li>Now, master KBean can access the imported KBean in a static typed way.</li> <li>See example here.</li> <li>Be mindful that the imported KBean must deal with file paths using <code>KBean#getBaseDir</code> in order for it to be safely executed from any working directory.</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#bundled-kbeans","title":"Bundled KBeans","text":"<p>There are a bunch of KBeans bundled within Jeka. Those KBeans are always present.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#project","title":"project","text":"<p><code>ProjectKBean</code> provides a wrapper around a <code>JkProject</code> for building JVM-based projects. This KBean initialises  a default sensitive project object and provides a classic method for building a project (compile, package in jar, publish ...)</p> <p>This KBean proposes an extension point through its <code>configure(JkProject)</code> method. This way, other KBeans can  modify the properties of the project to be built.</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#intellij","title":"intellij","text":"<p><code>IntellijKBean</code> provides methods for generating metadata files for IntelliJ IDE. The content of an iml file is computed  according the <code>JkProject</code> object found in project KBean.</p> <p>This KBean proposes an extension point through its <code>configure</code> methods in order to modify the resulting iml (e.g. using a module dependency instead of a library dependency).</p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#scaffold","title":"scaffold","text":"<p><code>ScaffoldjKBean</code> provides methods for project directories and files to create a new Jeka project. Basically,  it creates a project ready to create vanilla automation tasks.</p> <p>This KBean offers an extension point in order for another KBean to augment the scaffolded structure. For example,  executing <code>jeka scaffold#run</code> will create a basic Jeka project while <code>jeka scaffold#run project#</code> will create  a project ready to build a JVM-based project. </p>"},{"location":"legacy/reference-guide/execution-engine-kbeans/#git","title":"git","text":"<p><code>GitKBean</code> exposes some common git command combos. It can also auto-inject a version inferred from Git into project KBean.</p>"},{"location":"legacy/reference-guide/execution-engine-process/","title":"Execution engine process","text":"<p>Jeka follows a specific process before invoking KBean methods :</p> <ol> <li>Parse command line and set arguments specified as -Dxxx=yyy as system properties.</li> <li>Set [project dir] = current working dir</li> <li>Augment the current classloader with jar files found in [project dir]/jeka/boot </li> <li>Augment the current classloader with resolved coordinates mentionned in command line as @group:name:version</li> <li>Parse source files contained in project dir/jeka/def<ol> <li>Detect <code>@JkInjectProject</code> annotations. For each : <ol> <li>Set [project dir] to value declared in annotation</li> <li>Process steps 3, 4, 5, 6 for the injected project</li> </ol> </li> <li>Augment the current classloader with dependencies declared in source files</li> </ol> </li> <li>Compile files in [project dir]/def/jeka and augment current classloader with compiled files</li> <li>If the compilation fails and the command-line option <code>-dci</code> is present, ignore it.</li> <li>Scan classloader classpath to find KBeans and associate each KBean referenced in the    command line.</li> <li>Identify the default KBean if available. The default KBean is the first class found     in [project dir]/jeka/def extending <code>JkBean</code>.</li> <li>Instantiate the default KBean. Instantiate means :<ol> <li>Invoke no-arg constructor</li> <li>Inject KBean properties mentioned in command line</li> </ol> </li> <li>Instantiate other KBean, if not yet done by order they appear in the command line.</li> </ol> <p>Once KBeans have been instantiated, KBean methods are executed in the order in which they appear in the command line.</p> <p>Info</p> <p>There is only one KBean instance by KBean class and by project.</p> <p>Info</p> <p><code>JkRuntime</code> is the KBean container for a given project. Each KBean instance   belongs to a <code>JkRuntime</code>. From <code>JkRuntime</code>, you can access other KBeans   from the same or other projects.</p>"},{"location":"legacy/reference-guide/execution-engine-properties/","title":"Execution engine properties","text":""},{"location":"legacy/reference-guide/execution-engine-properties/#properties","title":"Properties","text":"<p>Properties are pairs of String  key-value that are used across Jeka system. They typically carry urls, local paths, tool versions, or credentials. </p> <p>Properties can be defined at different levels, in order of precedence :</p> <ul> <li>System properties : Properties can be defined using system properties as <code>-DpropertyName=value</code>. System properties can   be injected from the Jeka command line.</li> <li>OS environment variables : Properties can also be defined as OS environment variables.</li> <li>Project : Defined in [Project Root]/jeka/local.properties. Typically used to store tool versions (e.g. <code>jeka.kotlin.version=1.5.21</code>).</li> <li>Global : Defined in the [User Home]/.jeka/global.properties file. Typically used to define urls, local paths, and credentials.</li> </ul> <p>Properties inherit from project properties defined in project parent folders (if extant). </p> <p>Here, project2 will inherit properties defined in project1/jeka/local.properties : <pre><code>project1\n   + jeka\n      + local.properties\n   + project2   (sub-project)\n      + jeka\n         + local.properties\n</code></pre></p> <p>Info</p> <p>Properties support interpolation via <code>${}</code>tokens. </p> <p>For example, if we define the following properties : <code>foo=fooValue</code> and <code>bar=bar ${foo}</code> then <code>JkProperties.get(\"bar\")</code> will return 'bar fooValue'.</p>"},{"location":"legacy/reference-guide/execution-engine-properties/#standard-properties","title":"Standard properties","text":"<ul> <li><code>jeka.jdk.X=</code> location of the JDK version X (e.g. jeka.jdk.11=/my/java/jdk11). It is used to compile projects when    project JVM target version differs from Jeka running version.</li> <li><code>jeka.kotlin.version</code> : Version of Kotlin used to compile both def and Kotlin project sources.</li> <li><code>jeka.java.version</code> :  Target JVM version for compiled files.</li> <li><code>jeka.classpath.inject</code>: Additional dependencies that will be added to the JeKa classpath.     We can specify many dependencies separated by <code>&lt;space&gt;</code>.    It can be either Maven coordinates or file paths. If a file path is relative, it is resolved     upon project base dir (could be distinct from working dir).    Example : <code>jeka.classpath.inject=dev.jeka:springboot-plugin  com.google.guava:guava:31.1-jre ../other-project/jeka/output/other-project.jar</code></li> <li><code>jeka.kbean.default</code>: The KBean to use when omitting mentioning KBean prefix (or using <code>kb#</code> prefix) in command or field assignment.    Example: declaring <code>jeka.kbean.default=myBean</code>, makes the following expressions equivalent : <code>myBean#run</code>, <code>#run</code>, and <code>kb#run</code>.</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-properties/#command-shorthands","title":"Command shorthands","text":"<ul> <li><code>jeka.cmd.xxx=</code> define an alias that can be substituted for its value in the command line using the <code>:</code> symbol.     Example : <code>jeka.cmd.myBuild=${jeka.cmd.build} sonarqube#run jacoco#</code> allows you to simply execute <code>jeka :myBuild</code>.</li> <li><code>jeka.cmd._append=</code> will append the argument to every Jeka execution command.    Example : <code>jeka.cmd._append=@dev.jeka:springboot-plugin</code> will add springboot plugin to Jeka classpath for each execution.    This properties can be splitted when argument line becomes to long. In fact, every properties starting with <code>jeka.cmd._append</code> will     be taken in account to assemble the extra command line arguments. For example, we can define <code>jeka.cmd._append.0=</code>, <code>jeka.cmd._append.1=</code>, and so on.</li> </ul> <p>Note</p> <p>Command shorthands are a really powerful mechanism for getting rid of build classes. Many projects can be built using properties only !</p>"},{"location":"legacy/reference-guide/execution-engine-properties/#repositories","title":"Repositories","text":"<p>The repositories used to download and publish artifacts can be defined using properties. The download repositories are set using the <code>jeka.repos.download</code> property, while the publish repository is defined using <code>jeka.repos.publish</code>.</p> <p>Use JkRepoFromProperties class to get the repositories defined by properties.</p> <p>Note</p> <p>By default, when no repository is configured, artifacts are downloaded on Maven Central repo.</p> <p>Using single repo <pre><code>jeka.repos.download=https://my.company/repo\n</code></pre></p> <p>Using multiple repos <pre><code>jeka.repos.download=https://my.company/repo1, file://path/to/a/local/repo \n</code></pre></p> <p>Using single repo with credentials <pre><code>jeka.repos.download=https://my.company/repo\njeka.repos.download.username=myUsername\njeka.repos.download.password=myPassword\n</code></pre></p> <p>Specifying http headers to include in each request towards the repo <pre><code>jeka.repos.download.headers.my-header-name=myHeaderValue\njeka.repos.download.headers.another-header-name=anotherHeaderValue\n</code></pre></p> <p>For convenience, we can define multiple repositories and reference them using aliases <pre><code>jeka.repos.myRepo1=https://my.company/repo\njeka.repos.myRepo1.username=myUsername\njeka.repos.myRepo1.password=myPassword\n\njeka.repos.myRepo2=https://my.company/repo2\njeka.repos.myRepo2.username=myUsername2\njeka.repos.myRepo2.password=myPassword2\n\njeka.repos.download=myRepo1, myRepo2\njeka.repos.publish=myRepo2\n</code></pre></p> <p>Aliases are predefined for Maven Central and Jeka GitHub Repos <pre><code>jeka.repos.download=https://my.company/repo1, mavenCentral, jekaGithub\njeka.repos.jekaGithub.username=myGithubAccountName\njeka.repos.jekaGithub.password=myGithubPersonalAccessToken\n</code></pre></p>"},{"location":"legacy/reference-guide/execution-engine-properties/#kbean-field-value-injection","title":"KBean field value injection","text":"<p>If a property is named as <code>xxx#yyyyy</code> then Jeka will try to inject its value  in public field <code>yyyyy</code> of KBean <code>xxx</code>. </p> <p>examples: <pre><code>springboot#springbootVersion=2.4.7\nproject#test.skip=true\n</code></pre></p> <p>Note</p> <p>There is a slight difference between using <code>-Dproject#test.skip=true</code> and  <code>project#test.skip=true</code> in the command line. For the former, the field is injected via system properties, this means that for multi-modules projects, the value will be injected on every Jeka module. For the latter, the value will be injected only on the root module.</p>"},{"location":"legacy/reference-guide/execution-engine-reuse/","title":"Execution engine reuse","text":"<p>Jeka provides powerful and easy means to reuse build elements across projects.</p> <p>Elements can be reused as sources in a multi-project structure or exported as binaries in  order to be used as third-party dependencies to create a plugin ecosystem.</p>"},{"location":"legacy/reference-guide/execution-engine-reuse/#from-sources","title":"From Sources","text":"<p>In a multi-project (aka multi-module project), it is possible to use def classes defined in other sub-projects. When using <code>@JkInjectProject</code>, classes defined in ../sub-project-1/jeka/def and  in the classpath of sub-project-1.   </p> <pre><code>import dev.jeka.core.tool.JkBean;\n\n@JkInjectProject(\"../sub-project\")\nclass MyJkBean extends JkBean {\n\n}\n</code></pre> <p>In a KBean, it is possible to use a KBean coming from another project.</p> <pre><code>import dev.jeka.core.tool.JkBean;\n\nclass MyJkBean extends JkBean {\n\n    @JkInjectProject(\"../sub-project\")\n    private OtherJkBean importedBean;\n}\n</code></pre>"},{"location":"legacy/reference-guide/execution-engine-reuse/#from-binaries","title":"From Binaries","text":"<p>To extend Jeka capabilities, it's possible to create a jar file to be used in any Jeka project. An extension (or plugin) can contain KBean or not, and can have many purposes (such as integrating a specific technology,  predefining a set of dependencies, providing utiliy classes, etc.).</p> <p>To achieve this, we must create a project that packs and exports the library.</p> <p>The project may declare dependencies on Jeka : the simplest way is to add a dependency on the jeka jar that actually builds the project using <code>JkLocator.getJekaJarPath()</code>.</p> <pre><code>import dev.jeka.core.api.project.JkProject;\n\nclass Build extends JkBean {\n\n    ProjectJkBean projectBean = getBean(ProjectJkean.class).lately(this::configure);\n\n    private void configure(JkProject project) {\n\n        // Optional indication about Jeka version compatibility\n        JkJekaVersionCompatibilityChecker.setCompatibilityRange(project.getConstruction().getManifest(),\n                \"0.9.20.RC2\",\n                \"https://raw.githubusercontent.com/jerkar/protobuf-plugin/breaking_versions.txt\");\n\n        project.simpleFacade()\n                .configureCompileDeps(deps -&gt; deps\n                        .andFiles(JkLocator.getJekaJarPath())\n                );\n    }\n\n}\n</code></pre>"},{"location":"legacy/reference-guide/execution-engine-reuse/#check-jeka-version-compatibility","title":"Check Jeka Version Compatibility","text":"<p><code>JkJekaVersionCompatibilityChecker.setCompatibilityRange</code> insert information about Jeka version compatibility within the Manifest. This information will be used by Jeka to alert you if the library is marked as being incompatible with the running Jeka version.</p> <p>The method contains three arguments :</p> <ul> <li>The object standing for the Manifest file</li> <li>The lowest version of Jeka which is compatible with the library</li> <li>A url string pointing on a file mentioning the versions of Jeka that are no longer compatible   with the version of the library</li> </ul> <p>For the last of these, the information has to be stored outside the library itself as the author cannot guess which future version of Jeka will break the compatibility.</p> <p>An example of such a file is available here</p>"},{"location":"legacy/reference-guide/execution-engine-setup/","title":"Execution engine setup","text":"<p>To determine the JDK to run upon, jeka prioritizes the following, in order :</p> <ul> <li>JEKA_JDK environment variable ([JEKA_JDK]/bin/java must point on java executable)</li> <li>jeka.jdk.XX property definied in [JEKA_USER_DIR]/global.properties, if a jeka.java.version=XX property is defined in [PROJECT_ROOT]/jeka/local.properties file.</li> <li>JAVA_HOME environment variable </li> <li>java executable accessible from PATH environment variable.</li> </ul> <p>Note</p> <p>Jeka organization provides a plugin for IntelliJ in order to render the following tasks useless. </p> <p>Here, we'll focus only on how to do it using command line only.</p> <p>There are two ways of using jeka : by installing Jeka itself, or by using a project that already contains the Jeka wrapper.</p>"},{"location":"legacy/reference-guide/execution-engine-setup/#install-jeka-distribution","title":"Install Jeka Distribution","text":"<p>Note</p> <p>It is not required to install Jeka distribution to use it. If you fetch a project that already contains a wrapper, using <code>jekaw</code> will be enough. Nevertheless, if you want to create a project from scratch, installation will be necessary.</p> <ul> <li>Download the latest release here   and unpack the distrib.zip wherever you want on your machine. We'll refer to this directory as [JEKA HOME].</li> <li>Add [JEKA HOME] to your PATH environment variable.</li> <li>Now, you can use the <code>jeka</code> command from everywhere.</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-setup/#projects-with-jeka-wrapper","title":"Projects with Jeka Wrapper","text":"<p>There is no need to install Jeka to work a project already holding a Jeka wrapper:</p> <ul> <li>Fetch the project from its remote repository</li> <li>Use the <code>jekaw</code> command from the project root path.</li> </ul> <p>Note</p> <p>To start from an empty project, clone the blank project template from https://github.com/jerkar/jeka-wrapper-project-template.git</p>"},{"location":"legacy/reference-guide/execution-engine-setup/#setup-ide","title":"Setup IDE","text":"<ul> <li>Add an IDE path variable JEKA_USER_HOME pointing on [USER HOME]/.jeka. In Intellij :  Settings... | Appearance &amp; Behavior | Path Variables</li> <li>If you use <code>jeka</code> instead of <code>jekaw</code>, add an IDE path variable JEKA_HOME pointing on [JEKA HOME].</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-setup/#hello-world-project","title":"Hello World Project","text":"<p>For simplicity's sake, we'll use the basic example of displaying a message on the console.</p>"},{"location":"legacy/reference-guide/execution-engine-setup/#create-project-structure","title":"Create Project Structure","text":"<ul> <li>Create the root dir of the project or use the template wrapper project mentioned above. </li> <li>At project root, execute <code>jeka scaffold#run scaffold#wrapper</code> (or just <code>jekaw scaffold#run</code> if using the template wrapper project).</li> <li>Execute <code>jeka intellij#iml</code> or <code>jeka eclipse#files</code> in order to generate the IDE configuration file. </li> <li>The project with a Jeka structure and a basic build class is ready to work within your IDE</li> </ul>"},{"location":"legacy/reference-guide/execution-engine-setup/#create-a-jeka-method","title":"Create a Jeka Method","text":"<p>Jeka methods must be zero-args instance methods returning <code>void</code>. </p> <p>Modify the def/Build.java file to add the hello method as follows.</p> <pre><code>import dev.jeka.core.tool.JkBean;\nimport dev.jeka.core.tool.JkInit;\n\nclass Build extends JkBean {\n\n    public void hello() {\n        System.out.println(\"Hello world !\");\n    }\n\n    public static void main(String[] args) throws Exception {\n        Build build = JkInit.instanceOf(Build.class, args);\n        build.hello();\n    }\n\n}\n</code></pre> <p>Now, execute <code>jeka hello</code> to see the message displayed on the console.</p> <p>Optionally, you can also use the classical <code>main</code> method to launch it from the IDE.  </p>"},{"location":"legacy/reference-guide/execution-engine-setup/#get-contextual-help","title":"Get Contextual Help","text":"<p>Execute <code>jeka -h</code> (or <code>jeka -help</code>) to display contextual help on the console.</p> <p>Follow the instructions to navigate to more specific help.</p> <p>Warning</p> <p>Do not confuse <code>jeka -help</code> and <code>jeka #help</code>. The latter only provides documentation about the default KBean.</p>"},{"location":"legacy/reference-guide/execution-engine-setup/#customization","title":"Customization","text":"<p>For any reason, we might use different locations than the standard ones for Jeka User Home and Jeka Cache.</p> <p>We can change the location using the following OS environment variables :</p> <ul> <li><code>JEKA_USER_HOME</code> : to set the Jeka User Home to a specified location (absolute path).</li> <li><code>JEKA_CACHE_DIR</code> : to set the cache (mainly all downloaded files), to a specified location (absolute path)</li> </ul> <p>Or setting the following System properties :</p> <ul> <li><code>jeka.cache.dir</code> : to set the cache (mainly all downloaded files), to a specified location (absolute path)</li> </ul>"},{"location":"legacy/tutorials/gui-getting-started/","title":"Getting started with Jeka","text":""},{"location":"legacy/tutorials/gui-getting-started/#install-intellij-plugin","title":"Install Intellij Plugin","text":"<ul> <li>Install plugin directly from here or search jeka in Intellij Marketplace.</li> </ul> <p>As this plugin embeds its own version of Jeka, that's all we need to install on our machine.</p>"},{"location":"legacy/tutorials/gui-getting-started/#hello-world","title":"Hello World !","text":"<p>The below example showcases how to write tasks executable both from IDE and the  command line. </p> <ul> <li>Create a new Jeka project in Intellij : New &gt; Project ... &gt; Jeka </li> </ul> <p></p> <p>Leave default (we might change the name) and press Create.</p> <p>Note</p> <p>A Jeka structure (folders and files) can be created in an existing project of any type. On IntelliJ project window-tool : Select project &gt; Click Left &gt; Jeka ... &gt; Scaffold ...</p> <p></p> <p>We get a workable Jeka project from which we can :</p> <ul> <li>execute/debug methods from the IDE using editor gutter buttons or tool-windows explorer.</li> <li>navigate to discover available KBeans on this project, and their content.</li> <li>create Intellij run-configuration from existing methods</li> <li>execute methods directly in the terminal (e.g. <code>./jekaw #hello #name=Joe</code>)</li> <li>create new methods/fields. If they do not appear in the tool-window, use the top menu button to refresh view.</li> </ul>"},{"location":"legacy/tutorials/gui-getting-started/#import-3rd-party-libraries","title":"Import 3rd Party libraries","text":"<p>We can also import 3rd-party libraries to use in our build classes by using the <code>@JkDep</code>annotation.</p> <p>Libraries referenced with coordinates will come into classpath along with all their dependencies.</p> <p></p> <p>Do not forget to refresh iml explicitly when the Jeka classpath has been changed.</p> <p>Tip</p> <p>Use Ctrl+space when editing <code>@JkDep</code> to get dependency auto-completion.</p> <p></p>"},{"location":"legacy/tutorials/gui-getting-started/#build-a-java-project","title":"Build a Java Project","text":"<ul> <li> <p>Create a new Jeka project in Intellij : New &gt; Project ... &gt; Jeka</p> </li> <li> <p>Select java project template and click Create</p> </li> </ul> <p></p> <p>Now we have a workable Java project. We can :</p> <ul> <li>Add dependencies using <code>project.flatFacade().configureXxxDependencies()</code> in Build class.</li> <li>Add dependencies by editing project-dependencies.txt file</li> <li>Customize <code>project</code> instance in order to fits your need.</li> </ul> <p>After modifying your dependencies, do not forget to refresh Intellij by Right Click &gt; Jeka Synchronise Iml File</p> <p>Our project is ready to code. Invoke <code>cleanPack</code> to generate binary, sources, and javadoc jar files.</p> <p>Tip</p> <p>Navigate to the right-side Jeka Tool Window &gt; Classpath KBeans &gt; project to see all available methods.</p> <p>Right-click on a method to run/debug it from IDE.  It is possible to combine several methods using Run... or Debug...</p> <p>For most standard projects, we may not need a build code, only a simple properties file. To scaffold such a project :</p> <ul> <li> <p>Create a new Jeka project in Intellij : New &gt; Project ... &gt; Jeka</p> </li> <li> <p>Select java project - code.less template and click Create</p> </li> </ul> <p>We get :</p> <p></p> <p>Execute <code>./jekaw :build_quality</code> to create a full build and perform Sonarqube analysis + code coverage.</p> <p>Properties and code can be used in conjunction, a tough build class may override values defined in local.properties.</p> <p>We will find many project examples here</p> <p>Learn more about Java project builds</p> <p>Learn more about dependency management </p>"},{"location":"legacy/tutorials/gui-getting-started/#build-a-springboot-project","title":"Build a Springboot Project","text":"<ul> <li> <p>Create a new Jeka project in Intellij : New &gt; Project ... &gt; Jeka</p> </li> <li> <p>Select springboot project template and click Create</p> </li> </ul> <p></p> <p>We now have a project ready to code, and already containing a workable RestController and its test counterpart.</p> <p>Execute <code>./jekaw project#pack</code> to generate the bootable jar.</p> <p>Execute <code>./jekaw project#runJar</code> to run the bootable.jar</p> <p>Note</p> <p>As for java project, Springboot projects can be scaffolded with code.less flavor.</p> <p>Visit JeKa sample projects to have concrete implementation examples.</p>"},{"location":"legacy/tutorials/gui-reuse-elements/","title":"Reuse build logic (Work in progress)","text":"<p>Jeka offers flexible and powerful mechanisms for reusing build logic, such as : </p> <ul> <li>Adding Java dependencies to def classpath.</li> <li>Importing build code from another module (see example here)</li> <li>Using plugins</li> </ul>"},{"location":"legacy/tutorials/gui-reuse-elements/#add-dependencies-to-def-classpath","title":"Add dependencies to def classpath","text":"<p>This simple mechanism is powerful. It lets def classes depend on other Java code just as it they would for test/production code. This means that def classes can depend on :</p> <ul> <li>code lying in a different module from the same multi-module project</li> <li>compiled code lying somewhere on the filesystem</li> <li>jars located in a binary repository (i.e. Maven modules)</li> </ul> <p>This tutorial will give some simple examples on how you can factor out parts of your builds. </p> <p>With Jeka you can reuse and share any build elements exactly as you would do for regular code. You can reuse a piece of code within a multi-module project or export it on a repository to reuse it  across projects.</p> <p>These pieces of code can be Jeka plugins or simple classes to make your build code shorter.</p>"},{"location":"legacy/tutorials/gui-reuse-elements/#create-your-own-plugin","title":"Create your own plugin","text":"<p>A plugin is a collection of commands and options (meaning public no-args methods and fields) that can be bound to any  JkClass in order to augment it or modify its behavior. </p> <p>For common usage, you don't need to write your own plugin but you will probably use the ones that are bundled with  Jeka. The simplest way to understand how it works, is to write your own.</p>"},{"location":"reference/api-dependency-management/","title":"Dependency Management","text":"<p>For Jeka, a dependency is something that can be resolved to a set of files by a <code>JkDependencyResolver</code>. Generally a dependency resolves to 1 file (or folder) but it can also be 0 or many.</p> <p>Compared to mainstream build tools, Jeka offers a simpler and more flexible model to deal with multiple dependency configurations required to build a project.</p>"},{"location":"reference/api-dependency-management/#types-of-dependency","title":"Types of Dependency","text":"<p>A dependency is always an instance of <code>JkDependency</code>.</p> <p>Jeka distinguishes between 3 main types of dependency :</p> <ul> <li>Arbitrary files located on the file system (represented by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system while the build is running.</li> <li>Files produced by a computation (represented by <code>JkComputedDependency</code> class). These files may be present on file system, or not. If they are not present, the computation is run in order to produce the missing files. Usually the computation stands for the build of an external project.</li> <li>Coordinate pointing to a remote artifact (represented by <code>JkCoordinateDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jeka can consume and transitively resolve any artifact located in a repository as you would do with Maven, Ivy, or Gradle.</li> </ul> <p>Lastly, Jeka uses Ivy 2.5.1 under the hood. Jeka jar embeds Ivy and executes it in a dedicated classloader to be hidden for client code.</p> <p>Dependency type hierarchy: <pre><code>graph TD\n\n    JkCoordinateDependency --&gt; JkDependency\n    JkFileDependency --&gt; JkDependency\n\n    JkComputedDependency --&gt; JkFileDependency\n    JkFileSystemDependency --&gt; JkFileDependency\n    JkLocalProjectDependency --&gt; JkFileDependency</code></pre></p>"},{"location":"reference/api-dependency-management/#coordinate-dependency","title":"Coordinate dependency","text":"<p>This type of dependency is represented by a <code>JkCoordinateDependency</code> class. It stands for a Maven/Ivy dependency expressed with coordinates (e.g. group:module:version).</p> <p>This is for declaring a dependency on a module hosted in the Maven or Ivy repositories.  Basically you instantiate a <code>JkCoordinateDependency</code> from its group, name, and version.</p>"},{"location":"reference/api-dependency-management/#string-notation","title":"String Notation","text":"<p>The string representation follows the Gradle short notation,  and accept the similar Ivy versioning.</p> <p>Additionally, the Jeka notation allow to express extensions, classifiers and BOMs. Many string formats are accepted to specify a module coordinate :</p> <ul> <li>group:name</li> <li>group:name:version</li> <li>group:name:classifier:version</li> <li>group:name:classifier:extension:version</li> </ul> <p>Examples: <pre><code>org.slf4j:slf4j-api:2.0.16                       &lt;-- Declares an exact version\norg.slf4j:slf4j-api:2.0.16+                      &lt;-- Declares a lower bound version\norg.slf4j:slf4j-api:[2.0.0,2.0.16[               &lt;-- Declares a bounded version\n\norg.mock-server:mockserver-netty:shaded:5.15.0   &lt;-- Declare a dependency on the -shaded- classifier\norg.lwjgl:lwjgl:natives_linux:3.1.0              &lt;-- Declare a dependency on the natives_linux classifier\norg.slf4j:slf4j-bom::pom:2.0.16                  &lt;-- Declare a bom dependency \n</code></pre></p>"},{"location":"reference/api-dependency-management/#bom","title":"BOM","text":"<p>To mention a BOM dependency, we just need to reference the POM extension of this dependency. For example, Springboot defines a BOM in <code>org.springframework.boot:spring-boot-dependencies</code> Maven module.</p> <p>To reference this BOM in our dependencies, we just need to specify the POM extension as in <code>org.springframework.boot:spring-boot-dependencies::pom:3.3.6</code>.</p>"},{"location":"reference/api-dependency-management/#transitivity","title":"Transitivity","text":"<p>By default, dependencies specifying a classifier or an extension are not considered to be transitive.  Although, transitivity can be explicitly defined programmatically.</p> <p>By default, Jeka uses the most relevant transitivity according to the declaration context, so users don't need to specify it unless they want a specific one.</p> <p>Example of programmatic instantiation of a coordinate dependency: <pre><code>var dep = JkCoordinateDependency.of(\"group:name:version\")\n                                .withTransitivity(JkTransitivity.RUNTIME);\n</code></pre></p> <p>See later for more details about transitivity.</p>"},{"location":"reference/api-dependency-management/#file-system-dependencies","title":"File System Dependencies","text":"<p>This type of dependency is represented by the <code>JkFileSystemDependency</code> class.</p> <p>Just mention the path of one or several files. If one of the files does not exist at the time of resolution (when the dependency is actually retrieved), build fails.</p> <pre><code>JkDependencySet.of().andFiles(\"libs/my.jar\", \"libs/my.testingtool.jar\");\n</code></pre>"},{"location":"reference/api-dependency-management/#computed-dependencies","title":"Computed Dependencies","text":"<p>This type of dependency is represented by the <code>JkComputedDependency</code> class.</p> <p>It is typically used for multi-modules or multi-techno projects.</p> <p>The principle is that if the specified files are not present, the computation is run in order to generate the missing files. If some files still missing after the computation has run, the build fails.</p> <p>This mechanism is quite simple yet powerful as it addresses the following use cases :</p> <ul> <li>Dependencies on files produced by an artifact producer (<code>JkArtifactProducer</code>). A <code>JkProject</code> is an artifact producer.</li> <li>Dependencies on files produced by external build tools (Ant, Maven, Gradle, SBT, Android SDK, Make, npm ...).</li> <li>... In other words, files produced by any means.</li> </ul> <p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p> <p>The following snippet constructs a set of dependencies on two external projects : one is built with Maven, the other with Jeka. <pre><code>Path mavenProject = Paths.get(\"../a-maven-project\");\nPath mavenProjectJar = mavenProject.resolve(\"target/maven-project.jar\");\nPath externalProject = Paths.get(\"../a-jeka-project\");\n\nJkProcess mavenBuild = JkProcess.of(\"mvn\", \"clean\", \"install\").withWorkingDir(mavenProject);\n\nJkJavaProject externalProject = JkJavaProject.of(externalProject); \n\nJkDependencySet deps = JkDependencySet.of()\n    .and(JkComputedDependency.of(mavenBuild, mavenProjectJar))\n    .and(externalProject);\n</code></pre></p>"},{"location":"reference/api-dependency-management/#dependency-set","title":"Dependency Set","text":"<p>A dependency set (<code>JkDependencySet</code>) is an ordered bunch of dependencies used for a given purpose (compilation, war packaging, testing, ...). It can contain any kind of <code>JkDependency</code>. See here</p> <p>dependencySet also defines :</p> <ul> <li>A version provider to define which version of a module should be used in case it is not explicitly mentioned. </li> <li>A set of transitive dependency exclusion rules.</li> </ul> <p>It is designed as an immutable object where we can apply set theory operations for adding, removing, or merging with other dependencies and dependencySet.</p> Example.java<pre><code>...\nJkDependencySet deps = JkDependencySet.of()\n    .and(\"com.google.guava\") \n    .and(\"org.slf4j:slf4j-simple\")\n    .and(\"com.orientechnologies:orientdb-client:2.0.8\")\n    .andFile(\"../libs.myjar\")\n    .withVersionProvider(myVersionProvider);\n</code></pre> <p>Note</p> <ul> <li>Module versions can be omitted when declaring dependencies. Versions can be provided by a <code>JkVersionProvider</code> or a BOM dependency.</li> <li>Instances of <code>JkDependencySet</code> can be combined in order to construct a large dependencySet from smaller ones.</li> </ul>"},{"location":"reference/api-dependency-management/#transitivity_1","title":"Transitivity","text":"<p>For each dependency, mainstream build tools use a single concept (scope or configuration) to determine :</p> <ol> <li>which part of the build needs the dependency</li> <li>which transitive dependencies to fetch along the dependency</li> <li>with which transitivity the dependency must be published</li> </ol> <p>This confusion leads to dependency management systems that are bloated, difficult to reason with, and not quite flexible. Gradle comes with a proliferation of 'configurations' to cover most use case combinations, while Maven narrows 'scopes' to a smaller number, but with limitations and not-so-clear transitivity/publish rules.</p> <p>In the opposite, Jeka distinguishes clearly the following three purposes :</p> <ol> <li>Jeka uses distinct dependencySet instances for each part of the build (compile, runtime, test,...). Each can be    defined relatively to another using set theory operations.</li> <li>For each dependency, we can decide its transitivity, that is, the transitive dependencies fetched along the dependency.</li> <li>For publishing, we can optionally re-define a specific dependencySet, exposing exactly what we want.</li> </ol> <p>Jeka defines by default, three levels of transitivity :</p> <ul> <li>NONE : Not transitive</li> <li>COMPILE : Also fetches transitive dependencies declared with scope 'compile' in the dependency published pom.</li> <li>RUNTIME : Also fetches transitive dependencies declared with any scope in the dependency published pom.</li> </ul> <p>Notes</p> <p>On Maven repositories, published poms can declare only two scopes for transitive dependencies : 'compile' and 'runtime'.</p> <p>For Ivy repositories, it is possible to declare a specific transitivity that maps to a slave 'configuration'.</p> <p>The below example shows a JkJavaProject declaration using explicit transitivity.</p> <p><pre><code>JkJavaProject.of().simpleFacade()\n    .configureCompileDeps(deps -&gt; deps\n            .and(\"com.google.guava:guava:23.0\", JkTransitivity.NONE)\n            .and(\"javax.servlet:javax.servlet-api:4.0.1\"))\n    .configureRuntimeDeps(deps -&gt; deps\n            .and(\"org.postgresql:postgresql:42.2.19\")\n            .withTransitivity(\"com.google.guava:guava\", JkTransitivity.RUNTIME)\n            .minus(\"javax.servlet:javax.servlet-api\"))\n    .configureTestDeps(deps -&gt; deps\n            .and(Hint.first(), \"org.mockito:mockito-core:2.10.0\")\n    )\n</code></pre> It results in : <pre><code>Declared Compile Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:NONE\n  javax.servlet:javax.servlet-api:4.0.1\n\nDeclared Runtime Dependencies : 2 elements.\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n\nDeclared Test Dependencies : 4 elements.\n  org.mockito:mockito-core:2.10.0\n  com.google.guava:guava:23.0 transitivity:RUNTIME\n  org.postgresql:postgresql:42.2.19\n  javax.servlet:javax.servlet-api:4.0.1\n</code></pre> Dependencies without any transitivity specified will take default transitivity for their purpose, namely COMPILE for compile dependencies, and RUNTIME for runtime and test dependencies.</p> <p>The API allows you to redefine the transitivity declared in a upper dependency set.</p> <p>Note that transitivity can only apply to <code>JkModuleDependency</code> (like com.google.guava:guava:23.0) and <code>JkLocalProjectDependency</code>.</p>"},{"location":"reference/api-dependency-management/#resolve-dependencies","title":"Resolve Dependencies","text":"<p>The <code>JkDependencyResolver</code> class is responsible JkDependencyResolver.of(JkRepo.ofMavenCentral());to resolve dependencies by returning <code>JkResolveResult</code> from a <code>JkdependencySet</code>.</p> <pre><code>JkDependencySet deps = JkDependencySet.of()\n                            .and(\"org.apache.httpcomponents:httpclient:4.5.3\")\n                            .andFile(\"libs/my.jar\");\n\n// Here, module dependencies are fetched from Maven central repo\nJkDependencyResolver resolver = \n        JkDependencyResolver.of(JkRepo.ofMavenCentral());  \nJkResolveResult result = resolver().resolve(deps);\n</code></pre> <p>From the result you can :</p> <ul> <li>Navigate in the resolved dependency tree as :</li> </ul> <pre><code>JkDependencyNode slfjApiNodeDep = result.getDependencyTree()\n        .getFirst(JkModuleId.of(\"org.slf4j:slf4j-api\"));\nSystem.out.println(slfjApiNode.getModuleInfo().getResolvedVersion());\n</code></pre> <ul> <li>Get the direct list of artifact files</li> </ul> <pre><code>JkPathSequence sequence = result.getFiles();  \nsequence.forEach(System.out::println); // print each files part of the result\n</code></pre>"},{"location":"reference/api-dependency-management/#publication","title":"Publication","text":"<p>Jeka is able to publish on both the Maven and Ivy repositories. This includes repositories such as Sonatype Nexus.</p> <p>Maven and Ivy have different publication models, so Jeka proposes specific APIs according to whether you want to publish on a Maven or Ivy repository.</p>"},{"location":"reference/api-dependency-management/#publish-on-a-maven-repository","title":"Publish on a Maven repository","text":"<p>Jeka proposes a complete API to pubish on Maven repository. POM files will be generated by Jeka according to provided elements.</p> <p>Find an example here</p> <p>Notice that Jeka allows you to :</p> <ul> <li>Publish more than one artifact.</li> <li>Produce &amp; publish checksum files for each published artifact.</li> <li>Mention using unique snapshots (What is it ?).</li> <li>Feed generated pom with data necessary to publish on central repository.</li> <li>Sign published artifacts with PGP</li> <li>Publish to multiple repositories by creating the publisher using a <code>JkRepoSet</code> instead of a <code>JkRepo</code>.</li> </ul> <p>To sign with PGP, there is no need to have PGP installed on Jeka machine. Jeka uses Bouncy Castle internally to sign artifacts.</p>"},{"location":"reference/api-dependency-management/#publish-to-a-ivy-repository","title":"Publish to a Ivy repository","text":"<p>Publishing on Ivy repo is pretty similar to publishing on Maven, though there are options specific to Ivy.</p> <p>See also here</p>"},{"location":"reference/api-dependency-management/#common-classes","title":"Common Classes","text":"<ul> <li> <p><code>JkRepo</code> and <code>JkRepoSet</code> represent both download and upload repositories. </p> </li> <li> <p><code>JkRepoFromProperties</code>provides configured repositories according to global or project scopes properties.</p> </li> <li> <p><code>JkDependencySet</code> represents a set of dependencies.</p> </li> <li> <p><code>JkDependencyResolver</code> resolves dependencies to classpaths and resolution results that allow resolution exploration.</p> </li> <li> <p><code>JkModuleFileProxy</code> provides an smart way to get a file from its coordinates.</p> </li> </ul>"},{"location":"reference/api-docker/","title":"Docker API","text":"<p>The Docker API provides classes for defining and building Docker images programmatically. It relies on the Docker CLI, so a Docker installation (e.g., Docker Desktop) is required to invoke Docker commands from Java code.</p>"},{"location":"reference/api-docker/#features","title":"Features","text":"<ul> <li>Define Dockerfiles and build-context directories programmatically.</li> <li>Generate optimized Docker images (JVM-based and native) directly from a project definition (e.g., a <code>JKProject</code> instance).</li> </ul>"},{"location":"reference/api-docker/#classes","title":"Classes","text":"<p>The classes are located in package <code>dev.jeka.core.api.tooling.docker</code>.</p>"},{"location":"reference/api-docker/#jkdocker","title":"<code>JkDocker</code>","text":"<p>Provides helper methods to:</p> <ul> <li>Execute Docker commands conveniently.</li> <li>Retrieve a list of image names present in the Docker registry.</li> </ul> <pre><code>JkDocker.execCmdLine(\"run\", \"--rm -p8080:8080 io.my-registry/my-image:latest\");\n</code></pre>"},{"location":"reference/api-docker/#jkdockerbuild","title":"<code>JkDockerBuild</code>","text":"<p>Represents a Docker build context. It enables defining the build context directory and Dockerfile, as well as invoking Docker to build an image.</p> <p>Key features include:</p> <ul> <li>Define Dockerfiles and build-context directory contents programmatically.</li> <li>Build images based on the defined build context.</li> <li>Simplify Dockerfile editing:</li> <li>Add a non-root user.</li> <li>Copy files into the build context.</li> <li>Adjust cursor position to insert build steps at specific locations.</li> <li>And more...</li> </ul> Example<pre><code>JkDockerBuild dockerBuild = JkDockerBuild.of()\n    .setBaseImage(\"eclipse-temurin:21-jdk-alpine\")\n    .setExposedPorts(8080);\n\ndockerBuild.dockerfileTemplate\n    .addCopy(Paths.get(\"/users/me/jars/my-app.jar\"), \"/app/my-app.jar\")\n    .add(\"WORKDIR /app\")\n    .addEntrypoint(\"java\", \"-jar\", \"/app/my-app.jar\");\n\ndockerBuild.buildImageInTemp(\"my-image:latest\");  // Create the Docker image in a random temp dir\n</code></pre> Generated Dockerfile<pre><code>FROM eclipse-temurin:21-jdk-alpine\nRUN addgroup --gid 1002 nonrootgroup &amp;&amp; \\\n    adduser --uid 1001 -g 1002 --disabled-password nonroot\nUSER nonroot\nCOPY imported-files/hello-jeka.jar /app/my-app.jar\nWORKDIR /app\nENTRYPOINT [\"java\", \"-jar\", \"/app/my-app.jar\"]\nEXPOSE 8080\n</code></pre> <p>Key Notes:</p> <ul> <li>The non-root user has been automatically added as part of the Dockerfile.</li> <li>Jar files from the filesystem have been imported into the [build context]/imported-files directory.</li> </ul> <p>For more details, refer to the Javadoc.</p>"},{"location":"reference/api-docker/#jkdockerjvmbuild","title":"<code>JkDockerJvmBuild</code>","text":"<p>An extension of <code>JkDockerBuild</code> that provides additional methods to:</p> <ul> <li>Generate optimized JVM-based Docker images directly from a project definition.</li> <li>Add agents to the program for runtime enhancements.</li> </ul> Example<pre><code>JkProject project = project();\nJkDockerJvmBuild dockerJvmBuild = JkDockerJvmBuild.of(project.asBuildable())\n    .addAgent(\"io.opentelemetry.javaagent:opentelemetry-javaagent:2.10.0\", \"myAgentOption\");\n\ndockerBuild.buildImageInTemp(\"my-jvm-image:latest\");  // Create the Docker image in a random temp dir\n</code></pre> <p>Generated Dockerfile<pre><code>FROM eclipse-temurin:23-jdk-alpine\nRUN addgroup --gid 1002 nonrootgroup &amp;&amp; \\\n    adduser --uid 1001 -g 1002 --disabled-password nonroot\nRUN mkdir -p /app &amp;&amp; chown -R nonroot:nonrootgroup /app \\\n    &amp;&amp; mkdir -p /workdir &amp;&amp; chown -R nonroot:nonrootgroup /workdir\nUSER nonroot\nCOPY agents /app/agents\nCOPY libs /app/libs\nCOPY snapshot-libs /app/snapshot-libs\nCOPY classpath.txt /app/classpath.txt\nCOPY resources /app/classes\nCOPY classes /app/classes\nWORKDIR /workdir\nENTRYPOINT [ \"java\", \"-javaagent:/app/agents/opentelemetry-javaagent-2.10.0.jar=myAgentOption\", \"-cp\", \"@/app/classpath.txt\", \"dev.jeka.core.tool.Main\" ]\nCMD []\n</code></pre> Key Notes:</p> <ul> <li>The Docker image is layered for optimal caching. If a class changes without modifying dependencies, only the final step is re-executed, significantly speeding up the image creation process.</li> <li>The OpenTelemetry agent has been included and referenced in the command-line arguments.</li> </ul>"},{"location":"reference/api-docker/#jkdockernativebuild","title":"<code>JkDockerNativeBuild</code>","text":"<p>An extension of <code>JkDockerBuild</code> offering additional methods for creating compact and efficient native executable images.</p> <p>*Example: Creating a Minimalist Distroless Image</p> <p>This approach produces images with a minimal package set to reduce the attack surface. It requires building a native executable with static linking on <code>libc</code> (e.g., using MUSL).</p> Example<pre><code>JkNativeCompilation nativeCompilation = getNativeCompilation()\n    .setStaticLinkage(MUSL);\n\nJkDockerNativeBuild dockerBuild = JkDockerNativeBuild.of(nativeCompilation)\n    .setBaseImage(\"gcr.io/distroless/static-debian12:nonroot\");\n\ndockerBuild.buildImageInTemp(\"my-jvm-image:latest\");  // Create the Docker image in a random temp dir\n</code></pre> Generated Dockerfile<pre><code>FROM ghcr.io/graalvm/native-image-community:23-muslib AS build\nCOPY imported-files/j2objc-annotations-3.0.0.jar /root/cp/j2objc-annotations-3.0.0.jar\nCOPY imported-files/error_prone_annotations-2.28.0.jar /root/cp/error_prone_annotations-2.28.0.jar\nCOPY imported-files/checker-qual-3.43.0.jar /root/cp/checker-qual-3.43.0.jar\nCOPY imported-files/jsr305-3.0.2.jar /root/cp/jsr305-3.0.2.jar\nCOPY imported-files/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar /root/cp/listenablefuture-9999.0-empty-to-avoid-conflict-with-guava.jar\nCOPY imported-files/failureaccess-1.0.2.jar /root/cp/failureaccess-1.0.2.jar\nCOPY imported-files/guava-33.3.1-jre.jar /root/cp/guava-33.3.1-jre.jar\nCOPY imported-files/hello-jeka.jar /root/cp/hello-jeka.jar\nCOPY imported-files/jeka-native-image-arg-file-5771078964740361323.txt /argfile\nRUN native-image @/argfile\n\nFROM gcr.io/distroless/static-debian12:nonroot\n\nCOPY  --from=build /my-app /app/myapp\n\nWORKDIR /app\nENTRYPOINT [\"/app/myapp\"]\n</code></pre> <p>Key Notes:</p> <ul> <li>The native executable is generated within a container using a multi-stage build.</li> <li>No non-root user has been created because the base image is inferred to already include one (based on its name).</li> <li>Native-based Docker images can be created directly from Windows or macOS workstations without any prerequisites other than Docker.</li> </ul>"},{"location":"reference/api-files/","title":"Files API","text":"<p>File manipulation is a key aspect of software development. Jeka extends the java.nio.file API by introducing additional concepts to offer a powerful and fluent API for performing common tasks with minimal effort.  </p> <p>The file-api classes are located in the <code>dev.jeka.core.api.file</code> package. Visit the Javadoc.</p>"},{"location":"reference/api-files/#jkpathfile","title":"<code>JkPathFile</code>","text":"<p>A simple wrapper for files (not folders). It provides copying, interpolation, checksum, deletion and creation methods.</p> Example<pre><code>JkPathFile.of(\"my-new-file.txt\")\n    .fetchContentFrom(\"https://www.bgreco.net/fortune.txt\")\n    .copyToDir(myFolder);\n</code></pre>"},{"location":"reference/api-files/#jkpathtree","title":"<code>JkPathTree</code>","text":"<p>An Immutable root folder along a <code>PathMatcher</code> providing operations to copy, navigate, zip, iterate, or watch. This is a central class in Jeka API.</p> Examples<pre><code>// copies all non java source files to another directory preserving structure\nJkPathTree.of(\"src\").andMatching(false, \"**/*.java\").copyTo(\"build/classes\");\n\n// One liner to zip an entire directory\nJkPathTree.of(\"build/classes\").zipTo(Paths.get(\"mylib.jar\"));\n\n// Traverse the tree in breath first (opposite to deep-first) \nJkPathTree.of(\"build/classes\").streamBreathFirst().forEach(file -&gt; ...);\n\n// Compute MD5\nString md5 = JkPathTree.of(\"src/main/java\").checksum();\n</code></pre>"},{"location":"reference/api-files/#jkpathsequence","title":"<code>JkPathSequence</code>","text":"<p>An Immutable sequence of <code>java.nio.file.Path</code> providing methods for filtering or appending. Example<pre><code>URL[] urls = JkPathSequence.of(paths)\n                .and(embeddedLibs())\n                .toUrls();\n</code></pre></p>"},{"location":"reference/api-files/#jkpathmatcher","title":"<code>JkPathMatcher</code>","text":"<p>An immutable <code>java.nio.file.PathMatcher</code> based on <code>java.nio.file</code> glob pattern or regerxp.   Used by <code>JkPathTree</code> to filter in/out files according name patterns.</p>"},{"location":"reference/api-files/#jkziptree","title":"<code>JkZipTree</code>","text":"<p>Same as <code>JkPathTree</code> but using a zip file instead of a directory. It allows you to manipulate a zip file   as a regular folder. </p>"},{"location":"reference/api-files/#jkpathtreeset","title":"<code>JkPathTreeSet</code>","text":"<p>An Immutable set of <code>JkPathTree</code>. Helpful to define a set of sources/resources and create jar/zip files.</p>"},{"location":"reference/api-files/#jkresourceprocessor","title":"<code>JkResourceProcessor</code>","text":"<p>A mutable processor for copying a set of files, preserving the structure and   replacing some texts with others. Typically used for replacing tokens <code>${server.ip}</code> with an actual values.</p>"},{"location":"reference/api-git/","title":"Git API","text":"<p>The Git API provides classes for conveniently working with Git in Java. The classes are part of the <code>dev.jeka.core.api.tooling.git</code> package.</p>"},{"location":"reference/api-git/#jkgit-class","title":"<code>JkGit</code> class","text":"<p>The <code>JkGit</code> class extends <code>JkProcess</code>, which means it inherits methods that make process execution easier.</p> Sequence og Git calls<pre><code>JkGit git = JkGit.of(rootDir);\ngit\n    .execCmdLine(\"add .\")\n    .execCmdLine(\"config user.name  jeka-bot\")\n    .execCmdLine(\"config user.email jeka-bot@github-action.com\")\n    .execCmdLine(\"commit -m update-javadoc --allow-empty\")\n    .execCmdLine(\"push\");\n</code></pre> <p>The tool offers many useful methods for executing standard DevOps commands like checking the workspace state, retrieving commit messages, and viewing current tags. For more details, visit the Javadoc.</p> Conenient method calls<pre><code>List&lt;String&gt; tagNames = git.getTagsOnCurrentCommit();\nString commit         = git.getCurrentCommit();\nString messageToken   = git.extractSuffixFromLastCommitMessage(\"release:\");\n...\n</code></pre>"},{"location":"reference/api-git/#jkversionfromgit-class","title":"<code>JkVersionFromGit</code> class","text":"<p>This class infers project versions from Git information based on the current tag or branch.</p> <ul> <li>If the current commit is on a tag, the returned version is <code>tag-name</code>.</li> <li>If not on a tag, the returned version is <code>branch-name-SNAPSHOT</code>.</li> </ul> <pre><code>JkVersionFromGit versionFromGit = JkVersionFromGit.of(\"v\");  // consider only tags starting with 'v'\nSystem.out.println(versionFromGit.getVersion());\n\nJkProject project = getProject();\nversionFromGit.handleVersioning(project);\n</code></pre>"},{"location":"reference/api-intro/","title":"Build Library","text":"<p>JeKa comes with a set of classes designed to help you programmatically accomplish build tasks. These classes are used to implement JeKa's engine and its bundled KBeans. You may find these classes useful for your own needs, as they cover the following concerns:</p> <ul> <li>File manipulation.</li> <li>Java specific actions (compilation, classloading, jar creation, ...). Visit Javadoc.</li> <li>Java specific actions (compilation, module). Visit source code.</li> <li>Cryptography signing. Visit source code.</li> <li>Dependency management.</li> <li>Project Building</li> <li>Testing (run tests on junit-jupiter engine). Visit Javadoc.</li> <li>Running external commands. Visit Visit Javadoc.</li> </ul>"},{"location":"reference/api-native/","title":"Native API","text":"<p>The Native API offers a <code>JkNativeCompilation</code> class that creates an executable file from compiled classes or JARs. </p> <p>An easy way to use it is by passing a <code>JkProject</code> when instantiating. This setup prepares everything for native compilation. The class automatically downloads GraalVM,  which includes the <code>nativeImage</code> executable used for compiling to native - you don't need to care about GraalVM installation. </p> <p>It also provides helpful methods to add resources to the native executable.</p> <p>Exemple<pre><code>JkProject project = ...\n\nJkNativeCompilation.of(project.asBuildable()\n    .setIncludesAllResources(true)\n    .make(Paths.get(\"build/my-app.exe\"));\n</code></pre> This code performs the following actions: - Checks if the system is running on GraalVM. If not, it fetches the latest GraalVM version (if not already available). - Includes all project resources located in src/main/resources. - Fetches the metadata repository and adds it to the compilation classpath. - Uses the <code>native-image</code> GraalVM tool to compile the application into a native binary.</p> <p>By default, JeKa will fetch GraalVM using the Foodjay API unless the <code>JEKA_GRAALVM_HOME</code> environment variable is set. If the environment variable's value starts with <code>DOWNLOAD_</code> (e.g., <code>DOWNLOAD_21</code>), the specified GraalVM version will be downloaded from the internet.</p>"},{"location":"reference/api-project/","title":"Project API","text":"<p>The Jeka Project API provides a high-level interface for building Java/JVM projects. At the core of this API is the <code>JkProject</code> class, which serves as the central entry point for performing build tasks.</p>"},{"location":"reference/api-project/#classes","title":"Classes","text":"<p>The classes are located in the <code>dev.jeka.core.api.project</code> package.</p>"},{"location":"reference/api-project/#jkproject","title":"<code>JkProject</code>","text":"<p>The <code>JkProject</code> class contains all the essential definitions for building a JVM project, including source locations, build output, testing, packaging (e.g., creating JAR files), compiler settings, dependencies, and more.</p> <p>Designed with multiple extension points, it provides flexibility for integrating custom or specific build behaviors.</p> <p>To manage all of these concerns efficiently, the class is structured as follows:</p> <p><pre><code>project\n\u251c\u2500 baseDir\n\u251c\u2500 outputDir\n\u251c\u2500 artifactLocator (define where artifact files are supposed to be created)\n\u251c\u2500 duplicateDependencyConflictStrategy\n\u251c\u2500 jvmTargetVersion\n\u251c\u2500 sourceEncoding\n\u251c\u2500 javaCompileToolChain\n\u251c\u2500 dependencyResolver\n\u251c\u2500 compilation  (produce individual binary files from production sources. This includes resource processing, code generation, processing on .class files, ...)\n\u2502  \u251c\u2500 layout (where are located source and resource files)\n\u2502  \u251c\u2500 source generators (plugin mechanism for generating source files)\n\u2502  \u251c\u2500 dependencies   (stands for compile dependencies)\n\u2502  \u251c\u2500 preCompileActions (including resources processing)\n\u2502  \u251c\u2500 compileActions (including java sources compilation. Compilation for other languages can be added here)\n\u2502  \u251c\u2500 postCompileActions\n\u2502  \u2514\u2500 methods : resolveDependencies(), run()\n\u251c\u2500 testing\n\u2502  \u251c\u2500 testCompilation (same as above 'prodcCompilation' but for test sources)\n\u2502  \u2502  \u251c\u2500 layout\n\u2502  \u2502  \u251c\u2500 dependencies (stands for test dependencies)\n\u2502  \u2502  \u2514\u2500 ...\n\u2502  \u251c\u2500 breakOnFailure (true/false)\n\u2502  \u251c\u2500 skipped (true/false)\n\u2502  \u251c\u2500 testProcessor\n\u2502  \u2502  \u251c\u2500 forkedProcess (configured the forked process who will run tests)\n\u2502  \u2502  \u251c\u2500 preActions\n\u2502  \u2502  \u251c\u2500 postActions\n\u2502  \u2502  \u251c\u2500 engineBehavior\n\u2502  \u2502  \u2502  \u251c\u2500 testReportDir\n\u2502  \u2502  \u2502  \u251c\u2500 progressDisplayer\n\u2502  \u2502  \u2502  \u2514\u2500 launcherConfiguration (based on junit5 platform API)\n\u2502  \u2502  \u2514\u2500 testSelection\n\u2502  \u2502     \u251c\u2500 includePatterns\n\u2502  \u2502     \u2514\u2500 includeTags\n\u2502  \u2514\u2500 method : run()\n\u251c\u2500 packaging (produces javadoc and source jar and bin jars)\n\u2502  \u251c\u2500 javadocConfiguration\n\u2502  \u251c\u2500 runtimeDependencies\n\u2502  \u251c\u2500 manifest\n\u2502  \u251c\u2500 fatJar (customize produced fat/uber jar if any)\n\u2502  \u2514\u2500 methods : createJavadocJar(), createSourceJar(), createBinJar(), createFatJar(), resolveRuntimeDependencies()\n\u2514\u2500 methods :  toDependency(transitivity), getIdeSupport(), pack(), getDependenciesAsXml(), includeLocalAndTextDependencies()           \n</code></pre> See a detailed example here.</p>"},{"location":"reference/api-project/#flat-facade","title":"Flat Facade","text":"<p>For convenience, <code>JkProject</code> offers a simplified facade to easily configure common settings without delving into its deeper structure.</p> <pre><code>JkProjectFlatFacade projectFacade = JkProject.of().flatFacade;\nprojectFacade\n       .setPublishedModuleId(\"dev.jeka:sample-javaplugin\")\n       .setVersionFromGitTag()\n       .mixResourcesAndSources()\n       .setLayoutStyle(SIMPLE)\n       .addTestExcludeFilterSuffixedBy(\"IT\", false);\nprojectFacade.dependencies.compile\n       .add(\"com.google.guava:guava:21.0\")\n       .add(\"com.sun.jersey:jersey-server:1.19.4\")\n       .add(\"org.projectlombok:lombok:1.18.36\");\nprojectFacade.dependencies.runtime\n       .remove(\"org.projectlombok:lombok\")\n       .add(\"com.github.djeang:vincer-dom:1.2.0\");\nprojectFacade.dependencies.test\n       .add(\"org.junit.vintage:junit-vintage-engine:5.6.0\");\nprojectFacade.doPack();  // compile, test and create jar\n</code></pre>"},{"location":"reference/api-project/#project-dependencies","title":"Project Dependencies","text":"<p>Project dependencies in Jeka are managed differently from Maven/Gradle.  Instead of a single collection of dependencies for a specific scope/configuration,  Jeka uses three distinct classpaths: compile, runtime, and test. Each is defined independently but can reference the others.</p> <ul> <li>Compile classpath: </li> </ul> <p>Classpath needed to compile the classes.</p> <ul> <li>Runtime classpath: </li> </ul> <p>Classpath needed to run the build application or to embedded with the built library (embedded in jar or specified as transitive dependencies).</p> <p>This classpath is automatically constructed by taking the compile classpath upon which other libraries can be added or removed.</p> <ul> <li>Test classpath: </li> </ul> <p>Classpath needed to compile and run the tests. </p> <p>This classpath is constructed by merging the compile and runtime classpaths upon which other libraries can be added or removed.</p> <p>Dependencies must follow the format: <code>group:module:[classifier]:[type]:[version]</code> where classifier, type, and version are optional. See <code>JkCoordinate</code> javadoc for details.</p> <p>To import a bill-of-materials (BOM), declare a dependency as: <code>group:module::pom:version</code>.</p> <p>Using the programmatic api, you can also declare filesystem dependencies, meaning jar files located in  the project code base.</p> <p></p>"},{"location":"reference/api-project/#dependenciestxt","title":"dependencies.txt","text":"<p>Entire project dependencies can be declared in full text located in the [PROJECT_DIR]/dependencies.txt file.</p> <p>Example: <pre><code>[version]\norg.junit:junit-bom:5.12.1@pom    # use this pom as a version provider for all junit dependencies\norg.postgresql:postgresql:42.5.0\norg.glassfish.jaxb:jaxb-*:4.0.5   # use joker to specify version according a pattern\n\n[compile]\nom.google.guava:guava:33.4.8-jre\norg.lwjgl:lwjgl:natives-linux:3.3.6  # specify the 'natives-linux' classifier for lwjgl\norg.glassfish.jaxb:jaxb-runtime      # version for org.glassfish.jaxb:jaxb-* is specified above\n../module-utils                      # specify a project directory located on file system\n\n[compile-only]\norg.projectlombok:lombok:1.18.36\norg.openjfx:javafx-base:${jeka.platform.os}:2.0.18  # properties are interpolated\n\n[runitme]\norg.postgresql:postgresql\n\n[test]\norg.junit.jupiter:junit-jupiter\norg.junit.platform:junit-platform-launcher\norg.fluentlenium:fluentlenium-junit:3.2.0\n    !org.apache.httpcomponents:httpclient  # exclude http-client from 'fluentlenium-junit' transitive dependencies\n!!net.sourceforge.htmlunit:htmlunit        # exclude htmlunit from all transitive dependencies\n</code></pre></p> <p>As shown in the example above, we can use the <code>@</code> and <code>@@</code> symbols to specify dependency exclusions. <code>[version]</code> Specifies the versions of dependencies to use when not explicitly defined. You can include all versions defined in a BOM by referencing its coordinates and appending <code>@pom</code>. The versions section inherits definitions from the version section in the <code>dependencies.txt</code> file located in the parent directory.</p> <p><code>[compile]</code> Specifies dependencies required for both compiling and running the project.</p> <p><code>[compile-only]</code> Specifies dependencies required only for compiling the project, which are excluded at runtime.</p> <p><code>[runtime]</code> Specifies dependencies required only for running the project.</p> <p><code>[test]</code> Specifies dependencies for the test classpath. This includes dependencies from the compile, compile-only, and runtime sections, along with those specified in the test section.</p> <p>Tip</p> <p>If you're using the Jeka plugin for IntelliJ, press <code>ctrl+&lt;space&gt;</code> for autocomplete suggestions.</p> <p>Resolve Dependencies Programmatically</p> <p>To resolve dependencies that make up the runtime classpath, you can use one of the following methods:</p> <ul> <li><code>JkProject.packaging.resolveRuntimeDependencies()</code> to fetch the dependency resolution tree.</li> <li><code>JkProject.packaging.resolveRuntimeDependenciesAsFiles()</code> to get the resolved classpath as a list of JAR files.</li> </ul> <p>The second option may be faster as it caches the results of previous invocations.</p> <p>Display Dependency tree on the console</p> <p>The dependency tree and the resulting classpath can be displayed on the console using: <code>JkProject.displayDependencyTree()</code> methods.</p> <p>Change the Maven repository</p> <p>By default, the dependencies are resolved using Maven central repository.</p> <p>We can change it programatically, by using <code>JkProject.dependencyResolver.setRepos()</code> method.</p>"},{"location":"reference/api-project/#display-generic-info","title":"Display Generic Info","text":"<p>We can display project info such as locations, source file count, version, moduleID, and more by displaying the result of the <code>JkProject.getInfo()</code> method.</p>"},{"location":"reference/api-project/#build-project","title":"Build Project","text":"<p>Different phases of the build can be invoked using the following methods:</p> <ul> <li><code>JkProject.compilation.generateSources()</code>: Generates sources if any source generators are registered.</li> <li><code>JkProject.compilation.run()</code>: Runs the entire compilation process, including source generation and other registered compilation tasks.</li> <li><code>JkProject.testing.run()</code>: Compiles tests and runs them. This also includes production code compilation if it hasn't been done yet.</li> <li><code>JkProject.pack()</code>: Creates the main JAR and any additional JARs specifically configured. This includes running tests if they haven't been executed.</li> </ul> <p>In the next section, we'll detail the classes involved in the entire build process.</p>"},{"location":"reference/api-project/#jkprojectcompilation","title":"JkProjectCompilation","text":"<p>Handles the compilation tasks for a <code>JkProject</code>. This class is used for both production and test code compilation. It offers configuration methods for defining:</p> <ul> <li>The locations of source files and compiled classes.</li> <li>Dependencies required for compilation.</li> <li>The compiler and compilation options.</li> <li>Source code generators attached to the compilation task.</li> <li>Additional <code>pre</code> and <code>post</code> actions tied to the compilation phase.</li> <li>Interpolators for resource processing.</li> </ul>"},{"location":"reference/api-project/#jkprojectsourcegenerator","title":"JkProjectSourceGenerator","text":"<p>Implement this class to define a source generator. Register the generator in a project using: <code>JkProject.compilation.addSourceGenerator(JkProjectSourceGenerator sourceGenerator)</code>.</p> <p>Once registered, sources will be automatically generated during compilation or when explicitly calling: <code>JkProject.compilation.generateSources()</code>.</p>"},{"location":"reference/kbeans-app/","title":"App KBean","text":"<p>Provides a way to install, update, or remove applications from the user PATH.</p> <p>Applications are installed from a Git repository and built by the client before installation. Applications can be installed as executable JARs or native apps.</p>"},{"location":"reference/kbeans-app/#install-applications","title":"Install Applications","text":"<pre><code>jeka app: install repo=&lt;repo-url&gt;\n</code></pre> <p>Install an application in native mode <pre><code>jeka app: install repo=&lt;repo-url&gt; native:\n</code></pre></p> <p>Example: <pre><code>jeka app: install repo=https://github.com/djeang/kill8 name=kill8 native:\n</code></pre></p>"},{"location":"reference/kbeans-app/#list-installed-applications","title":"List Installed Applications","text":"<p><pre><code>jeka app: list\n</code></pre> This displays the the name of the applications, along their repo, version/status, and runtime type. <pre><code>App Name   \u2502 Repo                                      \u2502 Version  \u2502 Status     \u2502 Runtime \u2502 \ncalculator \u2502 https://github.com/djeang/Calculator-jeka \u2502 latest   \u2502 up-to-date \u2502 jvm     \u2502 \nkill8      \u2502 https://github.com/djeang/kill8           \u2502 &lt;master&gt; \u2502 up-to-date \u2502 native  \u2502 \n</code></pre></p>"},{"location":"reference/kbeans-app/#update-applications","title":"Update Applications","text":"<p><pre><code>jeka app: update name=kill8\n</code></pre> Updates the application to the highest semantic version tag. If a 'latest' tag exists, uses that tag. If no tags exist, uses the latest commit.</p>"},{"location":"reference/kbeans-app/#uninstall-applications","title":"Uninstall Applications","text":"<pre><code>jeka app: uninstall name=kill8\n</code></pre>"},{"location":"reference/kbeans-app/#catalogs","title":"Catalogs","text":"<p>Display the registered catalogs of applications: <pre><code>jeka app: catalog\n</code></pre></p> <p>Display application registered in a given catalog: <pre><code>jeka app: name=demo \n</code></pre></p> <p>To add a catalog, add the following lines to your <code>~/.jeka/global.properties</code> file. <pre><code>catalog.xxx.repo=[http location or git repo url]\ncatalog.xxx.desc=[Description of the catalog]\n</code></pre> where <code>xxxx</code> stands for the name of your catalog.</p> <p><code>catalog.xxx.repo</code> can value a url pointing at the catalog file, or the url of the Github repo containing the catalog file.</p> <p>Both examples are valid: <pre><code># Inside the `demo' repo of the 'jeka-dev' Github organization. \n# The jeka-catalog.properties file is expected at the repo root.\ncatalog.demo.repo=jeka-dev/demo\n\n# Inside the `jeka-catalog' repo of the 'djeang' Github organization.\n# The jeka-catalog.properties file is expected at the repo root.\ncatalog.djeang.repo=djeang\n\n# Direct pointing at the url.\ncatalog.foo.repo=https://raw.githubusercontent.com/jeka-dev/jeka-catalog/refs/heads/main/jeka-catalog.properties\n</code></pre></p> <p>Catalog file example: <pre><code>app.cowsay.repo=https://github.com/jeka-dev/demo-cowsay\napp.cowsay.desc=Java port or the Cowsay famous CLI.\napp.cowsay.type=CLI\n\napp.demo-springboot-angular.repo=https://github.com/jeka-dev/demo-project-springboot-angular\napp.demo-springboot-angular.desc=Manage a list of users. Written in Springboot and Angular\napp.demo-springboot-angular.type=SERVER-UI\n</code></pre></p>"},{"location":"reference/kbeans-app/#security","title":"Security","text":"<p>Trusted URL prefixes are stored in the <code>jeka.apps.url.trusted</code> property, located in the ~/.jeka/global.properties file. You can adjust this property later to make it more or less restrictive. The check validates the start of the Git URL after removing the protocol and identifier part.</p> <p>Example: <code>jeka.app.url.trusted=github.com/djeang/</code> will trust urls formed as:</p> <ul> <li>https://github.com/djeang/xxx...    </li> <li>https://my-user-name@github.com/djeang/xxx...</li> <li>git@github.com/djeang/xxx..</li> <li>git@github.com:my-user-name/djeang/xxx..</li> <li>...</li> </ul> <p>Provides a way to install, update, or remove applications from the user PATH.</p> <p>Applications are installed from a Git repository and built by the client before installation. Applications can be installed as executable JARs or native apps.</p> <p>This KBean exposes the following fields:</p> Field Description repo [String] Git Remote repository URL of the app to install. name [String] Specifies the name of the app to update/uninstall. description [String] Short description of the app provided by the application author. url [String] Specifies the url to trust. <p>This KBean exposes the following methods:</p> Method Description catalog List application catalogs. install Builds and installs the app to make it available in PATH.Use <code>repo=[Git URL]</code> to set the source repository.Use <code>native:</code> argument to install as a native app. list Lists installed Jeka commands in the user's PATH. trustUrl Adds permanently the url to the trusted list.The urls starting with the specified prefix will be automatically trusted.Use 'url=my.host/my.path/' to specify the prefix. uninstall Uninstalls an app from the user's PATH.Use <code>name=[app-name]</code> to specify the app. update Updates an app from the given name.Use <code>name=[app-name]</code> to specify the app name."},{"location":"reference/kbeans-base/","title":"Base KBean","text":"<p>Manages the build and execution of code located in 'jeka-src' directory.</p> <p>The code stands for neither an application nor a library. For applications, code should contain a class including a main method to:</p> <ul> <li>Run application</li> <li>Create bootable jar</li> <li>Create bootable fat jar, and create Docker images</li> </ul> <p><code>BaseKBean</code> is similar to <code>ProjectKBean</code>, but it facilitates building JVM-based code hosted entirely in the jeka-src folder with a simpler classpath organization.</p> <ul> <li>Single Classpath: By default, there is a single classpath. However, if a <code>_dev</code> package exists in the code structure, its contents are excluded when creating JARs, native executables, or Docker images. Typically, build and test classes are placed in <code>_dev</code> for application builds.</li> <li>Dependency Declaration: Dependencies are declared by annotating any class with the <code>@JkDep</code> annotation. Dependencies within the <code>_dev</code> package are excluded from production artifacts.</li> </ul> <p>Key Features</p> <ul> <li>Resolves dependencies, compiles code, and runs tests.</li> <li>Creates various types of JAR files out-of-the-box: regular, fat, shaded, source, and Javadoc JARs.</li> <li>Infers project versions from Git metadata.</li> <li>Executes packaged JARs.</li> <li>Displays dependency trees and project setups.</li> <li>Scaffolds skeletons for new projects.</li> </ul> <p>Example</p> <ul> <li>Base Application: The <code>BaseKBean</code> is set as the default KBean in <code>jeka.properties</code>. The accompanying <code>README.md</code> file details the available <code>base:</code> methods that can be invoked.</li> </ul> <p>Manages the build and execution of code located in 'jeka-src' directory.</p> <p>The code stands for neither an application nor a library. For applications, code should contain a class including a main method to:</p> <ul> <li>Run application</li> <li>Create bootable jar</li> <li>Create bootable fat jar, and create Docker images</li> </ul> <p>This KBean exposes the following fields:</p> Field Description jvmOptions [String] Space separated list of options to pass to the JVM that will run the program. programArgs [String] Space separated list of program arguments to pass to the command line running the program. moduleId [String] Group and name for publication, formatted as 'groupId:nameId'. jarType [enum:JkProjectPackaging$JarType] Type of jar to produce for the main artifact. gitVersioning.enable [boolean] If true, a version computed from the current Git branch/tag will be injected into the Maven KBean to determine the published version. gitVersioning.tagPrefix [String] Some prefer to prefix version tags like 'v1.3.1' instead of simply using '1.3.1'. In such cases, this value can be set to 'v' or any other chosen prefix. scaffold.kind [enum:JkBaseScaffold$Kind] Kind of Jeka base to generate. scaffold.jekaVersion [String] Set a specific jeka.version to include in jeka.properties. NO: no jeka.version specified, [EMPTY]: last version found in Maven Central. scaffold.jekaLocation [String] Set a specific jeka.distrib.location to include in jeka.properties. scaffold.jekaDistribRepo [String] Set a specific jeka.distrib.repo to include in jeka.properties. scaffold.extraJekaProps [String] Coma separated string representing properties to add to jeka.properties. scaffold.rawJekaPropsContentPath [Path] Set the path of a file containing the exact content of the jeka.properties file to generate.If this field is set, all others related to jeka.properties generation are ignored. <p>This KBean exposes the following methods:</p> Method Description build Runs tests then 'pack'. depTree Displays exported dependency tree on console. info Displays info about this base KBean. pack Creates runnable fat jar and optional artifacts. runJar Runs fat jar. runMain Launches application. scaffold Creates a skeleton in the current working directory. test Launches test suite."},{"location":"reference/kbeans-bundle/","title":"Setup KBean","text":"<p>Bundle a self-contained Java app (containing JRE) using jpackage and jlink tools.</p> <p>This plugin creates a self-contained app and allows configuring the jpackage and jlink tools.</p> <p>This integrates with ProjectKBean for project-specific setups, handles file system operations to prepare input directories, and invokes jpackage and jlink tools.</p>"},{"location":"reference/kbeans-bundle/#creates-a-customized-sef-contained-app","title":"Creates a customized sef-contained app","text":"<p>Thanks to jpackage and jlink tools, this KBean creates self-contained Java app or installer tailored  for the host system.</p> <p>To create such a bundle, execute: <code>jeka bundle: pack</code>.</p> <p>The application or installer will be created in [project dir]/jeka-output dir.</p> <p>If you want to create this bundle along other artifacts while executing <code>jeka project: pack</code>,  you need to specify the following property in jeka.properties. <pre><code>@javafx.projectPack=true\n</code></pre></p> <p>Bundle a self-contained Java app (containing JRE) using jpackage and jlink tools.</p> <p>This plugin creates a self-contained app and allows configuring the jpackage and jlink tools.</p> <p>This integrates with ProjectKBean for project-specific setups, handles file system operations to prepare input directories, and invokes jpackage and jlink tools.</p> <p>This KBean post-initializes the following KBeans:</p> Post-initialised KBean Description ProjectKBean Adds the bundled application to 'project: pack' actions, if 'projectPack=true'. <p>This KBean exposes the following fields:</p> Field Description customJre [boolean] If true, a custom JRE is created including only Java modules used by the application. projectPack [boolean] If true, creates a bundled application along with the regular JAR when executing 'project: pack'. includeRuntimeLibs [boolean] It true, the runtimes libs will be added in the packaged application, which may be not necessary whe using FAT jars. jpackage.options.all.[key] [String] jpackage.options.windows.[key] [String] jpackage.options.linux.[key] [String] jpackage.options.mac.[key] [String] jlink.options.all.[key] [String] jlink.options.windows.[key] [String] jlink.options.linux.[key] [String] jlink.options.mac.[key] [String] <p>This KBean exposes the following methods:</p> Method Description jlinkHelp Prints jlink help on the console. jpackageHelp Prints jpackage help on the console. pack Packages the application into a bundle. showModuleDeps Prints JPMS module dependencies on the console."},{"location":"reference/kbeans-docker/","title":"Docker KBean","text":"<p>Builds and runs image based on project.</p> <p>This KBean can build JVM and Native (AOT) images from an existing project.</p> <p><code>DockerKBean</code> allows the creation of Docker images for both project and base KBeans. It supports generating JVM-based images as well as minimalist Docker images containing only the native executable.</p> <p>Key Features:</p> <ul> <li>Efficiently create layered and secure Docker images for JVM applications</li> <li>Generate secure, optimized Docker images for native applications</li> <li>Infer image name/version from the project</li> <li>Optionally switch to a non-root user (configurable)</li> <li>Customize the generated image via Java API</li> </ul> <p>Example Invocation: - <code>jeka docker:buildNative</code>: Builds a native Docker image of your application.</p> <p>Example Configuration:</p> <p>Specify base image: <pre><code>@docker.nativeBaseImage=gcr.io/distroless/static-debian12:nonroot\n</code></pre></p> <p>Add JVM agents <pre><code>@docker.jvmAgents.0.coordinate=io.opentelemetry.javaagent:opentelemetry-javaagent:2.16.0\n@docker.jvmAgents.0.optionLine=-Dotel.traces.exporter=otlp,-Dotel.metrics.exporter=otlp\n</code></pre> Example For Programmatic customization:</p> <p><pre><code>@JkPostInit\nprivate void postInit(DockerKBean dockerKBean) {\n    dockerKBean.customizeJvmImage(dockerBuild -&gt; dockerBuild\n            .addAgent(\"io.opentelemetry.javaagent:opentelemetry-javaagent:2.16.0\", \"\")\n            .setBaseImage(\"eclipse-temurin:21.0.1_12-jre-jammy\")\n            .nonRootSteps   // inserted after  USER nonroot\n            .addCopy(Paths.get(\"jeka-output/release-note.md\"), \"/release.md\")\n            .add(\"RUN chmod a+rw /release.md \")\n    );\n}\n</code></pre> This KBean allows customizing the Docker image programmatically using the Jeka libs for Docker.</p> <p>It\u2019s easy to see the customization result by executing <code>jeka docker: info</code>.  This will display details about the built image, including the generated Dockerfile.  You can also visit the generated Docker build directory,  which contains all the Docker context needed to build the image with a Docker client.</p> <p>Builds and runs image based on project.</p> <p>This KBean can build JVM and Native (AOT) images from an existing project.</p> <p>This KBean exposes the following fields:</p> Field Description jvmImageName [String] Explicit full name of the JVM image to build. It may includes placeholders such as '$version', '$groupId', and '$artifactId'.If not specified, the image name will be inferred form the project information. nativeImageName [String] Explicit full name of the native image to build. It may includes placeholders such as '$version', '$groupId', and '$artifactId'.If not specified, the image name will be inferred form the project information. jvmBaseImage [String] Base image to construct the Docker image. jvmOptions [String] Space-separated list of additional JVM options to use when running the container's Java process. nativeBaseImage [String] Base image for the native Docker image to build. It can be replaced by a distro-less image as 'gcr.io/distroless/static-debian12:nonroot'. nativeNonRootUser [enum:JkDockerBuild$NonRootMode] Specifies the policy for creating a non-root user in the native Docker image. jvmNonRootUser [enum:JkDockerBuild$NonRootMode] Specifies the policy for creating a non-root user in the JVM Docker image. jvmAgents.[key].coordinate [String] Coordinate of the JVM agent, e.g. 'io.opentelemetry.javaagent:opentelemetry-javaagent:1.32.0'. jvmAgents.[key].optionLine [String] Option line to pass to the agent, e.g. '-Dotel.traces.exporter=otlp,-Dotel.metrics.exporter=otlp. <p>This KBean exposes the following methods:</p> Method Description build Builds Docker image in local registry. buildNative Builds native Docker image in local registry. info Displays info about the Docker image. infoNative Displays info about the native Docker image."},{"location":"reference/kbeans-eclipse/","title":"IntelliJ KBean","text":"<p>Manages Eclipse metadata files.</p> <p><code>EclipseKBean</code>  provides methods for generating metadata files for the Eclipse IDE, specifically the .classpath and .project files.</p> <p>To ensure it works correctly, define a <code>JEKA_USER_HOME</code> classpath variable in Eclipse with the value <code>~/.jeka</code>.</p> <p>Manages Eclipse metadata files.</p> <p>This KBean exposes the following fields:</p> Field Description javadoc [boolean] If true, .classpath will include javadoc reference for declared dependencies. jreContainer [String] If not null, this value will be used as the JRE container path in .classpath. useVarPath [boolean] If true, dependency paths will be expressed relatively to Eclipse path variables instead of absolute paths. <p>This KBean exposes the following methods:</p> Method Description all Generates Eclipse files (.project and .classpath) on all sub-folders of the current directory. Only sub-folders having a jeka-src directory are taken in account. See eclipse#files. files Deprecated: use 'sync' instead. sync Generates Eclipse files (.classpath and .project) in the current directory. The files reflect project dependencies and source layout."},{"location":"reference/kbeans-git/","title":"Git KBean","text":"<p>Provides convenient operations for Git.</p> <p><code>GitKBean</code> provides command combos such as:</p> <ul> <li>Displaying a list of commit messages since the last tag.</li> <li>Pushing remote tags with guards to ensure the local workspace is clean.</li> </ul> <p>Provides convenient operations for Git.</p> <p>This KBean exposes the following methods:</p> Method Description lastCommitMessages Displays all commit messages since last tag. lastTag Displays last git tag in current branch. moveLatest Moves the 'latest' tag to the current commit and push it to origin. tagRemote Performs a dirty check first, put a tag at the HEAD and push it to the remote repo. The user will be prompted to enter the tag name."},{"location":"reference/kbeans-intellij/","title":"Intellij KBean","text":"<p>Manages Intellij metadata files.</p> <p><code>IntellijKBean</code> provides methods for generating metadata files for IntelliJ IDE.  The content of an iml file is computed according the <code>JkBuildable</code> object found in found in the base directory.</p> <p>This KBean proposes methods to customize generated iml file.</p> Configuration in a Build.java class<pre><code>@JkPostInit\nprivate void postInit(IntellijKBean intellijKBean) {\n    intellijKBean\n            .replaceLibByModule(\"dev.jeka.jeka-core.jar\", \"core\")\n            .setModuleAttributes(\"core\", JkIml.Scope.COMPILE, null);\n</code></pre> <p>Manages Intellij metadata files.</p> <p>This KBean exposes the following fields:</p> Field Description useVarPath [boolean] If true, dependency paths will be expressed relatively to $JEKA_REPO$ and $JEKA_HOME$ path variable instead of absolute paths. failOnDepsResolutionError [boolean] If true, the iml generation fails when a dependency can not be resolved. If false, it will be ignored (only a warning will be notified). splitModule [boolean] Experimental: If true, 'jeka-src' will have its own IntelliJ module. focus [enum:IntellijKBean$SyncFocus] Experimental: If 'jeka-src' is in its own module, the 'sync' action can target it specifically. downloadSources [boolean] If true, sources will be downloaded will resolving dependencies. <p>This KBean exposes the following methods:</p> Method Description initProject Re-init the project by deleting workspace.xml and regenerating .idea/modules.xml. modulesXml Generates ./idea/modules.xml file by grabbing all .iml files presents in root or sub-directory of the project. sync Generates IntelliJ [my-module].iml file. syncAll Generates iml files on this folder and its descendant recursively."},{"location":"reference/kbeans-maven/","title":"Maven KBean","text":"<p>Manages Maven publication for project and 'jeka-src'.</p> <p><code>MavenKBean</code> provides ability to publish artifacts on a  Maven repository. The artifacts are those produces by project or base Kbeans.  It also provides convenient mean to migrate from Maven prajects.</p> <p>Key Features:</p> <ul> <li>publish on local or remote repositories, artifacts produced by projects</li> <li>display info about publication, especially transitive dependencies published along the atifacts</li> <li>property or programmatic configuration for published POM metadata and dependencies</li> <li>property or programmatic configuration for publication repository</li> </ul> <p>Manages Maven publication for project and 'jeka-src'.</p> <p>This KBean exposes the following fields:</p> Field Description codeIndent [int] Indentation size for 'showPomDeps' output. pub.moduleId [String] Module id of the module to publish formatted as groupId:artifactId. pub.version [String] The version of the module to publish. pub.parentBom [boolean] If true, the publication will generate a BOM as its only artifact. The BOM will point to the version of each child base that contains a project KBean.Be caution to declare it with leading '' as  '@maven.pub.parentBom' in jeka.properties to not propagate it to children. pub.gitVersioning.enable [boolean] If true, a version computed from the current Git branch/tag will be injected into the Maven KBean to determine the published version. pub.gitVersioning.tagPrefix [String] Some prefer to prefix version tags like 'v1.3.1' instead of simply using '1.3.1'. In such cases, this value can be set to 'v' or any other chosen prefix. pub.metadata.projectName [String] Human-friendly name for the project to publish. pub.metadata.projectDescription [String] Description for the project to publish. pub.metadata.projectUrl [String] The page to visit to know more about the project. pub.metadata.projectScmUrl [String] The url to fetch source code, as the git repo url. pub.metadata.licenses [String] Comma separated list of license formated as =. pub.metadata.developers [String] Comma separated list of developers formatted as :. pub.predefinedRepo [enum:MavenKBean$PredefinedRepo] If not null, the publication will be published on this repo. pub.extraArtifacts [String] Coma separated string of artifact classifiers to publish, in format [classifier] or [classifier].[extension].This assumes the artifact file be present in jeka-output dir.Example: 'uber', 'doc.zip'. <p>This KBean exposes the following methods:</p> Method Description info Displays Maven publication information on the console. migrateDeps Displays Java code for declaring dependencies based on pom.xml. The pom.xml file is supposed to be in root directory. publish Publishes the Maven publication on the repositories specified inside this publication. publishLocal Publishes the Maven publication on the local JeKa repository. publishLocalM2 Publishes the Maven publication on the local M2 repository. This is the local repository of Maven."},{"location":"reference/kbeans-native/","title":"Native KBean","text":"<p>Creates native executables.</p> <p>A native images is an executable file created from Java bytecode. This KBean allows to create native images from executable jars generated from the project.</p> <p><code>NativeKBean</code> enables native compilation for project and base KBeans.</p> <p>Key Features</p> <ul> <li>Compiles classes into native executables.</li> <li>Automatically applies AOT metadata.</li> <li>Simplifies resource inclusion.</li> <li>Handles static linkage with minimal configuration.</li> </ul> <p>Example of Configuration in jeka.properties: <pre><code>@native.includeAllResources=true\n@native.staticLink=MUSL\n@native.metadataRepoVersion=0.10.3\n</code></pre></p> <p>Invocation: <code>jeka native: compile</code></p> <p>See native API.</p> <p>Creates native executables.</p> <p>A native images is an executable file created from Java bytecode. This KBean allows to create native images from executable jars generated from the project.</p> <p>This KBean exposes the following fields:</p> Field Description args [String] Extra arguments to pass to native-image compiler. staticLink [enum:JkNativeCompilation$StaticLink] Tell if the generated executable must by statically linked with native libs. useMetadataRepo [boolean] Use predefined exploratory aot metadata defined in standard repo. metadataRepoVersion [String] Use predefined exploratory aot metadata defined in standard repo. includeMainClassArg [boolean] If false, the main class won't be specified in command line arguments. This means that it is expected to be mentioned in aot config files. includeAllResources [boolean] If true, all resources will be included in the native image. <p>This KBean exposes the following methods:</p> Method Description compile Creates a native image from the project's main artifact jar.Builds the artifact first if none exists."},{"location":"reference/kbeans-project/","title":"Project KBean","text":"<p>Manages the build and execution of a JVM project.</p> <p>It contains all information and methods for resolving dependencies, compiling, testing and packaging as JARs.</p> <p><code>ProjectKBean</code>  acts as a wrapper around a <code>JkProject</code> to facilitate the building of JVM-based code hosted in a project structure. This KBean provides core methods for fundamental build tasks, including compiling, testing, and packaging.</p> <p>To work effectively with this KBean, it's helpful to have an overview of the capabilities offered by the <code>JkProject</code> object.</p> <p>Key Features</p> <ul> <li>Resolves dependencies, compiles code, and runs tests.</li> <li>Creates various types of JAR files out-of-the-box, including regular, fat, shaded, source, and Javadoc JARs.</li> <li>Infers project versions from Git metadata.</li> <li>Executes packaged JARs.</li> <li>Displays dependency trees and project setups.</li> <li>Scaffolds skeletons for new projects.</li> </ul> <p>Additionally, <code>ProjectKBean</code> serves as a central point of interaction for other KBeans, enabling them to access project details and extend or enhance the build process.</p> <p>It offers standardized methods that cover the whole build life-cycle:</p> <ul> <li><code>scaffold</code>: Creates new project structure from scratch</li> <li><code>generateSources</code>: Generates source code</li> <li><code>compile</code>: Compiles source code</li> <li><code>test</code>: Compiles and run test code</li> <li><code>pack</code>: Creates packaged artifacts as JAR files</li> <li><code>checkQuality</code>: Runs quality checkers and quality gates</li> <li><code>e2eTest</code>: Runs end-to-end test on a deployed version of the application</li> </ul> <p>The <code>JkProject</code> instance offers methods to customize or extend behavior, allowing seamless integration of third-party extensions.</p> <p>Example for getting information about source files:</p> <pre><code>class MyBuild extends KBean {\n\n  private List&lt;Path&gt; allSourceFiles;\n\n  @JkPostInit\n  private void postInit(ProjectKBean projectKBean) {\n      allSourceFiles = projectKBean.project.compilation.layout.resolveSources().getFiles();\n      ...\n  }\n}\n</code></pre> <p>Example taken from JeKa:</p> <ul> <li>Jacoco KBean:  A KBean that reads te underlying <code>JkProject</code> and modifies its testing behavior.</li> <li>Sonarqube KBean: A KBean that reads te underlying <code>JkProject</code> to extract information.</li> <li>Protobuf KBean:   A KBean that adds a Proto-buffer code generation to the underlying <code>JkProject</code>.</li> </ul>"},{"location":"reference/kbeans-project/#annotation-processors","title":"Annotation Processors","text":"<p>To use an annotation processor (like Lombok or MapStruct), add the dependency coordinates to the <code>compile-only</code> section in your <code>dependencies.txt</code> file.</p> <pre><code>[compile-only]\norg.mapstruct:mapstruct-processor:1.6.3\norg.projectlombok:lombok:1.18.38\n</code></pre> <p>Annotation processors that generate source files will output them to the jeka-output/generated-sources/annotation-processors directory.</p> <p>That's it!</p> <p>Manages the build and execution of a JVM project.</p> <p>It contains all information and methods for resolving dependencies, compiling, testing and packaging as JARs.</p> KBean Initialisation Applies the specified configuration to the underlying <code>JkProject</code> instance. <p>This KBean exposes the following fields:</p> Field Description version [String] Version of the project. Can be used by a CI/CD tool to inject version. moduleId [String] Module id of the project. Only needed if the project is published on a Maven repository. sourceEncoding [String] The encoding format used for handling source files within the project. javaVersion [String] Specifies the Java version used to compile and run the project. By default, this is the same as the version used to run Jeka. pack.jarType [enum:JkProjectPackaging$JarType] Type of jar to produce for the main artifact. pack.shadeJarClassifier [String] If not blank, the project will produce an extra shade jar having the specified classifier name.A shade Jar embeds classes coming from dependency jars. The dependency class packages are relocated to avoid potential collisions with other jar present in the classpath. pack.mainClass [String] Main class name to include in Manifest. pack.detectMainClass [boolean] If true and no mainClass specified, it will be detected and added to the Manifest. pack.javadocOptions [String] Options to pass to javadoc tool when invoked. e.g '--notimestamp -doctitle \"My Project API\"'. run.jvmOptions [String] JVM options to use when running generated jar. run.programArgs [String] Program arguments to use when running generated jar. run.useRuntimeDepsForClasspath [boolean] If true, the resolved runbase classpath will be used when running the generated jar. If the generated jar is a Uber jar or contains all the needed dependencies, leave it to 'false'. dependencies.compile [String] Comma separated compile dependencies to include at scaffold time. dependencies.runtime [String] Comma separated runtime dependencies to include at scaffold time. dependencies.test [String] Comma separated test dependencies to include at scaffold time. test.includePatterns [String] Space-separated string to filter the test class names to run. Use regex patterns like '.', '.Test', '.*IT', or 'ac.me.MyTest'. test.skip [boolean] If true, tests are not run. test.fork [boolean] If true, tests will be executed in a forked process. test.jvmOptions [String] Argument passed to the JVM if tests are executed in a forked process (example -Xms2G -Xmx2G). test.progress [enum:JkTestProcessor$JkProgressStyle] The style to use to show test execution progress. scaffold.generateLibsFolders [boolean] Generate libs sub-folders for hosting local libraries. scaffold.kind [enum:JkProjectScaffold$Kind] The template used for scaffolding the build class. scaffold.jekaVersion [String] Set a specific jeka.version to include in jeka.properties. NO: no jeka.version specified, [EMPTY]: last version found in Maven Central. scaffold.jekaLocation [String] Set a specific jeka.distrib.location to include in jeka.properties. scaffold.jekaDistribRepo [String] Set a specific jeka.distrib.repo to include in jeka.properties. scaffold.extraJekaProps [String] Coma separated string representing properties to add to jeka.properties. scaffold.rawJekaPropsContentPath [Path] Set the path of a file containing the exact content of the jeka.properties file to generate.If this field is set, all others related to jeka.properties generation are ignored. layout.style [enum:JkCompileLayout$Style] Style of directory source structure (src/main/java or just src). layout.mixSourcesAndResources [boolean] If true, Resource files are located in same folder than Java code. compilation.fork [boolean] Specify whether to fork the compilation process. compilation.javaVersion [String] The target JVM version for compiled files. compilation.compilerOptions [String] Extra arguments to be passed to the compiler (example -Xlint:unchecked). outputFile [Path] The output file for the xml dependency description. gitVersioning.enable [boolean] If true, a version computed from the current Git branch/tag will be injected into the Maven KBean to determine the published version. gitVersioning.tagPrefix [String] Some prefer to prefix version tags like 'v1.3.1' instead of simply using '1.3.1'. In such cases, this value can be set to 'v' or any other chosen prefix. <p>This KBean exposes the following methods:</p> Method Description build Runs a full build: cleans, compiles, tests, packs, checks quality and runs end-to-end tests. checkQuality Runs the quality checkers. clean Deletes the content of jeka-output directory and might execute extra clean actions. compile Performs compilation and resource processing. depTree Displays resolved dependency trees on console. depTreeAsXml Displays resolved dependency trees as xml, on console. e2eTest Runs the registered end-to-end tests. generateSources Generates sources. info Displays information about the Java project to build. pack Generates artifacts based on 'pack' options. Creates a single JAR by default. runJar Runs the generated jar. runMain Runs the compiled classes. scaffold Scaffolds a JeKa project skeleton in working directory. test Compiles and run tests defined within the project (typically Junit tests)."},{"location":"reference/kbeans-setup/","title":"Setup KBean","text":"<p>Provides convenient methods to perform global configuration tasks as editing global.properties file</p> <p>or updating embedded jeka boot scripts.</p> <p>Provides convenient methods to perform global configuration tasks as editing global.properties file or updating  embedded jeka boot scripts.</p> <p>Provides convenient methods to perform global configuration tasks as editing global.properties file</p> <p>or updating embedded jeka boot scripts.</p> <p>This KBean exposes the following fields:</p> Field Description content [String] Argument for 'addGlobalProp' and 'installApp' methods. name [String] Argument for the 'removeApp' method. <p>This KBean exposes the following methods:</p> Method Description addShorthand Adds a shorthand to the global properties file.Provide it as 'content=[shorthand-name]=[shorthand content]E.g. 'jeka operations: addShorthand content=build=project: pack sonarqube: run'. editGlobalProps Edits the global.properties file. openHomeDir Opens a file explorer window in the JeKA user home directory. updateLocalScripts Creates or updates jeka.ps1 and jeka bash scripts in the current directory.Uses the running JeKa version to set the script version."},{"location":"reference/kbeans/","title":"KBeans","text":"<p>KBean is the central concept of the execution engine. KBeans are classes with declared executable methods. There is only one KBean instance per KBean class in any given Jeka base directory.</p> <p>KBean classes share the following characteristics:</p> <ul> <li>They extend the <code>KBean</code> class.</li> <li>They may declare <code>public void</code> methods without arguments. All these methods can be invoked from the command line.</li> <li>They may declare <code>public</code> fields (also known as KBean properties). These field values can be injected from the command line.   Additionally, they can have non-public fields annotated with <code>@JkDoc</code>.</li> <li>They must provide a no-argument constructor.</li> <li>They may override the <code>init()</code> method.</li> <li>They must be instantiated by the execution engine and not by user code.</li> </ul>"},{"location":"reference/kbeans/#simple-example","title":"Simple Example","text":"<p>The following KBeans expose the <code>hello</code> and <code>bye</code> methods. The rendering can be configured  through <code>nema</code> and <code>uppercase</code> attributes.</p> <p><pre><code>@JkDoc(\"Displays greeting messages\")\npublic class Greeting extends KBean {\n\n    public String name = \"Bob\";\n\n    @JkDoc(\"If true, the message is shown in upper case.\")\n    public boolean uppercase;\n\n    @JkDoc(\"Prints a hello message.\")\n    public void hello() {\n        System.out.println(formatMessage(\"Hello \" + name + \"!\"));\n    }\n\n    public void bye() {\n        System.out.println(formatMessage(\"Goodbye \" + name + \"!\"));\n    }\n\n    private String formatMessage(String message) {\n        return uppercase ? message.toUpperCase() : message;\n    }\n}\n</code></pre> To execute a method from the command line, run the following example: <pre><code>jeka hello name=Alice uppercase=true\n</code></pre> To show help for this KBean, run: <pre><code>jeka greeting: --doc\n</code></pre> This will display: <pre><code>Displays greeting messages.\n\nFields\n      name=&lt;String&gt;   No description.\n                        Default: Bob\n      uppercase       If true, the message is shown in upper case.\n                        Default: false\nMethods\n  bye    No Description.\n  hello  Prints a hello message.\n</code></pre></p>"},{"location":"reference/kbeans/#location","title":"Location","text":"<p>KBeans can exists as source code in the local project jeka-src folder, at root or any package,  or  as class in the Jeka classpath.</p> <p>Multiple KBeans in jeka-src</p> <p>Many KBeans may coexist in a single jeka-src dir. In this case, use KBean names to precise on  which bean to invoke, as:</p> <p><pre><code>jeka greeting: hello bye other: foo\n</code></pre> In the above example, three methods coming from 2 distinct KBean are invoked.</p> <p>Classpath KBeans</p> <p>Jeka bundles a collection of KBeans for building projects, creating Docker images, performing Git operations, and more.</p> <p>For example, running: <pre><code>jeka project: compile\n</code></pre> will compile the source code located in the src/main/java directory, using dependencies specified in the dependencies.txt file.</p> <p>To display the documentation for the <code>project</code> KBean, run: <pre><code>jeka project: --doc\n</code></pre></p> <p>To list all available KBeans in the classpath, execute: <pre><code>jeka --doc\n</code></pre></p> <p>KBeans can be added to the classpath like any third-party dependency. This can be done by setting the <code>jeka.inject.classpath</code> property in the jeka.properties file as follows: <pre><code>jeka.classpath=dev.jeka:springboot-plugin   dev.jeka:openapi-plugin:0.11.8-1\n</code></pre></p> <p>KBeans can also be included directly in the source code using the <code>@JkDep</code> annotation: <pre><code>import dev.jeka.core.tool.JkDep;\n\n@JkDep(\"dev.jeka:springboot-plugin\")\n@JkDep(\"dev.jeka:openapi-plugin:0.11.8-1\")\nclass Custom extends KBean {\n...\n</code></pre></p> <p>Additionally, KBeans can be dynamically added from the command line like this: <pre><code>jeka --classpath=dev.jeka:openapi-plugin:0.11.8-1 openapi:--doc\n</code></pre></p> <p>Jeka discovers KBeans automatically by scanning the classpath.</p>"},{"location":"reference/kbeans/#kbean-methods","title":"KBean Methods","text":"<p>A KBean method is a specific method defined in a KBean class, designed to be executable from the command line interface. For successful recognition as a command, the method must adhere to the following criteria:</p> <ul> <li>It must be designated as <code>public</code>.</li> <li>It must be an instance method, not static or abstract.</li> <li>It must not require any arguments upon invocation.</li> <li>It must not return any value, as indicated by a <code>void</code> return type.</li> </ul>"},{"location":"reference/kbeans/#kbean-fields","title":"KBean Fields","text":"<p>A KBean field is a <code>public</code> instance field of a KBean class. Its value can be injected from the command line or from a property file. Additionally, it can be a non-public field annotated with <code>@JkDoc</code>.</p> <p>Fields can be annotated with <code>@JkInjectProperty(\"my.prop.name\")</code> to inject the value of a property into the field.</p> <p>We can also inject value using *jeka.properties</p> <p>For more details on field accepted types, see the <code>dev.jeka.core.tool.FieldInjector#parse</code> method.</p> <p>KBean fields can also represent nested composite objects. See the example in the <code>ProjectKBean#pack</code> field.</p>"},{"location":"reference/kbeans/#naming-kbeans","title":"Naming KBeans","text":"<p>To be referenced conveniently, KBeans can be identified by specific names. For any given KBean class, the accepted names are:</p> <ol> <li>Fully qualified class name.</li> <li>Uncapitalized simple class name (e.g., <code>myBuild</code> matches <code>org.example.MyBuild</code>).</li> <li>Uncapitalized simple class name without the <code>KBean</code> suffix (e.g., <code>project</code> matches <code>dev.jeka.core.tool.builtin.project.ProjectKBean</code>).</li> </ol> <p>Tip</p> <p>Execute <code>jeka</code> at the root of a project to display the KBeans available on the Jeka classpath.</p>"},{"location":"reference/kbeans/#document-kbeans","title":"Document KBeans","text":"<p>KBean classes, methods, and attributes can include the <code>@JkDoc</code> annotation to provide self-documentation. The text from these annotations is displayed when running the command: <pre><code>jeka &lt;kbeanName&gt;: --doc\n</code></pre> To display documentation for the default KBean, simply run: <pre><code>jeka --doc\n</code></pre></p> <p>Use the <code>@JkDocUrl</code> annotation to indicate that a KBean has online documentation. This URL will be displayed in the output of the <code>--doc</code> command.</p> <p>To document your KBean, you can use the following command: <pre><code>jeka &lt;kbeanName&gt;: --doc-md\n</code></pre> This command generates a markdown-formatted document of the specified KBean. You can copy and paste the output directly into your online documentation.</p>"},{"location":"reference/kbeans/#invoke-kbeans","title":"Invoke KBeans","text":""},{"location":"reference/kbeans/#from-the-command-line","title":"From the Command Line","text":"<p>KBean methods can be executed directly from the command line using the syntax:</p> <pre><code>jeka &lt;kbeanName&gt;: [methodName...] [attributeName=xxx...]\n</code></pre> <p>Example: <pre><code>jeka project: info pack tests.fork=false pack.jarType=FAT sonarqube: run\n</code></pre></p> <p>You can call multiple methods and set multiple fields in a single command.</p>"},{"location":"reference/kbeans/#from-intellij-jeka-plugin","title":"From IntelliJ Jeka Plugin","text":"<p>The IntelliJ Jeka Plugin enables invoking KBean methods directly from the IDE,  either from the code editor or the project explorer tool window.</p>"},{"location":"reference/kbeans/#from-a-plain-ide-setup","title":"From a Plain IDE Setup","text":"<p>KBean methods can also be launched or debugged in an IDE by invoking the <code>dev.jeka.core.tool.Main</code> method and passing the corresponding command-line arguments.</p> <p>Example: Invoking the <code>dev.jeka.core.tool.Main</code> method with arguments <code>project:</code> and <code>compile</code> will instantiate the <code>ProjectKBean</code> class and invoke its <code>compile</code> method.</p> <p>Warning</p> <p>Ensure that the main method is launched with the module directory set as the working directory. In IntelliJ, the default working directory is the project directory, which may cause issues.</p> <p>To update IntelliJ defaults: - Navigate to Run | Edit Configurations... | Application | Working Directory - Set the value to <code>$MODULE_DIR$</code>.</p>"},{"location":"reference/kbeans/#default-kbean","title":"Default KBean","text":"<p>When invoking Kbean methods or fields, we generally specify to which KBean this applies:</p> <p>Examples: <pre><code>jeka project: pack\njeka myBean: foo bar=1\n</code></pre></p> <p>If the target KBean is the default KBean, then this we don't need to mention the KBean name.</p> <p>By default, the default KBean is the first KBean found in jeka-src dir.  For instance, if you have a single KBean  <code>MyBean</code> in jeka-src, then you can invoke directly the methods and fields as following: <pre><code>jeka foo bar=1\n</code></pre> If you need to invoke methods of other KBean, in between, you can use the <code>:</code> symbol as: <pre><code>jeka project: pack : foo bar=1\n</code></pre> The above example invokes the <code>ProjectKBean#pack</code> method, then the  <code>MyBean#foo</code> method.</p> <p>You can select a specific default KBean, by setting the following property in jeka-src or as command-line argument: <pre><code>jeka.kbean.default=project\n</code></pre></p> <p>You can also mention the default KBean using <code>--kbean=</code> option.</p> <p>The default KBean always participate in the runbase initialisation.</p> <p>This is quite frequent for project builds to use such setting as it shortens command line and prone usage of  <code>ProjectKBean</code> standard methods.</p>"},{"location":"reference/kbeans/#kbean-initialization","title":"KBean Initialization","text":"<p>During startup, JeKa initializes these KBeans:</p> <ul> <li>The default KBean</li> <li>KBeans specified with <code>@myKbean=on</code> in jeka.properties</li> </ul> <p>After identifying these initial KBeans, JeKa performs a discovery phase to find additional KBeans that need initialization:</p> <ul> <li>KBeans referenced as parameters in methods annotated with <code>@JkPostInit(required = true)</code></li> <li>KBeans returned by static methods annotated with <code>@JkRequire</code></li> </ul> <p>This discovery mechanism allows dynamic addition of KBeans to the initialization list.</p> <p>Example:</p> <p>If you have a <code>Custom</code> KBean located in the jeka-src directory, its class will be inspected under two conditions:</p> <ol> <li>It is set as the default KBean</li> <li>It is enabled with <code>@custom=on</code> in the jeka.properties file</li> </ol> <p>Then it will be inspected to discover other KBeans to initialize.</p> <pre><code>import dev.jeka.core.tool.JkPostInit;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\n\nclass Custom extends KBean {\n\n    @JkRequire\n    private static Class&lt;? extends KBean&gt; require(JkRunbase runbase) {\n        return runbase.getBuildableClass();\n    }\n\n    @JkPostInit(required = true)\n    private void postInit(MavenKBean mavenKBean) {\n        ...\n    }\n}\n</code></pre> <p>In this example, the <code>MavenKBean</code> will be included in the initialized KBeans.</p> <p>The <code>require(JkRunbase)</code> method will be invoked to know which KBean should be initialized too (either <code>ProjectKBean</code> nor <code>BaseKBean</code>.)</p>"},{"location":"reference/kbeans/#invoke-kbean-from-another-kbean","title":"Invoke KBean from another KBean","text":""},{"location":"reference/kbeans/#using-jkinject","title":"Using @JkInject","text":"<p><pre><code>import dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\nimport dev.jeka.core.tool.JkInject;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\nclass Build extends KBean {\n\n    @JkInject\n    private ProjectKBean projectKBean;\n\n    @JkInject\n    private MavenKBean mavenKBean;\n\n    @JkDoc(\"Clean, compile, test, create jar files, and publish them.\")\n    public void packPublish() {\n        projectKBean.clean();\n        projectKBean.pack();\n        mavenKBean.publishLocal();\n    }\n\n}\n</code></pre> Both <code>ProjectKBean</code> and <code>MavenKBean</code> are created and injected into the <code>Build</code> KBean during initialization.</p>"},{"location":"reference/kbeans/#using-load-and-find-methods","title":"Using #load and #find methods","text":"<p>As we saw earlier, you can dynamically retrieve a <code>KBean</code> using the <code>KBean#load(Class)</code> method. This method forces the initialization of the <code>KBean</code> if it is not already present. It is useful when you need a specific <code>KBean</code> only within certain methods.</p> <pre><code>@JkDoc(\"Compiles application to native executable\")\npublic void createNativeExec() {\n    load(NativeKBean.class).compile();\n}\n</code></pre> <p>On the other hand, the <code>KBean#find(Class)</code> method returns an <code>Optional&lt;? extends KBean&gt;</code>, which is empty if the specified <code>KBean</code> is not initialized. This is helpful for performing conditional tasks based on the presence of a <code>KBean</code>.</p> <pre><code>import dev.jeka.core.tool.builtins.tooling.docker.DockerKBean;\n\npublic void cleanup() {\n    find(DockerKBean.class).ifPresent(dockerKBean -&gt; {\n        // Do something\n    });\n}\n</code></pre>"},{"location":"reference/kbeans/#configure-a-kbean-from-another-kbean","title":"Configure a Kbean from another KBean.","text":"<p>Whether you want to create a JeKa plugin or simply configure a build, the approach is the same:  create a <code>KBean</code> and configure an existing one.</p> <p>For example, to configure a build, you can create a <code>Build</code> class as follows:</p> <p><pre><code>class Build extends KBean {\n\n    public boolean skipIT;\n\n    @JkPreInit\n    private static void preInit(ProjectKBean projectKBean) {\n        projectKBean.tests.progress = JkTestProcessor.JkProgressStyle.PLAIN;\n    }\n\n    @JkPostInit(required = true)\n    private void postInit(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n        project.flatFacade.dependencies.compile\n                .add(\"com.google.guava:guava:33.3.1-jre\")\n                .add(\"org.openjfx:javafx-base:21\");\n        project.flatFacade.dependencies.test\n                .add(\"org.junit.jupiter:junit-jupiter:5.8.1\");\n        project.flatFacade\n                .addTestExcludeFilterSuffixedBy(\"IT\", skipIT);\n    }\n\n    @JkPostInit\n    private void postInit(MavenKBean mavenKBean) {\n\n        // Customize the published pom dependencies\n        mavenKBean.getMavenPublication().customizeDependencies(deps -&gt; deps\n                .withTransitivity(\"com.google.guava:guava\", JkTransitivity.RUNTIME)\n                .minus(\"org.openjfx:javafx\")\n        );\n    }\n\n}\n</code></pre> This KBean defines a <code>Build</code> class that customizes the <code>project</code> and <code>maven</code> KBeans. </p>"},{"location":"reference/kbeans/#pre-initialize-kbeans","title":"Pre-initialize KBeans","text":"<p>The <code>preInit</code> methods are invoked before the KBean is instantiated; therefore, they must be declared as <code>static</code>. These methods are applied to the target KBean immediately after it is instantiated but before it is initialized. This means they are executed prior to the injection of properties or command-line values.</p> <p>The sole purpose of <code>preInit</code> methods is to provide default values, which can later be overridden by properties or command-line arguments. They should not perform further configuration, as the target KBean has not yet been fully initialized when these methods are invoked.</p>"},{"location":"reference/kbeans/#post-initialize-kbeans","title":"Post-initialize KBeans","text":"<p>The <code>postInit</code> methods are invoked only if their respective <code>KBean</code> is fully initialized.  This occurs after its properties and command-line values have been injected, and its <code>init()</code> method has been executed.</p> <p>The <code>required = true</code> attribute, means that the KBean project must be instantiated by JeKa, if not already setup.</p> <p>For example, when executing <code>jeka project: pack</code>, the <code>ProjectKBean</code> will be initialized with the settings provided by  command-line arguments and <code>@project...=</code> properties defined in the jeka.properties file.  The instance will then be passed to the <code>postInit</code> method before invoking the <code>pack</code> method.</p> <p>When executing <code>jeka maven: publish</code>, the <code>project</code> KBean will be implicitly loaded and configured,  followed by the same process for the <code>maven</code> KBean, before invoking the <code>publish</code> method.</p>"},{"location":"reference/kbeans/#lifecycle","title":"Lifecycle","text":"<p>Before Kbean methods are executed, Kbeans are configured as described in the detailed sequence:</p> <pre><code>sequenceDiagram\n    participant RB as Run Base\n    participant IN as Init class resolver\n    participant IT as Instantiater\n    participant KB as KBean\n    participant PR as Pre-initializer\n    participant PO as Post-initializer\n    participant RK as Registered KBeans\n\n    RB-&gt;&gt;IN:  Discover classes to init\n    RB-&gt;&gt;PR:  Register pre-init methods\n    RB-&gt;&gt;IT:  Instantiate classes to init\n    IT-&gt;&gt;KB:  New\n    IT-&gt;&gt;RK:  Register Kbean instance\n    IT-&gt;&gt;PR:  Pre-initialise KBean\n    IT-&gt;&gt;KB:  Inject fields annotated with @JkInject\n    IT-&gt;&gt;KB:  Inject values from properties\n    IT-&gt;&gt;KB:  Inject values from Command-line\n    IT-&gt;&gt;KB:  Init()\n    IT-&gt;&gt;PO:  Register KBean post-init methods\n    RB-&gt;&gt;PO:  Post-initialize all initialized KBeans</code></pre>"},{"location":"reference/kbeans/#post-initialisation","title":"Post initialisation.","text":"<p>One all the KBean has been initialized, bean already initialized or extra one can be invoked from the KBean methods.</p> <pre><code>sequenceDiagram\n    participant AK as A KBean\n    participant RB as Run Base\n    participant IT as Instantiater\n    participant KB as KBean\n    participant PR as Pre-initializer\n    participant PO as Post-initializer\n    participant RK as Registered KBeans\n\n    AK-&gt;&gt;RB:  Load a KBean \n    RB-&gt;&gt;RK:  Find if KBean is already instantiated\n    RB--&gt;&gt;AK:  Returns Kbean instance if found\n    RB-&gt;&gt;IT:  Initialise KBean\n    IT-&gt;&gt;RK:  Register KBean\n    RB-&gt;&gt;PO:  Register KBean post-init methods\n    RB-&gt;&gt;PO:  Post-initialize all initialized KBeans\n    RB--&gt;&gt;AK:  </code></pre> <pre><code>classDiagram\n    class JkRunBase {\n        +Path baseDir\n        +KBean initKBean\n        +KBean defaultKBean\n        +JkProperties properties\n        +List dependencies\n\n        +KBean load()\n        +KBean find()\n        +List getKBeans()\n\n    }\n\n    class KBean {\n        +JkRunbase runbase\n    }\n\n    JkRunBase \"1\" &lt;--&gt; \"0..*\" KBean\n    JkRunBase --&gt; \"0..*\" BaseDir: Imported Base Dirs (multi-modules)\n\n    note for JkRunBase \"There is only one JkRunBase per base folder.&lt;br/&gt;The base folder is the project root.&lt;br/&gt;In multi-module projects, usually one JkRunBase exists per module.\"\n    note for BaseDir \"This class doesn\u2019t exist. It represents the base directory &lt;br/&gt;of another runbase in a multi-module project.\"\n</code></pre>"},{"location":"reference/kbeans/#multi-project-setup","title":"Multi-Project setup","text":"<p>In multi-project scenarios, it is common for a KBean in one project to access a KBean instance from another project. This can be achieved in a statically typed manner:</p> <ol> <li>In the master KBean, declare a field of type <code>KBean</code> (e.g., <code>KBean importedBuild;</code>). This field does not need to be public.</li> <li>Annotate the field, by specifying the relative path of the imported project (e.g., <code>@JkInjectRunbase(\"../anotherModule\")</code>).</li> <li>Run the command <code>jeka intellij: iml</code> or <code>jeka eclipse: files</code> to refresh project metadata.</li> <li>Change the declared field type from <code>KBean</code> to the concrete type of the imported KBean.</li> <li>The master KBean can now access the imported KBean in a type-safe manner.</li> <li>For an example, see this implementation.</li> </ol> <p>Tip</p> <p>Ensure that the imported KBean uses <code>KBean#getBaseDir</code> for handling file paths. This practice ensures safe execution from any working directory.</p> <p>For multi-module projects, use <code>JkInject</code> to access sub-module KBeans.</p> <p><pre><code>import dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\nimport dev.jeka.core.tool.JkInject;\n\nimport java.util.List;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\npublic class MasterBuild extends KBean {\n\n    @JkInject(\"./foo\")\n    ProjectKBean fooProject;\n\n    @JkInject(\"./bar\")\n    ProjectKBean barProject;\n\n    @JkDoc(\"For all sub-modules: clean, compile, test, create jar files, and publish them.\")\n    public void buildAll() {\n        List.of(fooProject, barProject).forEach(projectKbean -&gt; {\n            projectKbean.clean();\n            projectKbean.pack();\n            MavenKBean mavenKBean = projectKbean.load(MavenKBean.class);\n            mavenKBean.publishLocal();\n        });\n    }\n}\n</code></pre> In this example, JeKa initializes KBeans from the sub-modules ./foo and ./bar, then injects them into the <code>MasterBuild</code> KBean.</p> <p>We can create or load a KBean on the fly using the <code>KBean#load</code> method. This means we only need to declare one KBean per sub-module.</p> <p>Another option is to inject <code>JkRunbase</code> and make all calls through it:</p> <pre><code>import dev.jeka.core.tool.JkRunbase;\nimport dev.jeka.core.tool.builtins.project.ProjectKBean;\nimport dev.jeka.core.tool.builtins.tooling.maven.MavenKBean;\nimport dev.jeka.core.tool.JkInject;\n\nimport java.util.List;\n\n@JkDoc(\"A simple example to illustrate KBean concept.\")\npublic class MasterBuild extends KBean {\n\n    @JkInject(\"./foo\")\n    JkRunbase foo;\n\n    @JkInject(\"./bar\")\n    JkRunbase bar;\n\n    @JkDoc(\"For all sun-modules: clean, compile, test, create jar files, and publish them.\")\n    public void buildAll() {\n        List.of(foo, bar).forEach(runbase -&gt; {\n            ProjectKBean projectKBean = runbase.load(ProjectKBean.class);\n            projectKbean.clean();\n            projectKbean.pack();\n            MavenKBean mavenKBean = runbase.load(MavenKBean.class);\n            mavenKBean.publishLocal();\n        });\n    }\n}\n</code></pre> <p>For larger sub-project structures, use <code>KBean#getImportedKBeans()</code> to list all sub-modules, either recursively or not.</p> <pre><code>@JkDoc(\"For all sub-modules: compile, test, create jar files, and publish them.\")\npublic void buildAll() {\n    this.getImportedKBeans().get(ProjectKBean.class, true).forEach(ProjectKBean::pack);\n    this.getImportedKBeans().get(MavenKBean.class, true).forEach(MavenKBean::publish);\n}\n</code></pre>"},{"location":"reference/multi-modules/","title":"Working with Multi-Module Projects in JeKa","text":"<p>Multi-module support in JeKa allows developers to manage and build complex projects with multiple modules in a clean   and effective manner.</p>"},{"location":"reference/multi-modules/#structure-of-a-multi-module-project","title":"Structure of a Multi-Module Project","text":"<p>A multi-module project in JeKa consists of:</p> <ul> <li>A parent directory that contains the configuration and dependencies shared across all modules, and declares the location of child modules.</li> <li>Multiple child modules, which are independent or interdependent within the project.</li> </ul> <p>Example: <pre><code>project-root\n\u251c\u2500\u2500 jeka.properties\n\u251c\u2500\u2500 jeka-src (optional)\n\u251c\u2500\u2500 module-1\n\u2502   \u251c\u2500\u2500 jeka.properties\n\u2502   \u251c\u2500\u2500 dependencies.txt\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u2514\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 ...\n\u251c\u2500\u2500 module-2\n\u2502   \u251c\u2500\u2500 jeka.properties\n\u2502   \u251c\u2500\u2500 dependencies.txt\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u2514\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500 module-Xxxx ...\n</code></pre> To be recognized as a parent project, jeka.properties file must specify the <code>_jeka.child-bases</code> property  indicating where are located child modules.</p> <p>You can set it as <code>_jeka.child-bases=module1, module2, ...</code> or <code>_jeka.child-bases=*</code>. If you use <code>*</code>, Jeka will scan child directories and include any with a Jeka structure.</p> <p>It's also possible to use hierarchical structures as: <pre><code>parent-project\n\u251c\u2500\u2500 jeka.properties\n\u251c\u2500\u2500 jeka-src (optional)\n\u251c\u2500\u2500 core\n\u2502   \u251c\u2500\u2500 jeka.properties\n\u2502   \u251c\u2500\u2500 dependencies.txt\n\u2502   \u251c\u2500\u2500 src\n\u2502   \u2502   \u251c\u2500\u2500 main\n\u2502   \u2502   \u2514\u2500\u2500 test\n\u2502   \u2514\u2500\u2500 ...\n\u2514\u2500\u2500\u2500 plugins\n     \u251c\u2500\u2500 jeka.properties\n     \u251c\u2500\u2500 dependencies.txt\n     \u251c\u2500\u2500 plugin-common\n     \u2502   \u251c\u2500\u2500 dependencies.txt\n     \u2502   \u251c\u2500\u2500 jeka.properties\n     \u2502   \u2514\u2500\u2500 src\n     \u251c\u2500\u2500 plugin-1\n     \u2502   \u251c\u2500\u2500 dependencies.txt\n     \u2502   \u251c\u2500\u2500 jeka.properties\n     \u2502   \u2514\u2500\u2500 src\n     \u251c\u2500\u2500 plugin-2\n     \u2502   \u251c\u2500\u2500 dependencies.txt\n     \u2502   \u251c\u2500\u2500 jeka.properties\n     \u2502   \u2514\u2500\u2500 src\n     \u2514\u2500\u2500 ...\n</code></pre></p>"},{"location":"reference/multi-modules/#example-of-jekaproperties-for-parent-project","title":"Example of jeka.properties for parent project","text":"<p><pre><code># Define Java version for all modules\njeka.java.version=21\n\n# specify location of child modules\n_jeka.child-base=core, plugins/*\n\n# Parent module does not contain a JVM project\n_@project=off\n\n# Common settings for child modules containing a JVM project\n@project.compilation.compilerOptions=-g\n@project.pack.javadocOptions=-notimestamp\n\n# Enable Git-based versioning for Maven\n@maven.pub.gitVersioning.enable=true\n\n# Parent module Maven-specific settings\n_@maven.pub.moduleId=dev.jeka:bom\n_@maven.pub.parentBom=true\n</code></pre> Child modules inherit from the properties defined in their parent dir jeka.properties files recursively.</p> <p>To make a property non transmitted to the chidren, we need to prefix it with <code>_</code></p>"},{"location":"reference/multi-modules/#typical-jekaproperties-for-child-module","title":"Typical jeka.properties for child module","text":"<pre><code># The child module defines a JVM project with specific settings\n@project=on\n@project.pack.mainClass=dev.jeka.core.tool.Main\n+@project.compilation.compilerOptions=-Xlint:none\n\n# Specific Maven publish settings\n@maven.pub.moduleId=dev.jeka:jeka-core\n</code></pre> <p>The child modules inherit properties from the parent, except for properties prefixed with <code>_</code></p> <p>When a property declaration is prefixed with <code>+</code>, the specified value is happened to the parent value instead of overriding it. In this example, <code>-g -Xlint:none</code> will be passed to the compiler options.</p>"},{"location":"reference/multi-modules/#running-jeka-commands","title":"Running JeKa commands","text":"<p>When executing a JeKa command on a parent project, the specified actions are delegated to all child modules, then to the parent one.</p> <p>If a module is not concerned with a given KBean, it should declare it in its jeka.properties file, as <code>@project=off</code>.</p> <p>If we run the following command on the above example:</p> <p><pre><code>jeka project: pack maven: publish\n</code></pre> This will first run <code>project: test pack</code> method on all child modules. Parent module won't execute these actions  cause it does not declare explicitly project KBean (<code>@project=on</code> is absent).</p> <p>The the <code>maven: publish</code> action is invoked on all child modules and the parent module as it declares it explicitly (<code>@maven=on</code>).</p> <p>If a child module is not concerned by a specific KBean, it should explicitly disabled if (e.g. <code>@maven=off</code>). This could be the case if plugin-common should not be published as a Maven artifact.</p>"},{"location":"reference/multi-modules/#running-child-module","title":"Running child module","text":"<p>If you need to run some Jeka command for a child modules, you have 3 options:</p> <ol> <li> <p>Use <code>-cb</code> (alias <code>--child-base</code>) option    <pre><code>jeka -cb=plugins/plugin-1 project: test pack\n</code></pre></p> </li> <li> <p>Execute actions from child module directory:    <pre><code>cd plugins/plugin-1\njeka project: test pack\n</code></pre>    This approach works well, but code in <code>jeka-src</code> declared in parent module won't be taken in account.</p> </li> </ol>"},{"location":"reference/multi-modules/#managing-dependenciestxt","title":"Managing dependencies.txt","text":"<p>In multi-module project, we often need to define centrally the versions of the libaries we want to use accross all the modules.</p> <p>Example: plugins/dependencies.txt<pre><code>[version]\ncom.google.guava:guava:33.4.7-jre\norg.projectlombok:lombok:1.18.38\norg.junit:junit-bom:5.12.2@pom  # Use versions defined in this BOM\n</code></pre></p> <p>Child module <code>dependencies.txt</code> files inherit the <code>version</code> section from the parent directory's <code>dependencies.txt</code>, if present.</p> <p>Module interdependency can be defined using the module's relative path.</p> plugins/plugin-1/dependencies.txt<pre><code>[compile]\n../plugin-common \ncom.google.guava:guava\n\n[compile-only]\norg.projectlombok:lombok\n\n[test]\norg.junit.jupiter:junit-jupiter\norg.junit.platform:junit-platform-launcher\n</code></pre>"},{"location":"reference/multi-modules/#programmatic-approach","title":"Programmatic Approach","text":"<p>With combining multi-module and programmatic approach,you can:</p> <ul> <li>Use jeka-src code from one module in another module that depends on it.</li> <li>Import a run base (or any <code>KBean</code>) from one module into another.</li> </ul>"},{"location":"reference/multi-modules/#using-jeka-src-code-from-another-module","title":"Using jeka-src Code from Another Module","text":"<p>You may need to share build code between multiple modules. This is easy to do using the <code>@JkDep</code> annotation, which lets you import code from another module.</p> <p>Example:</p> <p>Let\u2019s say there\u2019s a central set of dependencies in the jeka-src folder of the <code>plugin-common</code> module. These dependencies can be defined as constants in a class, like a <code>PluginCommon</code> class, so they can be reused in other modules.</p> plugins/plugin-common/jeka-src/PluginCommon.java<pre><code>class Plugin1Common {\n\n    static final JkDependencySet LOG_LIBS = JkDependencySet.of()\n            .and(\"ch.qos.logback:logback:0.5\")\n            .and(\"org.slf4j:slf4j-api:2.0.17\");\n\n}\n</code></pre> <p>We can reuse the code in jeka-src of plugin-1 module, for instance, as below:</p> <p>plugins/plugin-1/jeka-src/Plugin1Custom.java<pre><code>import dev.jeka.core.api.depmanagement.JkDependencySet;\nimport dev.jeka.core.tool.JkDep;\n\n@JkDep(\"../plugin-common\")\nclass Plugin1Custom extends KBean {\n\n    private JkDependencySet logLibs = PluginCommon.LOG_LIBS;\n\n}\n</code></pre> The specified path is relative to the module declaring the annotation.</p>"},{"location":"reference/multi-modules/#import-kbeans-from-other-modules","title":"Import KBeans from other modules","text":"<p>You may use some KBeans from another modules. For example you want run kbean action for a given list of child modules.</p> <pre><code>class Custom extends KBean {\n\n    @JkInject(\"../../core\")\n    private ProjectKBean coreProjectKBean;\n\n    @JkInject(\"../pluginCommon\")\n    private ProjectKBean pluginCommonProjectKBean;\n\n    public void doXxxx() {\n        coreProjectKBean.pack();\n        pluginCommonProjectKBean.pack();\n        Path coreClasses = coreProjectKBean.project.compile.layout.resolveClassDir();\n        ...\n    }\n\n    @JkPostInit\n    private void postInit(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n        project.flatFacade\n                .setMainArtifactJarType(JkProjectPackaging.JarType.FAT)\n                .dependencies.compile\n                .add(coreProjectKBean.project.toDependency());\n    }\n\n}\n</code></pre>"},{"location":"reference/multi-modules/#import-runbases-from-other-modules","title":"Import runbases from other modules","text":"<p>In similar way, we can import runbases from aother modules.</p> <pre><code>class Custom extends KBean {\n\n    @JkInject(\"core\")\n    private JkRunbase coreRunbase;\n\n    public void delegate() {\n        JkProject coreProject = coreRunbase.load(ProjectKBean.class).project;\n        coreProject.test.run();\n        coreProject.pack.run();\n        ...\n    }\n\n}\n</code></pre>"},{"location":"reference/multi-modules/#discover-child-modules","title":"Discover child modules","text":"<p>From a parent module we can programmatically access to the child modules.</p> <pre><code>class MasterBuild extends KBean {\n\n    public boolean runIT = true;\n\n    public void doAll() {\n        this.getRunbase().getChildRunbases().stream()\n                .map(runbase -&gt; runbase.find(ProjectKBean.class))\n                .filter(Optional::isPresent)\n                .forEach(this::make);\n        this.getRunbase().getChildRunbases().stream()\n                .map(runbase -&gt; runbase.load(MavenKBean.class))\n                .forEach(MavenKBean::publish);\n    }\n\n    private void make(ProjectKBean projectKBean) {\n        JkProject project = projectKBean.project;\n        project.test.selection.addExcludePatternsIf(!runIT, JkTestSelection.IT_PATTERN);\n        project.test.run();\n        project.pack.run();\n    }\n}\n</code></pre>"},{"location":"reference/properties/","title":"Properties","text":"<p>Properties are pairs of String key-value that are used across Jeka. They typically carry urls, local paths, tool versions, or credentials. </p> <p>Properties can be defined at different levels, in order of precedence :</p> <ul> <li>System properties: Properties can be defined using system properties as <code>-DpropertyName=value</code>. System properties can   be injected from the Jeka command line.</li> <li>OS environment variables: Properties can also be defined as OS environment variables.</li> <li>Project: Defined in [Project Root]/jeka.properties. Typically used to store tool versions (e.g. <code>jeka.kotlin.version=1.5.21</code>).</li> <li>Global: Defined in the [User Home]/.jeka/global.properties file. Typically used to define urls, local paths, and credentials.</li> </ul> <p>Properties inherit from project properties defined in project parent folders (if extant). </p> <p>Here, project2 will inherit properties defined in project1/jeka/local.properties : <pre><code>project1\n   + jeka.properties\n   + project2   (sub-project)\n      + jeka.properties\n</code></pre></p> <p>Info</p> <p>Properties support interpolation via <code>${}</code>tokens. </p> <p>For example, if we define the following properties : <code>foo=fooValue</code> and <code>bar=bar ${foo}</code> then <code>JkProperties.get(\"bar\")</code> will return 'bar fooValue'.</p>"},{"location":"reference/properties/#standard-properties","title":"Standard properties","text":"<ul> <li><code>jeka.java.version</code>:  Target JVM version for compiled files.</li> <li><code>jeka.jdk.X=</code> location of the JDK version X (e.g., jeka.jdk.11=/my/java/jdk11). It is used to compile projects when    the project JVM target version differs from the Jeka running version.</li> <li><code>jeka.kotlin.version</code>: Version of Kotlin used to compile both def and Kotlin project sources.</li> <li><code>jeka.inject.classpath</code>: Additional dependencies that will be added to the JeKa classpath.     We can specify many dependencies separated by <code>&lt;space&gt;</code>.    It can be either Maven coordinates or file paths. If a file path is relative, it is resolved     upon project base dir (could be distinct from working dir).    Example: <code>jeka.inject..classpath=dev.jeka:springboot-plugin  com.google.guava:guava:31.1-jre ../other-project/jeka/output/other-project.jar</code></li> <li><code>jeka.kbean.default</code>: The KBean to use when omitting mentioning KBean prefix (or using <code>kb#</code> prefix) in command or field assignment.    Example: declaring <code>jeka.kbean.default=myBean</code>, makes the following expressions equivalent : <code>myBean#run</code>, <code>#run</code>, and <code>kb#run</code>.</li> </ul>"},{"location":"reference/properties/#command-shorthands","title":"Command shorthands","text":"<ul> <li><code>jeka.cmd.xxx=</code> define an alias that can be substituted for its value in the command line using the <code>:</code> symbol.     Example : <code>jeka.cmd.myBuild=${jeka.cmd.build} sonarqube#run jacoco#</code> allows you to simply execute <code>jeka :myBuild</code>.</li> <li><code>jeka.cmd._append=</code> will append the argument to every Jeka execution command.    Example : <code>jeka.cmd._append=@dev.jeka:springboot-plugin</code> will add springboot plugin to Jeka classpath for each execution.    This property can be split when the argument line becomes too long. In fact, every property starting with <code>jeka.cmd._append</code> will     be taken in account to assemble the extra command line arguments. For example, we can define <code>jeka.cmd._append.0=</code>, <code>jeka.cmd._append.1=</code>, and so on.</li> </ul> <p>Note</p> <p>Command shorthands are a really powerful mechanism for getting rid of build classes. Many projects can be built using properties only!</p>"},{"location":"reference/properties/#repositories","title":"Repositories","text":"<p>The repositories used to download and publish artifacts can be defined using properties. The download repositories are set using the <code>jeka.repos.download</code> property, while the publish repository is defined using <code>jeka.repos.publish</code>.</p> <p>Use JkRepoFromProperties class to get the repositories defined by properties.</p> <p>Note</p> <p>By default, when no repository is configured, artifacts are downloaded on Maven Central repo.</p> <p>Using single repo <pre><code>jeka.repos.download=https://my.company/repo\n</code></pre></p> <p>Using multiple repos <pre><code>jeka.repos.download=https://my.company/repo1, file://path/to/a/local/repo \n</code></pre></p> <p>Using single repo with credentials <pre><code>jeka.repos.download=https://my.company/repo\njeka.repos.download.username=myUsername\njeka.repos.download.password=myPassword\n</code></pre></p> <p>Specifying http headers to include in each request towards the repo <pre><code>jeka.repos.download.headers.my-header-name=myHeaderValue\njeka.repos.download.headers.another-header-name=anotherHeaderValue\n</code></pre></p> <p>Same for the publish repo <pre><code>jeka.repos.publish=https://my.company/myrepo\neka.repos.publish.username=myUsername\njeka.repos.publish.password=myPassword\njeka.repos.download.headers.Authorization=Bearer:: XHrU8hHKJHJ454==67g\n</code></pre></p> <p>For convenience, we can define multiple repositories and reference them using aliases <pre><code>jeka.repos.myRepo1=https://my.company/repo\njeka.repos.myRepo1.username=myUsername\njeka.repos.myRepo1.password=myPassword\n\njeka.repos.myRepo2=https://my.company/repo2\njeka.repos.myRepo2.username=myUsername2\njeka.repos.myRepo2.password=myPassword2\n\njeka.repos.download=myRepo1, myRepo2\njeka.repos.publish=myRepo2\n</code></pre></p> <p>Aliases are predefined for Maven Central and Jeka GitHub Repos <pre><code>jeka.repos.download=https://my.company/repo1, mavenCentral, jekaGithub\njeka.repos.jekaGithub.username=myGithubAccountName\njeka.repos.jekaGithub.password=myGithubPersonalAccessToken\n</code></pre></p>"},{"location":"reference/properties/#kbean-field-value-injection","title":"KBean field value injection","text":"<p>If a property is named as <code>xxx#yyyyy</code> then Jeka will try to inject its value  in public field <code>yyyyy</code> of KBean <code>xxx</code>. </p> <p>examples: <pre><code>@springboot.springbootVersion=2.4.7\n@project.test.skip=true\n</code></pre></p> <p>Note</p> <p>There is a slight difference between using <code>-D@project.test.skip=true</code> and  <code>@project.test.skip=true</code> in the command line. For the former, the field is injected via system properties, this means that for multi-modules projects, the value will be injected on every Jeka module. For the latter, the value will be injected only on the root module.</p>"},{"location":"reference/properties/#multivalue-fields","title":"Multivalue fields","text":"<p>Multi-value let to use map-like structures in KBean objects.</p> <p>Example:</p> <p><pre><code>class MyBean extends KBean {\n\n      public final JkMultiValue&lt;String&gt; phones = JkMultiValue.of(String.class);\n      public final JkMultiValue&lt;Address&gt; addresses = JkMultiValue.of(Address.class);\n\n      public static class Address {\n\n          @JkDoc(\"The street name and number\")\n          public String street;\n          public int zip;\n      }\n }\n</code></pre> <code>JkMultivalue</code> is a like-map structure that let access value according a give <code>key</code>.</p> <pre><code>Address mainAddress = myBean.addresses.get(\"main\");\nString gsmNum = myBean.phones.get(\"gsm\");\n</code></pre> <p>These values can be set using jeka.properties files or command-line argument as: <pre><code>@myBean.phones.gsm=0978765432\n@myBean.phones.home=0111334455\n\n@myBean.addresses.main.street=Georges street 32\n@myBean.addresses.main.zip=50600\n</code></pre></p> <p>Note</p> <p><code>JkMultiValue</code> objects support nesting, allowing you to create hierarchical data structures with multiple levels of key-value pairs.</p>"},{"location":"tutorials/basics/","title":"Getting Started - Basics","text":"<p>Prerequisite: Jeka must be installed.</p> <p>Let's create some simple scripts to understand the basic concepts.</p>"},{"location":"tutorials/basics/#create-a-basic-script","title":"Create a basic script","text":"<p>To create a basic Jeka structure, execute: <pre><code>jeka base: scaffold\n</code></pre></p> <p>This generates a jeka-src/Script.java file, which is an example of Java code invokable from command line.</p> <pre><code>class Script extends KBean {\n\n    @JkDoc(\"Person to whom the greeting is intended\")\n    public String name = \"World\";\n\n    @JkDoc(\"Print greeting on console\")\n    public void hello() {\n        String greetings = \"Hello \" + name + \" !\";\n        System.out.println(greetings);\n    }\n\n}\n</code></pre> <p>Tip</p> <p>If you use IntelliJ, execute <code>jeka intellij: iml</code> to synchronize the IDE metadata.  If IntelliJ does not reflect changes, execute <code>jeka intellij: initProject</code> By default, 'jeka-src' is declared as a test source folder of the Intellij module. You can make it live in its own module by executing <code>jeka intellij: jekaSrcAsModule</code></p> <p>Execute <code>jeka hello</code>. A Hello World message is printed on console. <pre><code>Hello World !\n</code></pre> Execute <code>jeka hello name=JeKa</code>. A Hello JeKa message is printed on console. <pre><code>Hello JeKa !\n</code></pre></p> <p>Add a similar <code>hi</code> method in Script.java <pre><code>public void hi() {\n    System.out.println(\"Hi \" + name + \" !\");\n}\n</code></pre> and execute <code>jeka hi</code>. you notice that your change has been automatically taken in account  without any extra action from your part.</p> <p>You can add as many public void no-args methods or public fields in your scripts. The accepted public field types are mentioned here.</p> <p>Tip</p> <p>You can document your script by annotation Class, public fields or public method with <code>@JkDoc</code> annotation. This will be visible when executing: <code>jeka script: --doc</code>. Note that only part before first breaking line of the doc content will be displayed as summary.</p>"},{"location":"tutorials/basics/#define-jdk-version","title":"Define JDK version","text":"<p>We can select which JDK will run the script bu using properties</p> <p>Edit jeka.properties: <pre><code>jeka.java.version=23\n</code></pre> Executing <code>jeka hello</code> will trigger a download of JDK 22 (if not already present), prior executing  the script. JeKa caches the downloaded JDKs in [USER HOME]/.jeka/cache/jdks.</p> <p>This is possible to choose another distribution by using the following properties : <pre><code>jeka.java.version=21\njeka.java.distrib=corretto\n</code></pre> If you don't want JeKa manage distribution for you, you can choose explicitly the SDK location: <pre><code>jeka.java.version=22\njeka.sdk.17=/my/jdks/22-corretto\n</code></pre></p> <p>Note</p> <p>The properties can also be set by using system properties or OS Environment variables. Continuous Integration machine can define env variables as <code>jeka.sdk.17</code> to override the SDK location.</p>"},{"location":"tutorials/basics/#define-jeka-version","title":"Define JeKa version","text":"<p>Your script may depends of some unstable JeKa APIs. To make sure your script will always work,  whatever JeKa version is installed at client/user side, mention the following properties in  jeka.properties, as : <pre><code>jeka.version=0.11.24\n</code></pre></p>"},{"location":"tutorials/basics/#add-dependencies","title":"Add dependencies","text":"<p>Your script can depends on libs located in a Maven repository, or on folder/jar located on file system.</p> <p>Annotate <code>Script</code> class with  : <pre><code>import dev.jeka.core.tool.JkDep;\n\n@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")\nclass Script extends KBean {\n</code></pre> ... and execute <code>jeka intellij: iml</code> to use the imported library in IDE.</p> <p>Add a method with following body: <pre><code>public void ascii() throws Exception {\n    System.out.println(FigletFont.convertOneLine(\"Hello\"));\n}\n</code></pre> ... and execute <code>jeka ascii</code>. This will display on console : <pre><code>  _   _      _ _       \n | | | | ___| | | ___  \n | |_| |/ _ \\ | |/ _ \\ \n |  _  |  __/ | | (_) |\n |_| |_|\\___|_|_|\\___/ \n</code></pre> This library has no transitive dependency, but it could have. Try to import any library with transitive  dependencies and execute <code>jeka --inspect</code>.  This displays runtime information about JeKa run, including the resulting classpath.</p> <p>You can add, as many <code>@JkDep</code> annotations you need, on the class.</p> <p>Note</p> <p>JeKa also accept JBang notation for declaring dependencies. You can use <code>//DEPS com.github.lalyos:jfiglet:0.0.9\"</code> in place of <code>@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")</code></p>"},{"location":"tutorials/basics/#use-bom-dependencies","title":"Use BOM dependencies","text":"<p>In some cases, we may need to use a BOM dependency which provides versioning information on other dependencies we might use.</p> <pre><code>@JkDep(\"com.google.cloud:libraries-bom::pom:5.0.0\")\n@JkDep(\"com.google.cloud:google-cloud-storage\")\n@JkDep(\"com.google.cloud:oogle-cloud-bigquery\")\n</code></pre>"},{"location":"tutorials/basics/#dependencies-on-file-system","title":"Dependencies on file system","text":"<p>There is 2 way of adding local file system dependencies :</p> <ul> <li>simply add a jar in jeka-boot dir (create this dir if not present)</li> <li>annotate class with <code>@JkDep()</code></li> </ul> <pre><code>@JkDep(\"../other-project/mylib.jar\")\n@JkDep(\"../other-project/my-classes\")\n</code></pre>"},{"location":"tutorials/basics/#define-dependencies-with-properties","title":"Define dependencies with properties","text":"<p>Dependencies can also be mentioned using the <code>jeka.classpath=</code> property in jeka.properties file.</p> <pre><code>jeka.classpath=\\\n  com.google.cloud:libraries-bom::pom:5.0.0 \\\n  com.google.cloud:google-cloud-storage \\\n  com.google.cloud:oogle-cloud-bigquery\n</code></pre>"},{"location":"tutorials/basics/#add-compilation-directives","title":"Add compilation directives","text":"<p>Classes from jeka-src are compiled behind-the-scene prior of being executed.</p> <p>We can inject some compilation directive to the compiler by annotating the Script class  with <code>@JkInjectCompileOption()</code>. </p> <p>For example we can turn off some warning messages using  <pre><code>@JkCompileOption(\"-Xlint:-options\")\n</code></pre></p>"},{"location":"tutorials/basics/#multi-file-scripts","title":"Multi-file scripts","text":"<p>jeka-src can host as many scripts and utility classes as you need. For now, we have a single  class located in default package, but we could have located Script.java in org.example the same way.</p> <p>Creating many script classes in a single project isn't a common use case but it will help to understand  some concepts related to KBeans</p> <ol> <li>In the existing project, create a new class Build.java at the root of jeka-src. This class should extend <code>KBean</code>.</li> <li> <p>Add a public void no-args method foo in this class <pre><code>import dev.jeka.core.tool.KBean;\n\npublic class Build extends KBean {\n\n    public void foo() {\n        System.out.println(\"Method 'foo()' is running.\");\n    }\n}\n</code></pre> and execute <code>jeka foo</code> to notice that this method is actually run.</p> </li> <li> <p>Execute <code>jeka hello</code>. You should get the following error message    <pre><code>ERROR: Unmatched argument at index 0: 'hello'\n</code></pre>     This is because,  we did not mention the KBean to use as default when invoking method.     JeKa explores jeka-src, with width-first strategy, to find the first class implementing <code>KBean</code>.      In this case, Build.java won.</p> <p>Execute <code>jeka foo</code>. It should display: <pre><code>Method 'foo()' is running.\n</code></pre></p> </li> <li> <p>To execute a method of a specific KBean, we should mention it explicitly as: <code>jeka [kbean]: [method]</code>.</p> <p>Execute: <code>jeka script: hello</code>. This should display on console: <pre><code>Hello World !\n</code></pre></p> </li> <li> <p>We can specify the KBean to use as default using <code>jeka.kbean.default=</code>property in jeka.properties.     <pre><code>jeka.kbean.default=script\n</code></pre></p> <p>You can check the actual default KBean, by executing <code>jeka --inspect</code> and check for the Default KBean entry.</p> <p>Note</p> <p>A given <code>KBean</code> class can accept many names to be referenced :</p> <ul> <li>Its fully qualified class name (as org.eaxample.kbeans.MyCoolKBean)</li> <li>Its short class name (as MyCoolKBean))</li> <li>Its short class name withj uncapitalized first-letter (as myCoolKBean)</li> <li>If the class name is ending with 'KBean', the KBean suffix can omitted (as myCool)</li> </ul> </li> </ol>"},{"location":"tutorials/basics/#configure-default-values","title":"Configure default values","text":"<p>We can override the value of public fields of KBeans by using properties as : <pre><code>@script.name=Everybody\n</code></pre></p> <p>Add the last properties tou your jeka.properties file and xecute 'jeka hello'. You should get :: <pre><code>Hello Everybody\n</code></pre></p>"},{"location":"tutorials/basics/#make-kbeans-interact-with-each-other","title":"Make KBeans interact with each other","text":"<p>KBean mechanism plays a central role in JeKa ecosystem. In the following section, we will play around it to make you more familiar with.</p> <ol> <li> <p>Set <code>jeka.kbean.default=script</code> property in the jeka.properties file and remove <code>@script.name=Everybody</code>     added in previous step.    <pre><code>jeka.kbean.default=script\n</code></pre>    Also, make sure that Script.java and Build.java  are still present in jeka-src dir.</p> </li> <li> <p>Add the following method in Build.java <pre><code>public class Build extends KBean {\n\n    @Override\n    protected void init() {\n        Script script = load(Script.class);  //  Get the singleton Script instance\n        script.name = \"Mates\";           \n    }\n</code></pre>    The init() method is called when a Kbean singleton is initialized by JeKa engine.</p> </li> <li> <p>Now, execute <code>jeka script: hello build:</code>. This initializes script and build KBean singletons then    invokes <code>Script.hello()</code> method.    <pre><code>Hello Mates !\n</code></pre>    What has happened ?    JeKa has initialized script and build KBeans, then has invoked <code>Script.hello()</code> method.    All KBeans to be initialized, are initialized prior any KBean method is invoked.</p> </li> <li> <p>If you simply execute <code>jeka script: hello</code>, you'll notice that this display <code>Hello world</code>. This is because     <code>build</code> is not initialized anymore.</p> <p>You can force it to be always initialized, by adding <code>@build=</code> property to jeka-properties file.</p> <p>Add it and retry <code>jeka script: hello</code>. It should display <code>Hello Mates</code></p> </li> </ol>"},{"location":"tutorials/basics/#classpath-kbeans","title":"Classpath KBeans","text":"<p>We distinct local KBeans (which are Java sources file defined in jeka-src) from classpath KBeans (which  are compiled classes lying in the Jeka classpath).</p> <p>Execute: <code>jeka --doc</code> to list all available KBeans. You'll notice the standard KBeans section that mentions  all KBeans bundled with JeKa out-of-the-box (and always available). These are typically classpath KBeans.</p> <p>For example, you can execute <code>jeka admin: openHomeDir</code> to open yourJeka Home directory.</p>"},{"location":"tutorials/basics/#add-kbeans-to-classpath","title":"Add KBeans to classpath","text":"<p>Adding KBeans to classpath just consists in adding a dependency that contains a KBean class. </p> <p>You can use <code>jeka.classpath</code> properties as : <pre><code>jeka.classpath=\\\n  dev.jeka:springboot-plugin  \\\n  dev.jeka:sonarqube-plugin \\\n  dev.jeka:openapi-plugin:0.11.0.1\n</code></pre></p> <p>or declare it using <code>@JkDep</code> annotation in any class from jeka-src.</p> <p>Note</p> <p>When omitting the version for a dependency of group 'dev.jeka', as in 'dev.jeka:springboot-plugin',  JeKa uses its own running version for resolving the coordinate. This is due that most of extension with 'dev.jeka' group share released in the same time than JeKa.</p>"},{"location":"tutorials/basics/#example-with-nodejs","title":"Example with NodeJs","text":"<p>This is also possible to augment classpath dynamically from the command line, using the <code>-cp</code>option.</p> <p>In this example, we'll add the nodeJs plugin. The plugin doanload Nodejs version 20.12.2 (if needed)  and then execute the specified command line.</p> <p><pre><code>jeka -cp=dev.jeka:nodejs-plugin nodeJs: version=\"20.12.2\" exec cmdLine=\"npx cowsay Hello JeKa\"\n</code></pre> This should display: <pre><code>Directory not found /Users/jerome/temp-jeka-tests/client-js, use current dir as working dir.\nTask: start-program &gt;npx cowsay Hello\n       ___________\n      &lt; Hello JeKa&gt;\n       -----------\n              \\   ^__^\n               \\  (oo)\\_______\n                  (__)\\       )\\/\\\n                      ||----w |\n                      ||     ||\n      npm notice \n      npm notice New minor version of npm available! 10.5.0 -&gt; 10.9.1\n      npm notice Changelog: &lt;https://github.com/npm/cli/releases/tag/v10.9.1&gt;\n      npm notice Run `npm install -g npm@10.9.1` to update!\n      npm notice \n</code></pre></p> <p>You can have more info about NodeJs plugin by executing  <pre><code>jeka -cp=dev.jeka:nodejs-plugin nodeJs: --doc\n</code></pre></p>"},{"location":"tutorials/build-base/","title":"Build Base","text":"<p>In this tutorial, we'll use the <code>base</code> KBean to build a Java application or library. </p> <p>This mode provides a layout between a single-file style like JBang and a full Maven/Gradle project.</p> <p>Visit this repository to have a concrete example.</p> <p>Prerequisite: Jeka must be installed.</p> <p>Tip</p> <p>Run <code>jeka base: --doc</code> to see all available options.</p>"},{"location":"tutorials/build-base/#scaffold-a-new-code-base","title":"Scaffold a New Code Base","text":"<p>Run <code>jeka base: scaffold scaffold.kind=APP</code> to create a base structure, ready for you to start coding right away.</p> <p>You\u2019ll get the following project structure: <pre><code>. \n\u251c\u2500\u2500 jeka-src             &lt;- Source root directory\n\u2502   \u251c\u2500\u2500 _dev             &lt;- Optional package containing all non-prod (build and test)\n\u2502   \u2502   \u251c\u2500\u2500 test\n\u2502   \u2502   \u2514\u2500\u2500 Custom.java  \n\u2502   \u2514\u2500\u2500 app              &lt;- Sugested base package for production code/resources\n\u2502       \u2514\u2500\u2500 App.java     \n\u251c\u2500\u2500 jeka-output          &lt;- Generated dir where artifacts as jars, classes, reports or doc are generated\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration  (Java and jeka version, kben configurations, ...)\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands\n</code></pre></p> <p>All your Java code is supposed to be in the jeka-src folder.</p> <p><code>_dev</code> is a special package for source code and dependencies used only for development (e.g., tests, builds). If you're new to Java, you can ignore or delete it.</p> <p>The scaffolded example includes an App class in the app package. You can add or modify classes in any package you like.</p>"},{"location":"tutorials/build-base/#sync-with-intellij","title":"Sync with IntelliJ","text":"<p>Run: <code>jeka intellij: iml --force</code> to sync the project with IntelliJ. If changes don't appear in IntelliJ, go to the project's root directory, then run: <code>jeka intellij: initProject</code>.</p>"},{"location":"tutorials/build-base/#add-dependencies","title":"Add Dependencies","text":"<p>The App.java class declares a <code>@JkDep</code> annotation to reference a library. You can add as many libraries as needed. A good practice is to declare all libraries in the same base class.</p> <pre><code>@JkDep(\"com.github.lalyos:jfiglet:0.0.9\")\n@JkDep(\"com.fasterxml.jackson:jackson-bom::pom:2.18.2\")\n@JkDep(\"com.fasterxml.jackson.core:jackson-core\")\n@JkDep(\"com.fasterxml.jackson.core:jackson-annotations\")\npublic class App {\n    ...\n}\n</code></pre> <p>See details on dependency notations.</p> <p>Additionally, you can copy-paste JAR files into the following directory to automatically include them as dependencies: <pre><code>\u251c\u2500\u2500 jeka-boot      &lt;- Jars included in the production classpath.\n</code></pre></p> <p>Declare non-prod dependencies</p> <p>Declare dependency on any class under <code>_dev</code> package, to add dependency with embedding them  in production.</p> <pre><code>import sun.lwawt.macosx.CWarningWindow;\n\n@JkDep(\"org.junit.jupiter:junit-jupiter:5.11.4\")\n@JkDep(\"org.mockito:mockito-junit-jupiter:5.15.2\")\nclass Custom extends KBean {\n    ...\n}\n</code></pre> <p>Reminder</p> <p>Don't forget to run <code>jeka intellij: iml</code> once you have modified the dependencies.</p>"},{"location":"tutorials/build-base/#run-your-application","title":"Run your Application","text":"<p>The application can be run using:  <pre><code>jeka --program arg0 args1 ... # or `jeka -p` for short\n</code></pre> To clean compilation before starting, use <code>--clean</code> option (<code>-c</code> for short).</p> <p>If ths source code is hosted in a Git repo, the application can be directly executed by referencing the repo as: <pre><code>jeka --remote [git repo url] --program arg0 arg1 ... # or jeka -r [git repo url] -p\n</code></pre></p>"},{"location":"tutorials/build-base/#make-it-native","title":"Make it Native","text":"<p>To compile in native, execute: <pre><code>jeka native: compile\n</code></pre> When done, execution of <code>jeka --program ...</code> will run the native version instead of the Java one.</p> <p>Notes</p> <p>You may set this properties if your application needs some resources to run <pre><code>@native.includeAllResources=true\n</code></pre></p> <p>If you want to force native build, set the following property: jeka.properties<pre><code>jeka.program.build=native: compile\n</code></pre></p>"},{"location":"tutorials/build-base/#dockerize","title":"Dockerize","text":"<p>If you want to create a Docker image of your application, execute: <pre><code>jeka docker: build\n</code></pre> This creates a Docker image based and registers it on your local Docker daemon.  The console output explains how to execute it.</p> <p>To create a Docker image based on native executable, execute: <pre><code>jeka docker: buildNative\n</code></pre></p>"},{"location":"tutorials/build-base/#pre-defined-build-commands","title":"Pre-defined Build Commands","text":"From *base* KBean<pre><code>jeka base: test       # Runs tests\njeka base: pack       # Runs tests + creates jars\njeka base: runJar     # Runs the jar generated by the above command\njeka base: info       # Displays project configuration info\njeka base: depTree    # Displays dependency trees \n</code></pre> <p>See here for extra commands.</p>"},{"location":"tutorials/build-base/#create-a-library","title":"Create a Library","text":"<p>If you want to write a library, instead of an application, you need to declare  both moduleId and versioning.</p> <p>The settings are similar for project building. Use 'base' instead of 'project', like this:</p> <pre><code>@base.moduleId=org.example:my-lib\n@base.version=1.0.0-SNAPSHOT\n</code></pre> <p>Now, you can publish your library by executing: <pre><code>jeka maven: publish\n</code></pre></p>"},{"location":"tutorials/build-projects/","title":"Build Projects","text":"<p>In this tutorial, we'll use the <code>project</code> KBean to build a Java application or library.  This KBean provides build methods and a project layout similar to those of Maven and Gradle.</p> <p>If you prefer a lighter structure, you can go to Build Base.</p> <p>Prerequisite: Jeka must be installed.</p> <p>Tip</p> <p>Run <code>jeka project: --doc</code> to see all available options.</p>"},{"location":"tutorials/build-projects/#scaffold-a-new-project","title":"Scaffold a New Project","text":"<p>Run <code>jeka project: scaffold</code> to create a standard project structure, ready for you to start coding right away.</p> <p>You\u2019ll get the following project structure: <pre><code>.\n\u251c\u2500\u2500 src                  \n\u2502   \u251c\u2500\u2500 main             &lt;- Java code and reources\n\u2502   \u2502   \u251c\u2500\u2500 java\n\u2502   \u2502   \u2514\u2500\u2500 resources    \n\u2502   \u2514\u2500\u2500 test             &lt;- Java code and reources for tests\n\u2502       \u251c\u2500\u2500 java\n\u2502       \u2514\u2500\u2500 resources \n\u251c\u2500\u2500 jeka-src             &lt;- Optional Java (or Kotlin) code for building the project\n\u2502   \u2514\u2500\u2500 Custom.java      \n\u251c\u2500\u2500 jeka-output          &lt;- Generated dir where artifacts as jars, classes, reports or doc are generated\n\u251c\u2500\u2500 dependencies.txt     &lt;- Dependency lists for compile, runtime and testing\n\u251c\u2500\u2500 jeka.properties      &lt;- Build configuration  (Java and jeka version, kben configurations, ...)\n\u251c\u2500\u2500 jeka.ps              &lt;- Optional Powershell script to boot Jeka on Windows\n\u251c\u2500\u2500 jeka                 &lt;- Optional bash script to boot Jeka on Linuw/MacOS\n\u2514\u2500\u2500 README.md            &lt;- Describes available build commands for building the project\n</code></pre></p> <p>The jeka.ps and jeka OS scripts are needed only if you want to build your project on a machine where Jeka is not installed. Build.java can also be removed if you don't need advanced settings.  </p> <p>You can choose a simpler code layout structure by setting the following properties: jeka.properties<pre><code>@project.layout.style=SIMPLE\n@project.layout.mixSourcesAndResources=true\n</code></pre> You'll end up with the following code layout: <pre><code>.\n\u251c\u2500\u2500 src       &lt;- Contains both Java code and resooources    \n\u251c\u2500\u2500 test      &lt;- Contains both Java code and resooources for testing\n</code></pre></p> <p>Additionally, you can copy-paste JAR files into the following directory structure to automatically include them as dependencies: <pre><code>.\n\u251c\u2500\u2500 libs                  \n\u2502   \u251c\u2500\u2500 compile          &lt;- Jars included in compile, runtime and test classpaths \n\u2502   \u251c\u2500\u2500 compile-only     &lt;- Jars included in compile and test classpaths\n\u2502   \u251c\u2500\u2500 runtime          &lt;- Jars included in runtime and test classpaths\n\u2502   \u2514\u2500\u2500 test             &lt;- Jars included in test classpath\n</code></pre></p>"},{"location":"tutorials/build-projects/#sync-with-intellij","title":"Sync with IntelliJ","text":"<p>Run: <code>jeka intellij: iml --force</code> to sync the project with IntelliJ. If changes don't appear in IntelliJ, go to the project's root directory, then run: <code>jeka intellij: initProject</code>.</p>"},{"location":"tutorials/build-projects/#add-dependencies","title":"Add Dependencies","text":"<p>Dependencies are listed in the dependencies.txt file as shown below:</p> dependencies.txt<pre><code>[version]    # define versions found in declared BOMs\norg.junit:junit-bom:5.12.2@pom\n\n[compile]\ncom.google.guava:guava:33.4.0-jre\ncom.google.code.gson:gson:2.13.1\n\n\n[compile-only]\norg.projectlombok:lombok:1.18.32\n\n[runtime]\norg.postgresql:postgresql:42.7.4\n\n[test]\norg.junit.jupiter:junit-jupiter\norg.junit.platform:junit-platform-launcher\n</code></pre> <p>Dependency versions declared in BOM can be imported in using the <code>@pom</code> prefix.  So we don't need to declare explicit versions for every dependency.</p> <p>Note</p> <p>When declared in [version] section, BOM applies to all dependencies within the project, including the sub-modules.</p> <p>You can also reference a local JAR by specifying its relative path, such as <code>mylibs/libs.jar</code>,  instead of using Maven coordinates.</p>"},{"location":"tutorials/build-projects/#specify-a-java-version-for-the-project","title":"Specify a Java version for the project.","text":"<p>By default, the project builds using the same Java version as the one running JeKa (defined in <code>jeka.java.version</code>). This can be overridden by specifying the <code>@project.javaVersion property</code>.</p>"},{"location":"tutorials/build-projects/#configure-jar-type","title":"Configure JAR Type","text":"<p>By default, JeKa produces regular JAR files.  You can configure it to create a fat JAR (JAR that includes all dependencies)  or a shade JAR (same as fat JAR but with relocated packages to avoid classpath collisions).</p> <p>To configure, edit jeka.properties and add: jeka.properties<pre><code>@project.pack.jarType=FAT\n</code></pre> This configures the project to create a single jar, also known as a fat jar. This is ideal for bundling applications. This properties accepts <code>REGULAR</code>, <code>FAT</code>, and <code>SHADE</code> values.</p> <p>If you are bundling a library, you may prefer to create an additional shade jar, in addition of the regular one, so consumers  can choose which one to pick.</p> <p>To do this, edit jeka.properties and add: jeka.properties<pre><code># Create an extra jar suffixed with 'all*\n@project.pack.shadeJarClassifier=all\n\n# Instruct Maven plugin to publish it as well.\n@maven.publication.extraArtifacts=all\n</code></pre></p>"},{"location":"tutorials/build-projects/#handle-versioning","title":"Handle Versioning","text":"<p>Setting a version or group/moduleId is optional. To set a specific version, add <code>@project.version=1.0-SNAPSHOT</code> to jeka.properties. jeka.properties<pre><code>@project.moduleId=org.mygroup:my-module-id\n@project.version=1.0.0-SNAPSHOT\n</code></pre> You can override any property by passing a command-line argument, for example: <code>-D@project.version=1.0.0</code>.</p> <p>A better approach might be to infer the version from Git. The version will be set to [TAG NAME] if the workspace is on a tag, or [BRANCH]-SNAPSHOT if it is not.</p> <p>The Manifest file will also include Git information (commit, dirty, branch, etc.). To enable this, use the following property: jeka.properties<pre><code>@project.gitVersioning.enable=true\n</code></pre></p>"},{"location":"tutorials/build-projects/#pre-defined-build-commands","title":"Pre-defined Build Commands","text":"Common Options<pre><code>--clean (-c)      # Deletes *jeka-output* dir prior running\n--verbose (-v)    # Displays verbos traces\n</code></pre> Run Code Directly<pre><code>jeka --program (-p) arg0 arg1 ...  # Runs the first native executable or jar found in *jeka-output*, execute a build prior if nothing found.\n</code></pre> From *project* KBean<pre><code>jeka project: compile    # Compiles sources\njeka project: test       # Compiles sources + runs tests\njeka project: pack       # Compiles sources + runs tests + creates jars\njeka project: runJar     # Runs the jar generated by the above command\njeka project: info       # Displays project configuration info\njeka project: depTree    # Displays dependency trees \n</code></pre> From *native* KBean<pre><code>jeka native: compile     # Compiles to native executable\n</code></pre> From *docker* KBean<pre><code>jeka docker: build          # Builds a Docker image for the project\njeka docker: info           # Displays info about generated image.\njeka docker: buildNative    # Builds a Docker image containing the native executable\njeka docker: infoNative     # Displays info about generated native image \n</code></pre> From *maven* KBean<pre><code>jeka maven: publishLocal      # Publish artifacts in the local repository\njeka maven: publish           # Publish in the defined Maven repository\n</code></pre>"},{"location":"tutorials/build-projects/#perform-static-analysis-using-sonarqube-and-jacoco","title":"Perform static analysis using SonarQube and JaCoCo","text":"<p>Jacoco and Sonarqube are not included in the Jeka distribution but are available as separate plugins. To use them, we need to add them to the classpath from Maven Central.</p> <p>Note</p> <p>We don't need to specify the plugin versions because Java can automatically select the correct one.</p> jeka.properties<pre><code>jeka.classpath=dev.jeka:sonarqube-plugin dev.jeka:jacoco-plugin\n@jacoco=\n\njeka.cmd.pack-quality=project: pack sonarqube: run\n\nsonar.host.url=http://localhost:9000\n</code></pre> <ul> <li><code>@jacoco=</code> initializes Jacoco KBean to run be run when project test willbe run.</li> <li><code>sonar.host.url=http://localhost:9000</code> SonarQube can be configured simply by setting the <code>sonar.*</code>properties.</li> </ul> <p>Build and run the project by running: <code>jeka project:pack sonarqube:run</code></p>"},{"location":"tutorials/build-projects/#configure-programmatically","title":"Configure Programmatically","text":"<p>By configuring the project programmatically, you gain full control: adding logic, extra tasks, or detailed configurations. The configuration can depend on any Java library by specifying its coordinates in a <code>@JkDep</code> annotation.</p> <p>Info</p> <p>Programmatic configuration complements properties-bases configuration, rather than replaces it. Properties configuration  are still effective until it is overridden by programmatic configuration.</p> jeka-src/Build.java<pre><code>@JkDep(\"org.apache.pdfbox:pdfbox:3.0.3\")\nclass Custom extends KBean {\n\n    @JkDoc(\"If true, the generated doc will include PDF documents\")\n    public boolean includePdfDoc;\n\n    @JkDoc(\"If true, the produced jar will include a JDBC driver\")\n    public boolean includeJdbcDriver;\n\n    @JkInject\n    private ProjectKBean projectKBean;\n\n    @JkDoc(\"Performs...\")\n    public void extraAction() {\n        // Perform an arbitrary action\n    }\n\n    // Configure MavenKbean to publish a 'doc' artifact and modify published dependencies\n    @JkPostInit\n    private void postInit(MavenKBean mavenKBean) {\n        mavenKBean.customizePublication(publication -&gt; {\n            publication.putArtifact(JkArtifactId.of(\"doc\", \"zip\"), this::generateDoc);\n            if (includeJdbcDriver) {\n                projectKBean.project.packaging.runtimeDependencies.add(\"org.postgresql:postgresql:42.7.4\");\n            }\n        });\n    }\n\n    private void generateDoc(File targetZipFile) {\n        Path docDir = getBaseDir().resolve(\"doc\");\n        if (includePdfDoc) {\n            // Create docs using pdf library...\n        }\n        JkPathTree.of(docDir).zipTo(targetZipFile);\n    }\n\n}\n</code></pre> <p>The <code>init()</code> method is designed for configuring the <code>JkProject</code> instance.</p> <p>The command <code>jeka extraAction includePdfDoc=true project: pack maven: publish</code> does:</p> <ul> <li>Executes the <code>extraAction</code> method.</li> <li>Create jar.</li> <li>Publish javadoc, sources, binary jars along the doc zip file containing PDF docs.   The javadoc and sources artifacts are automatically generated before publishing, if not already present.   The doc artifact is also created during publication, as it is explicitly registered.</li> </ul> <p>Note</p> <p>The <code>JkProject</code> class represents everything needed to build a JVM project. It i does:s a large object model that includes both configuration and methods to build the project. See Reference</p>"},{"location":"tutorials/run-remote-apps/","title":"Run Remote Applications","text":"<p>JeKa allows running or installing applications directly from their source code hosted on Git repository.</p>"},{"location":"tutorials/run-remote-apps/#run","title":"Run","text":"<p>You can have a look at the application catalog by executing: <pre><code>jeka app: catalog\n</code></pre></p> <p>To run directly an application, execute: <pre><code>jeka --remote &lt;git-url&gt; --program &lt;program arguments&gt;\n</code></pre> or <pre><code>jeka -r &lt;git-url&gt; -p &lt;program arguments&gt;\n</code></pre> Example: <pre><code>jeka --remote https://github.com/djeang/demo-dir-checksum --program -a SHA256\n</code></pre> you can pass <code>-Dxxxxx=yyyy</code> as program argument to set system properties.</p> <p>When you run it for the first time, Jeka will prompt you to confirm whether you trust the URL <code>github.com/djeang/demo-dir-checksum</code>. This is to prevent the execution of malicious code.</p> <p>If you accept, the application will build before running. On subsequent runs, it will execute directly, as the binaries are cached.</p> <p>Later you can edit the <code>[JEKA_HOME]/global.properties</code> file to adjust the trusted URLs.</p> <p>Example: <pre><code>jeka.app.url.trusted=github.com/djeang/\n</code></pre> In this example, we shorten the url, so that any url starting by <code>github.com/djeang/</code>will be trusted.</p>"},{"location":"tutorials/run-remote-apps/#run-a-specific-version","title":"Run a Specific Version","text":"<p>You can run a specific version of an application by specifying a tag name in the URL. For example:</p> <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay#0.0.6 -p \"Hello JeKa!\"\n</code></pre>"},{"location":"tutorials/run-remote-apps/#run-native-executables","title":"Run Native Executables","text":"<p>You can compile a remote application to a native executable. Once compiled, all subsequent runs will execute the native version of the application.</p> <p>To compile a remote application into a native executable, use the following command:</p> <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay#0.0.6 native: compile\n</code></pre> <p>After compilation, run the application as usual.</p>"},{"location":"tutorials/run-remote-apps/#build-docker-image-of-tha-application","title":"Build Docker Image of tha application","text":"<p>Jeka allow creating Docker images of a remote application.</p> <p>Create a JVM image: <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay docker: build\n</code></pre></p> <p>Create a native image: <pre><code>jeka -r https://github.com/jeka-dev/demo-cowsay docker: buildNative\n</code></pre> Then follow the instruction to run the built docker image.</p>"},{"location":"tutorials/run-remote-apps/#use-shorthands","title":"Use Shorthands","text":"<p>Typing and remembering the repository URL of the application for every run can be tedious. You can simplify this by using Jeka's global command shortcut substitution mechanism.</p> <p>For example, define the following property in your <code>~/.jeka/global.properties</code> file:</p> <p><pre><code>jeka.cmd.cowsay=-r https://github.com/jeka-dev/demo-cowsay#0.0.6 -p\n</code></pre> Now, you can invoke the application using the shortcut command: <pre><code>jeka ::cowsay \"Hello World!\"\n</code></pre></p>"},{"location":"tutorials/run-remote-apps/#install","title":"Install","text":"<p>JeKa lets you install apps for direct execution (no need to use <code>jeka</code>). Example:</p> <p><pre><code>jeka app: install repo=https://github.com/djeang/kill8\n</code></pre> Or <pre><code>jeka app: install repo=kill8@djeang\n</code></pre></p> <p>For a faster cold start, install the native version: <pre><code>jeka app: install repo=kill8@djeang native:\n</code></pre></p> <p>These commands install the <code>kill8</code> application in the user's PATH, allowing you to simply invoke the application by name to run it: <pre><code>kill8 8081\n</code></pre></p> <p>For more details, refer to the documentation.</p>"},{"location":"tutorials/run-remote-apps/#write-applications-for-direct-runinstallation","title":"Write Applications for Direct Run/Installation.","text":"<p>Applications built with Jeka are normally automatically made *source runnable\" by default.</p> <p>When Running a remote application for the first time, Jeka clones the directory then build it with <code>jeka base: pack</code>  or <code>jeka project: pack</code> if a project is detected.</p> <p>Then it looks in the jeka jeka-output dir to run the native or jar file.</p>"},{"location":"tutorials/run-remote-apps/#set-a-custom-build-command","title":"Set a Custom Build Command","text":"<p>If your project needs a specific build command or uses a tool like Maven, you can set the Jeka command for building.</p> <p>The command must be a Jeka KBean command, not a shell command.  For example, to build with Maven, you need to write a <code>Custom</code> Kbean defining the build method, and mention it in jeka.properties file.</p> <pre><code>jeka.program.build=custom: build\n\n## you can also specify the command for native builds\njeka.program.build.native=custom: build\n</code></pre> <pre><code>class Custom extends KBean {\n\n    @JkDoc(\"Build application and copy result in jeka-output in order to be run with '-p' option\")\n    public void build() {\n        mvn(\"clean package -DskipTests -Pnative\");\n        copyToJekaOutput();\n    }\n\n    private void mvn(String mvnArguments) {\n        JkLog.info(\"Executing mvn \" + mvnArguments);\n        String distrib = getRunbase().getProperties().get(\"jeka.java.distrib\", \"graalvm\");\n        String javaVersion = getRunbase().getProperties().get(\"jeka.java.version\", \"22\");\n        String distribFolder = distrib + \"-\" + javaVersion;\n        Path graalvmHome = JkLocator.getCacheDir().resolve(\"jdks\").resolve(distribFolder);\n        String newPath =  graalvmHome.resolve(\"bin\") + File.pathSeparator + System.getenv(\"PATH\");\n        JkProcess.ofWinOrUx(\"mvnw.cmd\", \"./mvnw\")\n                .addParamsAsCmdLine(mvnArguments)\n                .addParamsIf(System.getProperties().containsKey(\"jeka.test.skip\"), \"-Dmaven.test.skip=true\")\n                .setWorkingDir(getBaseDir())\n                .setEnv(\"JAVA_HOME\", graalvmHome.toString())\n                .setEnv(\"GRAALVM_HOME\", graalvmHome.toString())\n                .setEnv(\"PATH\", newPath)\n                .setInheritIO(true)\n                .exec();\n    }\n\n    private void copyToJekaOutput() {\n        JkPathTree.of(getBaseDir().resolve(\"target\")).andMatching(\"*.jar\", \"*-runner\")\n                .copyTo(getBaseDir().resolve(JkConstants.OUTPUT_PATH), StandardCopyOption.REPLACE_EXISTING);\n    }\n\n}\n</code></pre> <p>The main point is to keep the build portable, like using the Maven wrapper.</p>"}]}